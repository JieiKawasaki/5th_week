*** EVALUATION ***
ANSI-C/cC++ Compiler for HC08 V-5.0.41 Build 12319, Nov 15 2012

    1:  /*****************************************************************************
    2:  * MyWirelessApp Demo Beacon Coordinator application.
    3:  *
    4:  * (c) Copyright 2008, Freescale, Inc. All rights reserved.
    5:  *
    6:  *
    7:  * No part of this document must be reproduced in any form - including copied,
    8:  * transcribed, printed or by any electronic means - without specific written
    9:  * permission from Freescale Semiconductor.
   10:  *
   11:  *****************************************************************************/
   12:  
   13:  #include "MApp.h"
   14:  #include "Sound.h"
   15:  #include "NVM_Interface.h"
   16:  #include "CMT_interface.h"
   17:  #include "IIC_Interface.h" // New
   18:  
   19:  /************************************************************************************
   20:  *************************************************************************************
   21:  * Private macros
   22:  *************************************************************************************
   23:  ************************************************************************************/
   24:  
   25:  /* If there are too many pending packets to be send over the air, */
   26:  /* receive mMaxKeysToReceive_c chars. */
   27:  /* The chars will be send over the air when there are no pending packets*/
   28:  #define mMaxKeysToReceive_c 32
   29:  
   30:  //----------Sensor switch--------
   31:  #define gMPL3115A2_enable 0
   32:  #define gMMA8652_enable   0
   33:  #define gMAG3110_enable   0
   34:  #define gFXAS21000_enable 0
   35:  #define gMMA9553_enable   0
   36:  //-------------------------------
   37:  
   38:  /************************************************************************************
   39:  *************************************************************************************
   40:  * Private prototypes
   41:  *************************************************************************************
   42:  ************************************************************************************/
   43:  
   44:  /* Forward declarations of helper functions */
   45:  static void    UartRxCallBack(void);
   46:  static uint8_t App_StartScan(uint8_t scanType);
   47:  static void    App_HandleScanEdConfirm(nwkMessage_t *pMsg);
   48:  static uint8_t App_StartCoordinator(void);
   49:  static uint8_t App_HandleMlmeInput(nwkMessage_t *pMsg);
   50:  static uint8_t App_SendAssociateResponse(nwkMessage_t *pMsgIn);
   51:  static void    App_HandleMcpsInput(mcpsToNwkMessage_t *pMsgIn);
   52:  static void    App_TransmitUartData(void);
   53:  static uint8_t App_WaitMsg(nwkMessage_t *pMsg, uint8_t msgType);
   54:  #if (gMC1323xMatrixKBD_d == TRUE)
   55:  static void    App_HandleKeys(uint8_t events, uint8_t pressedKey);
   56:  #else
   57:  static void    App_HandleKeys(key_event_t events);
   58:  #endif //gMC1323xMatrixKBD_d
   59:  
   60:  /************************************************************************************
   61:  *************************************************************************************
   62:  * Private type definitions
   63:  *************************************************************************************
   64:  ************************************************************************************/
   65:  
   66:  
   67:  /************************************************************************************
   68:  *************************************************************************************
   69:  * Private memory declarations
   70:  *************************************************************************************
   71:  ************************************************************************************/
   72:  
   73:  /* The short address and PAN ID of the coordinator*/
   74:  static const uint8_t maShortAddress[2] = { (mDefaultValueOfShortAddress_c & 0xff), (mDefaultValueOfShortAddress_c >> 8)};
   75:  static const uint8_t maPanId[2] = { (mDefaultValueOfPanId_c & 0xff), (mDefaultValueOfPanId_c >> 8)};
   76:  
   77:  /* The current logical channel (frequency band) */
   78:  static uint8_t mLogicalChannel;
   79:  
   80:  /* These byte arrays stores an associated
   81:     devices long and short addresses. */
   82:  static uint8_t maDeviceShortAddress[2];
   83:  static uint8_t maDeviceLongAddress[8];
   84:  
   85:  /* Data request packet for sending UART input to the coordinator */
   86:  static nwkToMcpsMessage_t *mpPacket;
   87:  
   88:  /* The MSDU handle is a unique data packet identifier */
   89:  static uint8_t mMsduHandle;
   90:  
   91:  /* Number of pending data packets */
   92:  static uint8_t mcPendingPackets;
   93:  
   94:  /* Application input queues */
   95:  static anchor_t mMlmeNwkInputQueue;
   96:  static anchor_t mMcpsNwkInputQueue;
   97:  
   98:  /************************************************************************************
   99:  *************************************************************************************
  100:  * Public memory declarations
  101:  *************************************************************************************
  102:  ************************************************************************************/
  103:  
  104:  /* The current state of the applications state machine */
  105:  uint8_t gState;
  106:  
  107:  uint8_t MPL3115A2_start_flag = 0;
  108:  uint8_t MMA8652_start_flag   = 0;
  109:  uint8_t MAG3110_start_flag   = 0;
  110:  uint8_t FXAS21000_start_flag = 0;
  111:  uint8_t MMA9553_start_flag   = 0;
  112:  
  113:  /* This data set contains application variables to be preserved across resets */
  114:  NvDataItemDescription_t const gaNvAppDataSet[] = {
  115:    {NULL, 0}       /* Required end-of-table marker. */
  116:  };
  117:  
  118:  /************************************************************************************
  119:  *************************************************************************************
  120:  * Public functions
  121:  *************************************************************************************
  122:  ************************************************************************************/
  123:  
  124:  void DeepSleepWakeupStackProc(void);
  125:  
  126:  /*****************************************************************************
  127:  * Initialization function for the App Task. This is called during
  128:  * initialization and should contain any application specific initialization
  129:  * (ie. hardware initialization/setup, table initialization, power up
  130:  * notificaiton.
  131:  *
  132:  * Interface assumptions: None
  133:  *
  134:  * Return value: None
  135:  *
  136:  *****************************************************************************/
  137:  
  138:  void MApp_init(void)
  139:  { 
  140:    /* The initial application state */
  141:    gState = stateInit; 
  0000 4f       [1]             CLRA  
  0001 c70000   [4]             STA   gState
  142:    /* Reset number of pending packets */
  143:    mcPendingPackets = 0;   
  0004 c70000   [4]             STA   mcPendingPackets
  144:  
  145:    /* Initialize the MAC 802.15.4 extended address */
  146:    Init_MacExtendedAddress();
  0007 ac000000 [8]             CALL  Init_MacExtendedAddress
  147:    /* register keyboard callback function */
  148:    KBD_Init(App_HandleKeys);
  000b 450000   [3]             LDHX  @App_HandleKeys
  000e 89       [2]             PSHX  
  000f 8b       [2]             PSHH  
  0010 a600     [2]             LDA   @App_HandleKeys:PAGE
  0012 87       [2]             PSHA  
  0013 ac000000 [8]             CALL  KBD_Init
  0017 a703     [2]             AIS   #3
  149:    /* Initialize SPI Module */
  150:    SPI_Init();
  0019 ac000000 [8]             CALL  SPI1_Init
  151:    /* initialize LCD Module */
  152:    LCD_Init();
  153:    /* initialize LED Module */
  154:    LED_Init();
  001d ac000000 [8]             CALL  LED_Init
  155:    /* Initialize the LPM module */
  156:    PWRLib_Init();
  0021 ac000000 [8]             CALL  PWRLib_Init
  157:    /* Initialize the UART so that we can print out status messages */
  158:    UartX_SetBaud(gUartDefaultBaud_c);
  0025 ae34     [2]             LDX   #52
  0027 8c       [1]             CLRH  
  0028 ac000000 [8]             CALL  Uart1_SetBaud
  159:    UartX_SetRxCallBack(UartRxCallBack);
  002c 450000   [3]             LDHX  @UartRxCallBack
  002f 89       [2]             PSHX  
  0030 8b       [2]             PSHH  
  0031 a600     [2]             LDA   @UartRxCallBack:PAGE
  0033 87       [2]             PSHA  
  0034 ac000000 [8]             CALL  Uart1_SetRxCallBack
  0038 a703     [2]             AIS   #3
  160:    
  161:    /* Initialize the IIC module */
  162:    IIC_Bus_Reset();  // Reset IIC bus to prevent freezing sensor module using GPIO 
  003a ac000000 [8]             CALL  IIC_Bus_Reset
  163:    IIC_ModuleInit(); // New      
  003e ac000000 [8]             CALL  IIC_ModuleInit
  164:        
  165:  #if gMPL3115A2_enable
  166:    MPL3115A2_Init();
  167:  #endif
  168:    
  169:  #if gMMA8652_enable
  170:    MMA8652_Init();
  171:  #endif   
  172:  
  173:  #if gMAG3110_enable
  174:    MAG3110_Init();
  175:  #endif 
  176:    
  177:  #if gFXAS21000_enable
  178:    FXAS21000_Init();
  179:  #endif 
  180:   
  181:  #if gMMA9553_enable
  182:    MMA9553_Init();
  183:  #endif   
  184:    
  185:    /* initialize buzzer (NCB, SRB only) */  
  186:    BuzzerInit();  
  187:    /* Prepare input queues.*/  
  188:    MSG_InitQueue(&mMlmeNwkInputQueue); 
  0042 450000   [3]             LDHX  @mMlmeNwkInputQueue
  0045 ac000000 [8]             CALL  List_ClearAnchor
  189:    MSG_InitQueue(&mMcpsNwkInputQueue); 
  0049 450000   [3]             LDHX  @mMcpsNwkInputQueue
  004c ac000000 [8]             CALL  List_ClearAnchor
  190:    /* Enable MCU interrupts */
  191:    IrqControlLib_EnableAllIrqs();
  0050 9a       [1]             CLI   
  192:    /*signal app ready*/  
  193:    Led1Flashing();
  0051 a601     [2]             LDA   #1
  0053 ac000000 [8]             CALL  LED_StartFlash
  194:    Led2Flashing();
  0057 a602     [2]             LDA   #2
  0059 ac000000 [8]             CALL  LED_StartFlash
  195:    Led3Flashing();
  005d a604     [2]             LDA   #4
  005f ac000000 [8]             CALL  LED_StartFlash
  196:    Led4Flashing();
  0063 a608     [2]             LDA   #8
  0065 ac000000 [8]             CALL  LED_StartFlash
  197:      
  198:    UartUtil_Print("\n\rPress any switch on board to start running the application.\n\r", gAllowToBlock_d);  
  0069 450000   [3]             LDHX  @"\012\015Press any switch on board to start running the application.\012\015"
  006c a601     [2]             LDA   #1
  006e ac000000 [8]             CALL  UartUtil_Print
  199:    LCD_ClearDisplay();
  200:    LCD_WriteString(1,"Press any key");
  201:    LCD_WriteString(2,"to start.");
  202:  }
  0072 8d       [7]             RTC   
  203:  
  204:  
  205:  /*****************************************************************************
  206:  *Mac Application Task event processor.  This function is called to
  207:  * process all events for the task. Events include timers, messages and any
  208:  * other user defined events
  209:  *
  210:  * Interface assumptions: None
  211:  *
  212:  * Return value: None
  213:  *****************************************************************************/
  214:  /* The Application Task */
  215:  void AppTask(event_t events)
  216:  {   /* Pointer for storing the messages from MLME */
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  0002 a7fe     [2]             AIS   #-2
  217:    void *pMsgIn;
  218:    /* Stores the error/success code returned by some functions. */
  219:    uint8_t ret;
  220:    cmtErr_t ret_cmt;
  221:    pMsgIn = NULL;
  0004 9e6f02   [6]             CLR   2,SP
  0007 9e6f01   [6]             CLR   1,SP
  222:    
  223:    /* Dequeue the MLME message */
  224:    if (events & gAppEvtMessageFromMLME_c)
  000a 9f       [1]             TXA   
  000b a504     [2]             BIT   #4
  000d 2726     [3]             BEQ   L35 ;abs = 0035
  225:    {
  226:      /* Get the message from MLME */
  227:      pMsgIn = MSG_DeQueue(&mMlmeNwkInputQueue);
  000f 450000   [3]             LDHX  @mMlmeNwkInputQueue
  0012 ac000000 [8]             CALL  List_RemoveHead
  0016 9eff01   [5]             STHX  1,SP
  228:      
  229:      /* Any time a beacon might arrive. Always handle the beacon frame first */
  230:      if (pMsgIn)
  0019 271a     [3]             BEQ   L35 ;abs = 0035
  231:      {               
  232:        ret = App_WaitMsg(pMsgIn, gNwkBeaconNotifyInd_c);
  001b a604     [2]             LDA   #4
  001d ac000000 [8]             CALL  App_WaitMsg
  233:        if(ret == errorNoError)
  0021 4d       [1]             TSTA  
  0022 2611     [3]             BNE   L35 ;abs = 0035
  234:        {
  235:          /* ALWAYS free the beacon frame contained in the beacon notify indication.*/
  236:          /* ALSO the application can use the beacon payload.*/
  237:          MSG_Free(((nwkMessage_t *)pMsgIn)->msgData.beaconNotifyInd.pBufferRoot);
  0024 9efe01   [5]             LDHX  1,SP
  0027 9ece0a   [5]             LDHX  10,X
  002a ac000000 [8]             CALL  MM_Free
  238:          UartUtil_Print("Received an MLME-Beacon Notify Indication\n\r", gAllowToBlock_d);
  002e 450000   [3]             LDHX  @"Received an MLME-Beacon Notify Indication\012\015"
  0031 ac0001a0 [8]             CALL  AppTask:416
  0035          L35:    
  239:        }
  240:      }
  241:    }
  242:    /* The application state machine */
  243:    switch(gState)
  0035 c60000   [4]             LDA   gState
  0038 a105     [2]             CMP   #5
  003a 221a     [3]             BHI   L56 ;abs = 0056
  003c 4d       [1]             TSTA  
  003d 2719     [3]             BEQ   L58 ;abs = 0058
  003f 410122   [4]             CBEQA #1,L64 ;abs = 0064
  0042 410232   [4]             CBEQA #2,L77 ;abs = 0077
  0045 410357   [4]             CBEQA #3,L9F ;abs = 009f
  0048 a104     [2]             CMP   #4
  004a 2603     [3]             BNE   L4F ;abs = 004f
  004c cc00d0   [4]             JMP   LD0 ;abs = 00d0
  004f          L4F:    
  004f a105     [2]             CMP   #5
  0051 267b     [3]             BNE   LCE ;abs = 00ce
  0053 cc0119   [4]             JMP   L119 ;abs = 0119
  0056          L56:    
  0056 2076     [3]             BRA   LCE ;abs = 00ce
  0058          L58:    
  244:    {
  245:    case stateInit:       
  246:      /* Print a welcome message to the UART */
  247:      UartUtil_Print(" MyWirelessApp Demo Beacon Coordinator application is initialized and ready.\n\r\n\r", gAllowToBlock_d);            
  0058 450000   [3]             LDHX  @" MyWirelessApp Demo Beacon Coordinator application is initialized and ready.\012\015\012\015"
  005b ac0001a0 [8]             CALL  AppTask:416
  248:      /* Goto Energy Detection state. */
  249:      gState = stateScanEdStart;
  005f a601     [2]             LDA   #1
  250:      TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);    
  251:      break;
  0061 cc010a   [4]             JMP   L10A ;abs = 010a
  0064          L64:    
  252:      
  253:    case stateScanEdStart:
  254:      /* Start the Energy Detection scan, and goto wait for confirm state. */
  255:      UartUtil_Print("Initiating the Energy Detection Scan\n\r", gAllowToBlock_d);
  0064 450000   [3]             LDHX  @"Initiating the Energy Detection Scan\012\015"
  0067 ac0001a0 [8]             CALL  AppTask:416
  256:      /*Print the message on the LCD also*/
  257:      LCD_ClearDisplay();
  258:      LCD_WriteString(1,"Starting Energy");
  259:      LCD_WriteString(2,"Detection Scan");      
  260:      ret = App_StartScan(gScanModeED_c);
  006b 4f       [1]             CLRA  
  006c ac000000 [8]             CALL  App_StartScan
  261:      if(ret == errorNoError)
  0070 4d       [1]             TSTA  
  0071 265b     [3]             BNE   LCE ;abs = 00ce
  262:      {
  263:        gState = stateScanEdWaitConfirm;
  0073 a602     [2]             LDA   #2
  0075 2054     [3]             BRA   LCB ;abs = 00cb
  0077          L77:    
  264:      }
  265:      break;
  266:      
  267:    case stateScanEdWaitConfirm:
  268:      /* Stay in this state until the MLME Scan confirm message arrives,
  269:         and has been processed. Then goto Start Coordinator state. */
  270:      if (events & gAppEvtMessageFromMLME_c)
  0077 95       [2]             TSX   
  0078 e603     [3]             LDA   3,X
  007a a504     [2]             BIT   #4
  007c 2750     [3]             BEQ   LCE ;abs = 00ce
  271:      {
  272:        if (pMsgIn)
  007e 9efe01   [5]             LDHX  1,SP
  0081 274b     [3]             BEQ   LCE ;abs = 00ce
  273:        {
  274:          ret = App_WaitMsg(pMsgIn, gNwkScanCnf_c);
  0083 a60b     [2]             LDA   #11
  0085 ac000000 [8]             CALL  App_WaitMsg
  275:          if(ret == errorNoError)
  0089 4d       [1]             TSTA  
  008a 2642     [3]             BNE   LCE ;abs = 00ce
  276:          {
  277:            /* Process the ED scan confirm. The logical
  278:               channel is selected by this function. */
  279:            App_HandleScanEdConfirm(pMsgIn);
  008c 9efe01   [5]             LDHX  1,SP
  008f ac000000 [8]             CALL  App_HandleScanEdConfirm
  280:            /* Go to the Start Coordinator state */
  281:            gState = stateStartCoordinator;
  0093 a603     [2]             LDA   #3
  0095 c70000   [4]             STA   gState
  282:            TS_SendEvent(gAppTaskID_c, gAppEvtStartCoordinator_c);
  0098 c60000   [4]             LDA   gAppTaskID_c
  009b ae10     [2]             LDX   #16
  009d 2073     [3]             BRA   L112 ;abs = 0112
  009f          L9F:    
  283:          }
  284:        }
  285:      }
  286:      break;
  287:      
  288:  
  289:    case stateStartCoordinator:
  290:      if (events & gAppEvtStartCoordinator_c)
  009f 95       [2]             TSX   
  00a0 e603     [3]             LDA   3,X
  00a2 a510     [2]             BIT   #16
  00a4 2728     [3]             BEQ   LCE ;abs = 00ce
  291:      {
  292:        /* Start up as a PAN Coordinator on the selected channel. */
  293:        UartUtil_Print("\n\rStarting as PAN coordinator on channel 0x", gAllowToBlock_d);
  00a6 450000   [3]             LDHX  @"\012\015Starting as PAN coordinator on channel 0x"
  00a9 ac0001a0 [8]             CALL  AppTask:416
  294:        UartUtil_PrintHex(&mLogicalChannel, 1, FALSE);
  00ad 450000   [3]             LDHX  @mLogicalChannel
  00b0 89       [2]             PSHX  
  00b1 8b       [2]             PSHH  
  00b2 ae01     [2]             LDX   #1
  00b4 4f       [1]             CLRA  
  00b5 ac000000 [8]             CALL  UartUtil_PrintHex
  00b9 a702     [2]             AIS   #2
  295:        UartUtil_Print("\n\r", gAllowToBlock_d);
  00bb 450000   [3]             LDHX  @"\012\015"
  00be ac0001a0 [8]             CALL  AppTask:416
  296:        /*print a message on the LCD also*/
  297:        LCD_ClearDisplay();
  298:        LCD_WriteString(1,"Starting");
  299:        LCD_WriteString(2,"PAN coordinator");
  300:        ret = App_StartCoordinator();
  00c2 ac000000 [8]             CALL  App_StartCoordinator
  301:        if(ret == errorNoError)
  00c6 4d       [1]             TSTA  
  00c7 266b     [3]             BNE   L134 ;abs = 0134
  302:        {
  303:          /* If the Start request was sent successfully to
  304:             the MLME, then goto Wait for confirm state. */
  305:          gState = stateStartCoordinatorWaitConfirm;
  00c9 a604     [2]             LDA   #4
  00cb          LCB:    
  00cb c70000   [4]             STA   gState
  00ce          LCE:    
  00ce 2064     [3]             BRA   L134 ;abs = 0134
  00d0          LD0:    
  306:        }
  307:      }
  308:      break; 
  309:  
  310:    case stateStartCoordinatorWaitConfirm:
  311:      /* Stay in this state until the Start confirm message
  312:         arrives, and then goto the Listen state. */
  313:      if (events & gAppEvtMessageFromMLME_c)
  00d0 95       [2]             TSX   
  00d1 e603     [3]             LDA   3,X
  00d3 a504     [2]             BIT   #4
  00d5 275d     [3]             BEQ   L134 ;abs = 0134
  314:      {
  315:        if (pMsgIn)
  00d7 9efe01   [5]             LDHX  1,SP
  00da 2758     [3]             BEQ   L134 ;abs = 0134
  316:        {    
  317:          ret = App_WaitMsg(pMsgIn, gNwkStartCnf_c);
  00dc a60e     [2]             LDA   #14
  00de ac000000 [8]             CALL  App_WaitMsg
  318:          if(ret == errorNoError)
  00e2 4d       [1]             TSTA  
  00e3 264f     [3]             BNE   L134 ;abs = 0134
  319:          {
  320:            UartUtil_Print("Started the coordinator with PAN ID 0x", gAllowToBlock_d);
  00e5 450000   [3]             LDHX  @"Started the coordinator with PAN ID 0x"
  00e8 ac0001a0 [8]             CALL  AppTask:416
  321:            UartUtil_PrintHex((uint8_t *)maPanId, 2, 0);
  00ec 450000   [3]             LDHX  @maPanId
  00ef ac0001a7 [8]             CALL  AppTask:423
  322:            UartUtil_Print(", and short address 0x", gAllowToBlock_d);
  00f3 450000   [3]             LDHX  @", and short address 0x"
  00f6 ac0001a0 [8]             CALL  AppTask:416
  323:            UartUtil_PrintHex((uint8_t *)maShortAddress, 2, 0);
  00fa 450000   [3]             LDHX  @maShortAddress
  00fd ac0001a7 [8]             CALL  AppTask:423
  324:            UartUtil_Print(".\n\r\n\rReady to send and receive data over the UART.\n\r\n\r", gAllowToBlock_d);
  0101 450000   [3]             LDHX  @".\012\015\012\015Ready to send and receive data over the UART.\012\015\012\015"
  0104 ac0001a0 [8]             CALL  AppTask:416
  325:            /*print a message on the LCD also*/
  326:            LCD_ClearDisplay();
  327:            LCD_WriteString(1,"Ready to send");
  328:            LCD_WriteString(2,"and receive data");
  329:            gState = stateListen;
  0108 a605     [2]             LDA   #5
  010a          L10A:   
  010a c70000   [4]             STA   gState
  330:            TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);
  010d c60000   [4]             LDA   gAppTaskID_c
  0110 ae01     [2]             LDX   #1
  0112          L112:   
  0112 8c       [1]             CLRH  
  0113 ac000000 [8]             CALL  TS_SendEvent
  0117 201b     [3]             BRA   L134 ;abs = 0134
  0119          L119:   
  331:          }
  332:        }
  333:      }
  334:      break; 
  335:      
  336:    case stateListen:
  337:      /* Stay in this state forever. 
  338:         Transmit the data received on UART */
  339:      if (events & gAppEvtMessageFromMLME_c)
  0119 95       [2]             TSX   
  011a e603     [3]             LDA   3,X
  011c a504     [2]             BIT   #4
  011e 2709     [3]             BEQ   L129 ;abs = 0129
  340:      {
  341:        /* Get the message from MLME */
  342:        if (pMsgIn)
  0120 9efe01   [5]             LDHX  1,SP
  0123 2704     [3]             BEQ   L129 ;abs = 0129
  343:        {      
  344:          /* Process it */
  345:          ret = App_HandleMlmeInput(pMsgIn);
  0125 ac000000 [8]             CALL  App_HandleMlmeInput
  0129          L129:   
  346:          /* Messages from the MLME must always be freed. */
  347:        }
  348:      }
  349:  
  350:      if (events & gAppEvtRxFromUart_c)
  0129 95       [2]             TSX   
  012a e603     [3]             LDA   3,X
  012c a502     [2]             BIT   #2
  012e 2704     [3]             BEQ   L134 ;abs = 0134
  351:      {      
  352:        /* get byte from UART */
  353:        App_TransmitUartData();
  0130 ac000000 [8]             CALL  App_TransmitUartData
  0134          L134:   
  354:      
  355:      }  
  356:      break;
  357:    }
  358:    
  359:    if (pMsgIn)
  0134 9efe01   [5]             LDHX  1,SP
  0137 2704     [3]             BEQ   L13D ;abs = 013d
  360:    {
  361:      /* Messages must always be freed. */ 
  362:      MSG_Free(pMsgIn);
  0139 ac000000 [8]             CALL  MM_Free
  013d          L13D:   
  363:    }
  364:    
  365:    if (events & gAppEvtMessageFromMCPS_c)
  013d 95       [2]             TSX   
  013e e603     [3]             LDA   3,X
  0140 a508     [2]             BIT   #8
  0142 271b     [3]             BEQ   L15F ;abs = 015f
  366:    {      
  367:       /* Get the message from MCPS */
  368:      pMsgIn = MSG_DeQueue(&mMcpsNwkInputQueue);
  0144 450000   [3]             LDHX  @mMcpsNwkInputQueue
  0147 ac000000 [8]             CALL  List_RemoveHead
  369:      if (pMsgIn)
  014b 650000   [3]             CPHX  #0
  014e 270f     [3]             BEQ   L15F ;abs = 015f
  370:      {
  371:        /* Process it */
  372:        App_HandleMcpsInput(pMsgIn);
  0150 89       [2]             PSHX  
  0151 8b       [2]             PSHH  
  0152 ac000000 [8]             CALL  App_HandleMcpsInput
  373:        /* Messages from the MCPS must always be freed. */
  374:        MSG_Free(pMsgIn);
  0156 9efe01   [5]             LDHX  1,SP
  0159 ac000000 [8]             CALL  MM_Free
  015d a702     [2]             AIS   #2
  015f          L15F:   
  375:      }
  376:    }  
  377:    
  378:    
  379:    /* Check for pending messages in the Queue */ 
  380:    if(MSG_Pending(&mMcpsNwkInputQueue))
  015f 320000   [5]             LDHX  mMcpsNwkInputQueue
  0162 270a     [3]             BEQ   L16E ;abs = 016e
  381:      TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMCPS_c);
  0164 c60000   [4]             LDA   gAppTaskID_c
  0167 ae08     [2]             LDX   #8
  0169 8c       [1]             CLRH  
  016a ac000000 [8]             CALL  TS_SendEvent
  016e          L16E:   
  382:    if(MSG_Pending(&mMlmeNwkInputQueue))
  016e 320000   [5]             LDHX  mMlmeNwkInputQueue
  0171 270a     [3]             BEQ   L17D ;abs = 017d
  383:      TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMLME_c);  
  0173 c60000   [4]             LDA   gAppTaskID_c
  0176 ae04     [2]             LDX   #4
  0178 8c       [1]             CLRH  
  0179 ac000000 [8]             CALL  TS_SendEvent
  017d          L17D:   
  384:   
  385:     while(CMT_IsTxActive()); // Wait until ready for next transmission
  017d ac000000 [8]             CALL  CMT_IsTxActive
  0181 4d       [1]             TSTA  
  0182 26f9     [3]             BNE   L17D ;abs = 017d
  386:     (void)CMT_TxBits(0xff,8);
  0184 aeff     [2]             LDX   #-1
  0186 a608     [2]             LDA   #8
  0188 ac000000 [8]             CALL  CMT_TxBits
  018c          L18C:   
  387:     while(CMT_IsTxActive());
  018c ac000000 [8]             CALL  CMT_IsTxActive
  0190 4d       [1]             TSTA  
  0191 26f9     [3]             BNE   L18C ;abs = 018c
  388:     TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);
  0193 c60000   [4]             LDA   gAppTaskID_c
  0196 ae01     [2]             LDX   #1
  0198 8c       [1]             CLRH  
  0199 ac000000 [8]             CALL  TS_SendEvent
  389:  }
  019d a704     [2]             AIS   #4
  019f 8d       [7]             RTC   
  01a0          L1A0:   
  01a0 a601     [2]             LDA   #1
  01a2 ac000000 [8]             CALL  UartUtil_Print
  01a6 8d       [7]             RTC   
  01a7          L1A7:   
  01a7 89       [2]             PSHX  
  01a8 8b       [2]             PSHH  
  01a9 ae02     [2]             LDX   #2
  01ab 4f       [1]             CLRA  
  01ac ac000000 [8]             CALL  UartUtil_PrintHex
  01b0 a702     [2]             AIS   #2
  01b2 8d       [7]             RTC   
  390:  
  391:  
  392:  /************************************************************************************
  393:  *************************************************************************************
  394:  * Private functions
  395:  *************************************************************************************
  396:  ************************************************************************************/
  397:  
  398:  /*****************************************************************************
  399:  * UartRxCallBack
  400:  *
  401:  * This callback is triggered when a new byte is received over the UART
  402:  *
  403:  *****************************************************************************/
  404:  static void UartRxCallBack(void) 
  405:  {
  0000 8b       [2]             PSHH  
  406:    uint8_t pressedKey;
  407:  	if(stateListen == gState){
  0001 c60000   [4]             LDA   gState
  0004 a105     [2]             CMP   #5
  0006 260c     [3]             BNE   L14 ;abs = 0014
  408:      TS_SendEvent(gAppTaskID_c, gAppEvtRxFromUart_c);
  0008 c60000   [4]             LDA   gAppTaskID_c
  000b ae02     [2]             LDX   #2
  000d 8c       [1]             CLRH  
  000e ac000000 [8]             CALL  TS_SendEvent
  409:    }else{
  410:  	  (void)UartX_GetByteFromRxBuffer(&pressedKey);
  411:    }
  412:  }
  0012 8a       [3]             PULH  
  0013 8d       [7]             RTC   
  0014          L14:    
  0014 95       [2]             TSX   
  0015 ac000000 [8]             CALL  Uart1_GetByteFromRxBuffer
  0019 8a       [3]             PULH  
  001a 8d       [7]             RTC   
  413:  
  414:  /******************************************************************************
  415:  * The App_StartScan(scanType) function will start the scan process of the
  416:  * specified type in the MAC. This is accomplished by allocating a MAC message,
  417:  * which is then assigned the desired scan parameters and sent to the MLME
  418:  * service access point.
  419:  * The function may return either of the following values:
  420:  *   errorNoError:          The Scan message was sent successfully.
  421:  *   errorInvalidParameter: The MLME service access point rejected the
  422:  *                          message due to an invalid parameter.
  423:  *   errorAllocFailed:      A message buffer could not be allocated.
  424:  *
  425:  ******************************************************************************/
  426:  static uint8_t App_StartScan(uint8_t scanType)
  427:  {
  0000 87       [2]             PSHA  
  0001 a7fe     [2]             AIS   #-2
  428:    mlmeMessage_t *pMsg;
  429:    mlmeScanReq_t *pScanReq;
  430:  
  431:    UartUtil_Print("Sending the MLME-Scan Request message to the MAC...", gAllowToBlock_d);
  0003 450000   [3]             LDHX  @"Sending the MLME-Scan Request message to the MAC..."
  0006 ac000055 [8]             CALL  App_StartScan:85
  432:  
  433:    /* Allocate a message for the MLME (We should check for NULL). */
  434:    pMsg = MSG_AllocType(mlmeMessage_t);
  000a a60f     [2]             LDA   #15
  000c ac000000 [8]             CALL  MM_Alloc
  0010 9eff01   [5]             STHX  1,SP
  435:    if(pMsg != NULL)
  0013 2734     [3]             BEQ   L49 ;abs = 0049
  436:    {
  437:      /* This is a MLME-SCAN.req command */
  438:      pMsg->msgType = gMlmeScanReq_c;
  0015 a608     [2]             LDA   #8
  0017 f7       [2]             STA   ,X
  439:      /* Create the Scan request message data. */
  440:      pScanReq = &pMsg->msgData.scanReq;
  441:      /* gScanModeED_c, gScanModeActive_c, gScanModePassive_c, or gScanModeOrphan_c */
  442:      pScanReq->scanType = scanType;
  0018 9ee603   [4]             LDA   3,SP
  001b e701     [3]             STA   1,X
  443:      /* ChannelsToScan & 0xFF - LSB, always 0x00 */
  444:      pScanReq->scanChannels[0] = (uint8_t)((mDefaultValueOfChannel_c)     & 0xFF);
  001d 6f02     [5]             CLR   2,X
  445:      /* ChannelsToScan>>8 & 0xFF  */
  446:      pScanReq->scanChannels[1] = (uint8_t)((mDefaultValueOfChannel_c>>8)  & 0xFF);
  001f 6f03     [5]             CLR   3,X
  447:      /* ChannelsToScan>>16 & 0xFF  */
  448:      pScanReq->scanChannels[2] = (uint8_t)((mDefaultValueOfChannel_c>>16) & 0xFF);
  0021 6f04     [5]             CLR   4,X
  449:      /* ChannelsToScan>>24 & 0xFF - MSB */
  450:      pScanReq->scanChannels[3] = (uint8_t)((mDefaultValueOfChannel_c>>24) & 0xFF);
  0023 a602     [2]             LDA   #2
  0025 e705     [3]             STA   5,X
  451:      /* Duration per channel 0-14 (dc). T[sec] = (16*960*((2^dc)+1))/1000000.
  452:         A scan duration of 3 on 16 channels approximately takes 2 secs. */
  453:      pScanReq->scanDuration = 3;
  0027 4c       [1]             INCA  
  0028 e706     [3]             STA   6,X
  454:  #ifdef gMAC2006_d
  455:  	pScanReq->securityLevel = 0;
  456:  #endif //gMAC2006	
  457:      
  458:      /* Send the Scan request to the MLME. */
  459:      if(MSG_Send(NWK_MLME, pMsg) == gSuccess_c)
  002a 9efe01   [5]             LDHX  1,SP
  002d ac000000 [8]             CALL  NWK_MLME_SapHandler
  0031 4d       [1]             TSTA  
  0032 260a     [3]             BNE   L3E ;abs = 003e
  460:      {
  461:        UartUtil_Print("Done\n\r", gAllowToBlock_d);
  0034 450000   [3]             LDHX  @"Done\012\015"
  0037 ac000055 [8]             CALL  App_StartScan:85
  462:        return errorNoError;
  003b 4f       [1]             CLRA  
  003c 2014     [3]             BRA   L52 ;abs = 0052
  003e          L3E:    
  463:      }
  464:      else
  465:      {
  466:        UartUtil_Print("Invalid parameter!\n\r", gAllowToBlock_d);
  003e 450000   [3]             LDHX  @"Invalid parameter!\012\015"
  0041 ac000055 [8]             CALL  App_StartScan:85
  467:        return errorInvalidParameter;
  0045 a605     [2]             LDA   #5
  0047 2009     [3]             BRA   L52 ;abs = 0052
  0049          L49:    
  468:      }
  469:    }
  470:    else
  471:    {
  472:      /* Allocation of a message buffer failed. */
  473:      UartUtil_Print("Message allocation failed!\n\r", gAllowToBlock_d);
  0049 450000   [3]             LDHX  @"Message allocation failed!\012\015"
  004c ac000055 [8]             CALL  App_StartScan:85
  474:      return errorAllocFailed;
  0050 a604     [2]             LDA   #4
  0052          L52:    
  475:    }
  476:  }
  0052 a703     [2]             AIS   #3
  0054 8d       [7]             RTC   
  0055          L55:    
  0055 a601     [2]             LDA   #1
  0057 ac000000 [8]             CALL  UartUtil_Print
  005b 8d       [7]             RTC   
  477:  
  478:  
  479:  /******************************************************************************
  480:  * The App_HandleScanEdConfirm(nwkMessage_t *pMsg) function will handle the
  481:  * ED scan confirm message received from the MLME when the ED scan has completed.
  482:  * The message contains the ED scan result list. This function will search the
  483:  * list in order to select the logical channel with the least energy. The
  484:  * selected channel is stored in the global variable called 'mLogicalChannel'.
  485:  *
  486:  ******************************************************************************/
  487:  static void App_HandleScanEdConfirm(nwkMessage_t *pMsg)
  488:  {  
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  0002 a7fb     [2]             AIS   #-5
  489:    uint8_t n, minEnergy;
  490:    uint8_t *pEdList;
  491:    uint8_t ChannelMask;
  492:    
  493:    UartUtil_Print("Received the MLME-Scan Confirm message from the MAC\n\r", gAllowToBlock_d);
  0004 450000   [3]             LDHX  @"Received the MLME-Scan Confirm message from the MAC\012\015"
  0007 ac0000b0 [8]             CALL  App_HandleScanEdConfirm:176
  494:      
  495:    /* Get a pointer to the energy detect results */
  496:    pEdList = pMsg->msgData.scanCnf.resList.pEnergyDetectList;
  000b 9efe06   [5]             LDHX  6,SP
  000e 9ece08   [5]             LDHX  8,X
  0011 9eff03   [5]             STHX  3,SP
  497:    
  498:    /* Set the minimum energy to a large value */
  499:    minEnergy = 0xFF;
  0014 a6ff     [2]             LDA   #-1
  0016 95       [2]             TSX   
  0017 e704     [3]             STA   4,X
  500:  
  501:    /* Select default channel */
  502:    mLogicalChannel = 11;
  0019 a60b     [2]             LDA   #11
  001b c70000   [4]             STA   mLogicalChannel
  503:   
  504:    /* Search for the channel with least energy */
  505:    for(n=0; n<16; n++)
  001e 6f01     [5]             CLR   1,X
  0020          L20:    
  506:    {
  507:      ChannelMask = n + 11;
  0020 95       [2]             TSX   
  0021 e601     [3]             LDA   1,X
  0023 ab0b     [2]             ADD   #11
  508:  	if((pEdList[n] < minEnergy)&&((uint8_t)((mDefaultValueOfChannel_c>>ChannelMask) & 0x1)))
  0025 f7       [2]             STA   ,X
  0026 e601     [3]             LDA   1,X
  0028 eb03     [3]             ADD   3,X
  002a 87       [2]             PSHA  
  002b 4f       [1]             CLRA  
  002c e902     [3]             ADC   2,X
  002e 87       [2]             PSHA  
  002f e604     [3]             LDA   4,X
  0031 8a       [3]             PULH  
  0032 88       [3]             PULX  
  0033 f1       [3]             CMP   ,X
  0034 232e     [3]             BLS   L64 ;abs = 0064
  0036 4f       [1]             CLRA  
  0037 450200   [3]             LDHX  #512
  003a 87       [2]             PSHA  
  003b 87       [2]             PSHA  
  003c 89       [2]             PSHX  
  003d 8b       [2]             PSHH  
  003e 95       [2]             TSX   
  003f e604     [3]             LDA   4,X
  0041 cd0000   [6]             JSR   _LLSR
  0044 9ee604   [4]             LDA   4,SP
  0047 a501     [2]             BIT   #1
  0049 a708     [2]             AIS   #8
  004b 2717     [3]             BEQ   L64 ;abs = 0064
  509:      {
  510:        minEnergy = pEdList[n];
  004d e605     [3]             LDA   5,X
  004f eb07     [3]             ADD   7,X
  0051 87       [2]             PSHA  
  0052 4f       [1]             CLRA  
  0053 e906     [3]             ADC   6,X
  0055 87       [2]             PSHA  
  0056 8a       [3]             PULH  
  0057 88       [3]             PULX  
  0058 fe       [3]             LDX   ,X
  0059 9eef05   [4]             STX   5,SP
  511:        /* Channel numbering is 11 to 26 both inclusive */
  512:        mLogicalChannel = n + 11; 
  005c 95       [2]             TSX   
  005d e601     [3]             LDA   1,X
  005f ab0b     [2]             ADD   #11
  0061 c70000   [4]             STA   mLogicalChannel
  0064          L64:    
  0064 95       [2]             TSX   
  0065 6c01     [5]             INC   1,X
  0067 e601     [3]             LDA   1,X
  0069 a110     [2]             CMP   #16
  006b 25b3     [3]             BCS   L20 ;abs = 0020
  513:      }
  514:    }
  515:    
  516:    /* Print out the result of the ED scan */
  517:    UartUtil_Print("ED scan returned the following results:\n\r  [", gAllowToBlock_d);
  006d 450000   [3]             LDHX  @"ED scan returned the following results:\012\015  ["
  0070 ac0000b0 [8]             CALL  App_HandleScanEdConfirm:176
  518:    UartUtil_PrintHex(pEdList, 16, gPrtHexBigEndian_c | gPrtHexSpaces_c);
  0074 9efe03   [5]             LDHX  3,SP
  0077 89       [2]             PSHX  
  0078 8b       [2]             PSHH  
  0079 ae10     [2]             LDX   #16
  007b a609     [2]             LDA   #9
  007d ac000000 [8]             CALL  UartUtil_PrintHex
  0081 a702     [2]             AIS   #2
  519:    UartUtil_Print("]\n\r\n\r", gAllowToBlock_d);
  0083 450000   [3]             LDHX  @"]\012\015\012\015"
  0086 ac0000b0 [8]             CALL  App_HandleScanEdConfirm:176
  520:    
  521:    /* Print out the selected logical channel */
  522:    UartUtil_Print("Based on the ED scan the logical channel 0x", gAllowToBlock_d);
  008a 450000   [3]             LDHX  @"Based on the ED scan the logical channel 0x"
  008d ac0000b0 [8]             CALL  App_HandleScanEdConfirm:176
  523:    UartUtil_PrintHex(&mLogicalChannel, 1, 0);
  0091 450000   [3]             LDHX  @mLogicalChannel
  0094 89       [2]             PSHX  
  0095 8b       [2]             PSHH  
  0096 ae01     [2]             LDX   #1
  0098 4f       [1]             CLRA  
  0099 ac000000 [8]             CALL  UartUtil_PrintHex
  009d a702     [2]             AIS   #2
  524:    UartUtil_Print(" was selected\n\r", gAllowToBlock_d);
  009f 450000   [3]             LDHX  @" was selected\012\015"
  00a2 ac0000b0 [8]             CALL  App_HandleScanEdConfirm:176
  525:    
  526:    /* The list of detected energies must be freed. */
  527:    MSG_Free(pEdList);
  00a6 9efe03   [5]             LDHX  3,SP
  00a9 ac000000 [8]             CALL  MM_Free
  528:  }
  00ad a707     [2]             AIS   #7
  00af 8d       [7]             RTC   
  00b0          LB0:    
  00b0 a601     [2]             LDA   #1
  00b2 ac000000 [8]             CALL  UartUtil_Print
  00b6 8d       [7]             RTC   
  529:  
  530:  /******************************************************************************
  531:  * The App_StartScan(scanType) function will start the scan process of the
  532:  * specified type in the MAC. This is accomplished by allocating a MAC message,
  533:  * which is then assigned the desired scan parameters and sent to the MLME
  534:  * service access point. The MAC PIB attributes "macShortAddress", and 
  535:  * "macAssociatePermit" are modified.
  536:  *
  537:  * The function may return either of the following values:
  538:  *   errorNoError:          The Scan message was sent successfully.
  539:  *   errorInvalidParameter: The MLME service access point rejected the
  540:  *                          message due to an invalid parameter.
  541:  *   errorAllocFailed:      A message buffer could not be allocated.
  542:  *
  543:  ******************************************************************************/
  544:  static uint8_t App_StartCoordinator(void)
  545:  {
  0000 a7fb     [2]             AIS   #-5
  546:    /* Message for the MLME will be allocated and attached to this pointer */
  547:    mlmeMessage_t *pMsg;
  548:  
  549:    UartUtil_Print("Sending the MLME-Start Request message to the MAC...", gAllowToBlock_d);
  0002 450000   [3]             LDHX  @"Sending the MLME-Start Request message to the MAC..."
  0005 ac0000af [8]             CALL  App_StartCoordinator:175
  550:    
  551:    /* Allocate a message for the MLME (We should check for NULL). */
  552:    pMsg = MSG_AllocType(mlmeMessage_t);
  0009 a60f     [2]             LDA   #15
  000b ac000000 [8]             CALL  MM_Alloc
  000f 9eff01   [5]             STHX  1,SP
  553:    if(pMsg != NULL)
  0012 2603     [3]             BNE   L17 ;abs = 0017
  0014 cc00a3   [4]             JMP   LA3 ;abs = 00a3
  0017          L17:    
  554:    {
  555:      /* Pointer which is used for easy access inside the allocated message */
  556:      mlmeStartReq_t *pStartReq;
  557:      /* Return value from MSG_send - used for avoiding compiler warnings */
  558:      uint8_t ret;
  559:      /* Boolean value that will be written to the MAC PIB */
  560:      uint8_t boolFlag;
  561:      
  562:      /* Set-up MAC PIB attributes. Please note that Set, Get,
  563:         and Reset messages are not freed by the MLME. */
  564:      
  565:      /* We must always set the short address to something
  566:         else than 0xFFFF before starting a PAN. */
  567:      pMsg->msgType = gMlmeSetReq_c;
  0017 a609     [2]             LDA   #9
  0019 f7       [2]             STA   ,X
  568:      pMsg->msgData.setReq.pibAttribute = gMPibShortAddress_c;
  001a a653     [2]             LDA   #83
  001c e701     [3]             STA   1,X
  569:      pMsg->msgData.setReq.pibAttributeValue = (uint8_t *)maShortAddress;
  001e a600     [2]             LDA   @maShortAddress:MSB
  0020 e702     [3]             STA   2,X
  0022 a600     [2]             LDA   @maShortAddress
  0024 e703     [3]             STA   3,X
  570:      ret = MSG_Send(NWK_MLME, pMsg);
  0026 89       [2]             PSHX  
  0027 8b       [2]             PSHH  
  0028 ac000000 [8]             CALL  NWK_MLME_SapHandler
  571:      
  572:      /* We must set the Association Permit flag to TRUE 
  573:         in order to allow devices to associate to us. */
  574:      pMsg->msgType = gMlmeSetReq_c;
  002c 9efe01   [5]             LDHX  1,SP
  002f a609     [2]             LDA   #9
  0031 f7       [2]             STA   ,X
  575:      pMsg->msgData.setReq.pibAttribute = gMPibAssociationPermit_c;
  0032 a641     [2]             LDA   #65
  0034 e701     [3]             STA   1,X
  576:      boolFlag = TRUE;
  0036 a601     [2]             LDA   #1
  0038 95       [2]             TSX   
  0039 e704     [3]             STA   4,X
  577:      pMsg->msgData.setReq.pibAttributeValue = &boolFlag;
  003b af04     [2]             AIX   #4
  003d 8b       [2]             PSHH  
  003e 9ee602   [4]             LDA   2,SP
  0041 87       [2]             PSHA  
  0042 8a       [3]             PULH  
  0043 9f       [1]             TXA   
  0044 9eee03   [4]             LDX   3,SP
  0047 e703     [3]             STA   3,X
  0049 86       [3]             PULA  
  004a e702     [3]             STA   2,X
  578:      ret = MSG_Send(NWK_MLME, pMsg);
  004c ac000000 [8]             CALL  NWK_MLME_SapHandler
  579:      
  580:      /* This is a MLME-START.req command */
  581:      pMsg->msgType = gMlmeStartReq_c;
  0050 9efe03   [5]             LDHX  3,SP
  0053 a60a     [2]             LDA   #10
  0055 f7       [2]             STA   ,X
  582:      
  583:      /* Create the Start request message data. */
  584:      pStartReq = &pMsg->msgData.startReq;
  0056 af01     [2]             AIX   #1
  0058 9eff06   [5]             STHX  6,SP
  585:      /* PAN ID - LSB, MSB. The example shows a PAN ID of 0xBEEF. */
  586:      FLib_MemCpy(pStartReq->panId, (void *)maPanId, 2);
  005b 89       [2]             PSHX  
  005c 8b       [2]             PSHH  
  005d 450000   [3]             LDHX  @maPanId
  0060 a602     [2]             LDA   #2
  0062 ac000000 [8]             CALL  FLib_MemCpy
  0066 a702     [2]             AIS   #2
  587:      /* Logical Channel - the default of 11 will be overridden */
  588:      pStartReq->logicalChannel = mLogicalChannel;
  0068 9efe06   [5]             LDHX  6,SP
  006b c60000   [4]             LDA   mLogicalChannel
  006e e702     [3]             STA   2,X
  589:      /* Beacon Order: 0xF = turn off beacons, less than 0xF = turn on beacons */
  590:      pStartReq->beaconOrder = 0x0F;  
  0070 a60f     [2]             LDA   #15
  0072 e703     [3]             STA   3,X
  591:      /* Superframe Order: Must be equal or less than the beacon order */
  592:      pStartReq->superFrameOrder = mDefaultValueOfSuperframeOrder_c;
  0074 a606     [2]             LDA   #6
  0076 e704     [3]             STA   4,X
  593:      /* Be a PAN coordinator */
  594:      pStartReq->panCoordinator = TRUE;
  0078 a601     [2]             LDA   #1
  007a e705     [3]             STA   5,X
  595:      /* Dont use battery life extension */
  596:      pStartReq->batteryLifeExt = FALSE;
  007c 6f06     [5]             CLR   6,X
  597:      /* This is not a Realignment command */
  598:      pStartReq->coordRealignment = FALSE;
  007e 6f07     [5]             CLR   7,X
  599:      /* Dont use security */
  600:  #ifndef gMAC2006_d	
  601:      pStartReq->securityEnable = FALSE;
  0080 6f08     [5]             CLR   8,X
  602:  #else
  603:  	pStartReq->coordRealignSecurityLevel = 0;
  604:    pStartReq->beaconSecurityLevel = 0;	
  605:  #endif //gMAC2006_d	
  606:        
  607:      /* Send the Start request to the MLME. */
  608:      if(MSG_Send(NWK_MLME, pMsg) == gSuccess_c)
  0082 9efe03   [5]             LDHX  3,SP
  0085 ac000000 [8]             CALL  NWK_MLME_SapHandler
  0089 4d       [1]             TSTA  
  008a a702     [2]             AIS   #2
  008c 260a     [3]             BNE   L98 ;abs = 0098
  609:      {
  610:        UartUtil_Print("Done\n\r", gAllowToBlock_d);
  008e 450000   [3]             LDHX  @"Done\012\015"
  0091 ac0000af [8]             CALL  App_StartCoordinator:175
  611:        return errorNoError;
  0095 4f       [1]             CLRA  
  0096 2014     [3]             BRA   LAC ;abs = 00ac
  0098          L98:    
  612:      }
  613:      else
  614:      {
  615:        /* One or more parameters in the Start Request message were invalid. */
  616:        UartUtil_Print("Invalid parameter!\n\r", gAllowToBlock_d);
  0098 450000   [3]             LDHX  @"Invalid parameter!\012\015"
  009b ac0000af [8]             CALL  App_StartCoordinator:175
  617:        return errorInvalidParameter;
  009f a605     [2]             LDA   #5
  00a1 2009     [3]             BRA   LAC ;abs = 00ac
  00a3          LA3:    
  618:      }
  619:    }
  620:    else
  621:    {
  622:      /* Allocation of a message buffer failed. */
  623:      UartUtil_Print("Message allocation failed!\n\r", gAllowToBlock_d);
  00a3 450000   [3]             LDHX  @"Message allocation failed!\012\015"
  00a6 ac0000af [8]             CALL  App_StartCoordinator:175
  624:      return errorAllocFailed;
  00aa a604     [2]             LDA   #4
  00ac          LAC:    
  625:    }
  626:  }
  00ac a705     [2]             AIS   #5
  00ae 8d       [7]             RTC   
  00af          LAF:    
  00af a601     [2]             LDA   #1
  00b1 ac000000 [8]             CALL  UartUtil_Print
  00b5 8d       [7]             RTC   
  627:  
  628:  /******************************************************************************
  629:  * The App_SendAssociateResponse(nwkMessage_t *pMsgIn) will create the response
  630:  * message to an Associate Indication (device sends an Associate Request to its
  631:  * MAC. The request is transmitted to the coordinator where it is converted into
  632:  * an Associate Indication). This function will extract the devices long address,
  633:  * and various other flags from the incoming indication message for building the
  634:  * response message.
  635:  *
  636:  * The function may return either of the following values:
  637:  *   errorNoError:          The Associate Response message was sent successfully.
  638:  *   errorInvalidParameter: The MLME service access point rejected the
  639:  *                          message due to an invalid parameter.
  640:  *   errorAllocFailed:      A message buffer could not be allocated.
  641:  *
  642:  ******************************************************************************/
  643:  static uint8_t App_SendAssociateResponse(nwkMessage_t *pMsgIn)
  644:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  0002 a7fc     [2]             AIS   #-4
  645:    mlmeMessage_t *pMsg;
  646:    mlmeAssociateRes_t *pAssocRes;
  647:    
  648:    static uint8_t nwk_addr;
  649:   
  650:    UartUtil_Print("Sending the MLME-Associate Response message to the MAC...", gAllowToBlock_d);
  0004 450000   [3]             LDHX  @"Sending the MLME-Associate Response message to the MAC..."
  0007 ac0000b4 [8]             CALL  App_SendAssociateResponse:180
  651:   
  652:    /* Allocate a message for the MLME */
  653:    pMsg = MSG_AllocType(mlmeMessage_t);
  000b a60f     [2]             LDA   #15
  000d ac000000 [8]             CALL  MM_Alloc
  0011 9eff03   [5]             STHX  3,SP
  654:    if(pMsg != NULL)
  0014 2603     [3]             BNE   L19 ;abs = 0019
  0016 cc00a8   [4]             JMP   LA8 ;abs = 00a8
  0019          L19:    
  655:    {
  656:      /* This is a MLME-ASSOCIATE.res command */
  657:      pMsg->msgType = gMlmeAssociateRes_c;
  0019 a601     [2]             LDA   #1
  001b f7       [2]             STA   ,X
  658:      
  659:      /* Create the Associate response message data. */
  660:      pAssocRes = &pMsg->msgData.associateRes;
  001c af01     [2]             AIX   #1
  661:      
  662:      /* Assign a short address to the device. In this example we simply
  663:         choose 0x0001. Though, all devices and coordinators in a PAN must have
  664:         different short addresses. However, if a device do not want to use 
  665:         short addresses at all in the PAN, a short address of 0xFFFE must
  666:         be assigned to it. */
  667:      if(pMsgIn->msgData.associateInd.capabilityInfo & gCapInfoAllocAddr_c)
  001e 9eff01   [5]             STHX  1,SP
  0021 9efe05   [5]             LDHX  5,SP
  0024 e60b     [3]             LDA   11,X
  0026 2a1c     [3]             BPL   L44 ;abs = 0044
  668:      {
  669:        /* Assign a unique short address less than 0xfffe if the device requests so. */
  670:        pAssocRes->assocShortAddress[0] = 0x01;
  0028 a601     [2]             LDA   #1
  002a 9efe01   [5]             LDHX  1,SP
  002d e708     [3]             STA   8,X
  671:        pAssocRes->assocShortAddress[1] = nwk_addr;
  002f c60000   [4]             LDA   nwk_addr
  0032 e709     [3]             STA   9,X
  672:        nwk_addr += 1;
  0034 450000   [3]             LDHX  @nwk_addr
  0037 7c       [4]             INC   ,X
  673:        if (nwk_addr >= 2){
  0038 c60000   [4]             LDA   nwk_addr
  003b a102     [2]             CMP   #2
  003d 9efe01   [5]             LDHX  1,SP
  0040 246d     [3]             BCC   LAF ;abs = 00af
  0042 200a     [3]             BRA   L4E ;abs = 004e
  0044          L44:    
  674:      	  return errorAllocFailed;
  675:        }
  676:      }
  677:      else
  678:      {
  679:        /* A short address of 0xfffe means that the device is granted access to
  680:           the PAN (Associate successful) but that long addressing is used.*/
  681:        pAssocRes->assocShortAddress[0] = 0xFE;
  0044 a6fe     [2]             LDA   #-2
  0046 9efe01   [5]             LDHX  1,SP
  0049 e708     [3]             STA   8,X
  682:        pAssocRes->assocShortAddress[1] = 0xFF;
  004b 4c       [1]             INCA  
  004c e709     [3]             STA   9,X
  004e          L4E:    
  683:      }
  684:      /* Get the 64 bit address of the device requesting association. */
  685:      FLib_MemCpy(pAssocRes->deviceAddress, pMsgIn->msgData.associateInd.deviceAddress, 8);
  004e 89       [2]             PSHX  
  004f 8b       [2]             PSHH  
  0050 9eff03   [5]             STHX  3,SP
  0053 9efe07   [5]             LDHX  7,SP
  0056 af01     [2]             AIX   #1
  0058 a608     [2]             LDA   #8
  005a ac000000 [8]             CALL  FLib_MemCpy
  005e a702     [2]             AIS   #2
  686:      /* Association granted. May also be gPanAtCapacity_c or gPanAccessDenied_c. */
  687:      pAssocRes->status = gSuccess_c;
  0060 9efe01   [5]             LDHX  1,SP
  0063 6f0b     [5]             CLR   11,X
  688:      /* Do not use security */
  689:  #ifndef gMAC2006_d
  690:      pAssocRes->securityEnable = FALSE;
  0065 6f0a     [5]             CLR   10,X
  691:  #else
  692:  	pAssocRes->securityLevel = 0;
  693:  #endif //gMAC2006_d	
  694:      
  695:      /* Save device info. */
  696:      FLib_MemCpy(maDeviceShortAddress, pAssocRes->assocShortAddress, 2);
  0067 450000   [3]             LDHX  @maDeviceShortAddress
  006a 89       [2]             PSHX  
  006b 8b       [2]             PSHH  
  006c 9efe03   [5]             LDHX  3,SP
  006f af08     [2]             AIX   #8
  0071 a602     [2]             LDA   #2
  0073 ac000000 [8]             CALL  FLib_MemCpy
  0077 a702     [2]             AIS   #2
  697:      FLib_MemCpy(maDeviceLongAddress,  pAssocRes->deviceAddress,     8);
  0079 450000   [3]             LDHX  @maDeviceLongAddress
  007c 89       [2]             PSHX  
  007d 8b       [2]             PSHH  
  007e 9efe03   [5]             LDHX  3,SP
  0081 a608     [2]             LDA   #8
  0083 ac000000 [8]             CALL  FLib_MemCpy
  0087 a702     [2]             AIS   #2
  698:      
  699:      /* Send the Associate Response to the MLME. */
  700:      if(MSG_Send(NWK_MLME, pMsg) == gSuccess_c)
  0089 9efe03   [5]             LDHX  3,SP
  008c ac000000 [8]             CALL  NWK_MLME_SapHandler
  0090 4d       [1]             TSTA  
  0091 260a     [3]             BNE   L9D ;abs = 009d
  701:      {
  702:        UartUtil_Print("Done\n\r", gAllowToBlock_d);
  0093 450000   [3]             LDHX  @"Done\012\015"
  0096 ac0000b4 [8]             CALL  App_SendAssociateResponse:180
  703:        return errorNoError;
  009a 4f       [1]             CLRA  
  009b 2014     [3]             BRA   LB1 ;abs = 00b1
  009d          L9D:    
  704:      }
  705:      else
  706:      {
  707:        /* One or more parameters in the message were invalid. */
  708:        UartUtil_Print("Invalid parameter!\n\r", gAllowToBlock_d);
  009d 450000   [3]             LDHX  @"Invalid parameter!\012\015"
  00a0 ac0000b4 [8]             CALL  App_SendAssociateResponse:180
  709:        return errorInvalidParameter;
  00a4 a605     [2]             LDA   #5
  00a6 2009     [3]             BRA   LB1 ;abs = 00b1
  00a8          LA8:    
  710:      }
  711:    }
  712:    else
  713:    {
  714:      /* Allocation of a message buffer failed. */
  715:      UartUtil_Print("Message allocation failed!\n\r", gAllowToBlock_d);
  00a8 450000   [3]             LDHX  @"Message allocation failed!\012\015"
  00ab ac0000b4 [8]             CALL  App_SendAssociateResponse:180
  00af          LAF:    
  716:      return errorAllocFailed;
  00af a604     [2]             LDA   #4
  00b1          LB1:    
  717:    }
  718:  }
  00b1 a706     [2]             AIS   #6
  00b3 8d       [7]             RTC   
  00b4          LB4:    
  00b4 a601     [2]             LDA   #1
  00b6 ac000000 [8]             CALL  UartUtil_Print
  00ba 8d       [7]             RTC   
  719:  
  720:  /******************************************************************************
  721:  * The App_HandleMlmeInput(nwkMessage_t *pMsg) function will handle various
  722:  * messages from the MLME, e.g. (Dis)Associate Indication.
  723:  *
  724:  * The function may return either of the following values:
  725:  *   errorNoError:   The message was processed.
  726:  *   errorNoMessage: The message pointer is NULL.
  727:  ******************************************************************************/
  728:  static uint8_t App_HandleMlmeInput(nwkMessage_t *pMsg)
  729:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  730:    if(pMsg == NULL)
  0002 650000   [3]             CPHX  #0
  0005 2604     [3]             BNE   LB ;abs = 000b
  731:      return errorNoMessage;
  0007 a603     [2]             LDA   #3
  0009 2036     [3]             BRA   L41 ;abs = 0041
  000b          LB:     
  732:    
  733:    /* Handle the incoming message. The type determines the sort of processing.*/
  734:    switch(pMsg->msgType) {
  000b f6       [3]             LDA   ,X
  000c 2706     [3]             BEQ   L14 ;abs = 0014
  000e a10c     [2]             CMP   #12
  0010 262e     [3]             BNE   L40 ;abs = 0040
  0012 2012     [3]             BRA   L26 ;abs = 0026
  0014          L14:    
  735:    case gNwkAssociateInd_c:
  736:      UartUtil_Print("Received an MLME-Associate Indication from the MAC\n\r", gAllowToBlock_d);
  0014 450000   [3]             LDHX  @"Received an MLME-Associate Indication from the MAC\012\015"
  0017 a601     [2]             LDA   #1
  0019 ac000000 [8]             CALL  UartUtil_Print
  737:      /* A device sent us an Associate Request. We must send back a response.  */
  738:      return App_SendAssociateResponse(pMsg);
  001d 9efe01   [5]             LDHX  1,SP
  0020 ac000000 [8]             CALL  App_SendAssociateResponse
  0024 201b     [3]             BRA   L41 ;abs = 0041
  0026          L26:    
  739:      break;
  740:      
  741:    case gNwkCommStatusInd_c:
  742:      /* Sent by the MLME after the Association Response has been transmitted. */
  743:      UartUtil_Print("Received an MLME-Comm-Status Indication from the MAC - status = ", gAllowToBlock_d);
  0026 450000   [3]             LDHX  @"Received an MLME-Comm-Status Indication from the MAC - status = "
  0029 a601     [2]             LDA   #1
  002b ac000000 [8]             CALL  UartUtil_Print
  744:      UartUtil_PrintHex(&pMsg->msgData.commStatusInd.status, 1, gPrtHexNewLine_c);
  002f 9efe01   [5]             LDHX  1,SP
  0032 af15     [2]             AIX   #21
  0034 89       [2]             PSHX  
  0035 8b       [2]             PSHH  
  0036 ae01     [2]             LDX   #1
  0038 a602     [2]             LDA   #2
  003a ac000000 [8]             CALL  UartUtil_PrintHex
  003e a702     [2]             AIS   #2
  0040          L40:    
  745:      break;
  746:    }
  747:    return errorNoError;
  0040 4f       [1]             CLRA  
  0041          L41:    
  748:  }
  0041 a702     [2]             AIS   #2
  0043 8d       [7]             RTC   
  749:  
  750:  /******************************************************************************
  751:  * The App_HandleMcpsInput(mcpsToNwkMessage_t *pMsgIn) function will handle 
  752:  * messages from the MCPS, e.g. Data Confirm, and Data Indication.
  753:  *
  754:  ******************************************************************************/
  755:  static void App_HandleMcpsInput(mcpsToNwkMessage_t *pMsgIn)
  756:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  757:    switch(pMsgIn->msgType)
  0002 f6       [3]             LDA   ,X
  0003 2705     [3]             BEQ   LA ;abs = 000a
  0005 41010d   [4]             CBEQA #1,L15 ;abs = 0015
  0008 2071     [3]             BRA   L7B ;abs = 007b
  000a          LA:     
  758:    {
  759:      /* The MCPS-Data confirm is sent by the MAC to the network 
  760:         or application layer when data has been sent. */
  761:    case gMcpsDataCnf_c:
  762:      if(mcPendingPackets)
  000a c60000   [4]             LDA   mcPendingPackets
  000d 276c     [3]             BEQ   L7B ;abs = 007b
  763:        mcPendingPackets--;
  000f 450000   [3]             LDHX  @mcPendingPackets
  0012 7a       [4]             DEC   ,X
  0013 2066     [3]             BRA   L7B ;abs = 007b
  0015          L15:    
  764:      break;
  765:    
  766:    case gMcpsDataInd_c:
  767:      /* The MCPS-Data indication is sent by the MAC to the network 
  768:         or application layer when data has been received. We simply 
  769:         copy the received data to the UART. */
  770:  	if (pMsgIn->msgData.dataInd.pMsdu[0]==0x81){
  0015 9ece1b   [5]             LDHX  27,X
  0018 f6       [3]             LDA   ,X
  0019 a181     [2]             CMP   #-127
  001b 265e     [3]             BNE   L7B ;abs = 007b
  771:          UartUtil_Print("Source NW Addr : ", gAllowToBlock_d);
  001d 450000   [3]             LDHX  @"Source NW Addr : "
  0020 ac00008b [8]             CALL  App_HandleMcpsInput:139
  772:          UartUtil_PrintHex(&(((mcpsToNwkMessage_t*)pMsgIn)->msgData.dataInd.srcAddr[0]), 2, 0);
  0024 9efe01   [5]             LDHX  1,SP
  0027 af0c     [2]             AIX   #12
  0029 89       [2]             PSHX  
  002a 8b       [2]             PSHH  
  002b ae02     [2]             LDX   #2
  002d 4f       [1]             CLRA  
  002e ac000000 [8]             CALL  UartUtil_PrintHex
  0032 a702     [2]             AIS   #2
  773:          UartUtil_Print("\n\r", gAllowToBlock_d);
  0034 450000   [3]             LDHX  @"\012\015"
  0037 ac00008b [8]             CALL  App_HandleMcpsInput:139
  774:  
  775:          UartUtil_Print("Data:MMA8652(2g: Int2,Float10) \n\rX axis : 0x", gAllowToBlock_d);
  003b 450000   [3]             LDHX  @"Data:MMA8652(2g: Int2,Float10) \012\015X axis : 0x"
  003e ac00008b [8]             CALL  App_HandleMcpsInput:139
  776:          UartUtil_PrintHex(&pMsgIn->msgData.dataInd.pMsdu[1], 2, 1);
  0042 9efe01   [5]             LDHX  1,SP
  0045 9ece1b   [5]             LDHX  27,X
  0048 af01     [2]             AIX   #1
  004a ac00007e [8]             CALL  App_HandleMcpsInput:126
  777:          UartUtil_Print(" /1024 [g]\n\rY axis : 0x", gAllowToBlock_d);
  004e 450000   [3]             LDHX  @" /1024 [g]\012\015Y axis : 0x"
  0051 ac00008b [8]             CALL  App_HandleMcpsInput:139
  778:          UartUtil_PrintHex(&pMsgIn->msgData.dataInd.pMsdu[3], 2, 1);
  0055 9efe01   [5]             LDHX  1,SP
  0058 9ece1b   [5]             LDHX  27,X
  005b af03     [2]             AIX   #3
  005d ac00007e [8]             CALL  App_HandleMcpsInput:126
  779:  		UartUtil_Print(" /1024 [g]\n\rZ axis : 0x", gAllowToBlock_d);
  0061 450000   [3]             LDHX  @" /1024 [g]\012\015Z axis : 0x"
  0064 ac00008b [8]             CALL  App_HandleMcpsInput:139
  780:  		UartUtil_PrintHex(&pMsgIn->msgData.dataInd.pMsdu[5], 2, 1);
  0068 9efe01   [5]             LDHX  1,SP
  006b 9ece1b   [5]             LDHX  27,X
  006e af05     [2]             AIX   #5
  0070 ac00007e [8]             CALL  App_HandleMcpsInput:126
  781:  		UartUtil_Print(" /1024 [g]\n\r", gAllowToBlock_d);
  0074 450000   [3]             LDHX  @" /1024 [g]\012\015"
  0077 ac00008b [8]             CALL  App_HandleMcpsInput:139
  007b          L7B:    
  782:  		//UartUtil_Tx(&pMsgIn->msgData.dataInd.pMsdu[1], 6);
  783:  	}
  784:      break;
  785:    }
  786:  }
  007b a702     [2]             AIS   #2
  007d 8d       [7]             RTC   
  007e          L7E:    
  007e 89       [2]             PSHX  
  007f 8b       [2]             PSHH  
  0080 ae02     [2]             LDX   #2
  0082 a601     [2]             LDA   #1
  0084 ac000000 [8]             CALL  UartUtil_PrintHex
  0088 a702     [2]             AIS   #2
  008a 8d       [7]             RTC   
  008b          L8B:    
  008b a601     [2]             LDA   #1
  008d ac000000 [8]             CALL  UartUtil_Print
  0091 8d       [7]             RTC   
  787:  
  788:  /******************************************************************************
  789:  * The App_WaitMsg(nwkMessage_t *pMsg, uint8_t msgType) function does not, as
  790:  * the name implies, wait for a message, thus blocking the execution of the
  791:  * state machine. Instead the function analyzes the supplied message to determine
  792:  * whether or not the message is of the expected type.
  793:  * The function may return either of the following values:
  794:  *   errorNoError: The message was of the expected type.
  795:  *   errorNoMessage: The message pointer is NULL.
  796:  *   errorWrongConfirm: The message is not of the expected type.
  797:  *
  798:  ******************************************************************************/
  799:  static uint8_t App_WaitMsg(nwkMessage_t *pMsg, uint8_t msgType)
  800:  {
  801:    /* Do we have a message? If not, the exit with error code */
  802:    if(pMsg == NULL)
  0000 650000   [3]             CPHX  #0
  0003 2603     [3]             BNE   L8 ;abs = 0008
  803:      return errorNoMessage;
  0005 a603     [2]             LDA   #3
  0007 8d       [7]             RTC   
  0008          L8:     
  804:  
  805:    /* Is it the expected message type? If not then exit with error code */
  806:    if(pMsg->msgType != msgType)
  0008 f1       [3]             CMP   ,X
  0009 2703     [3]             BEQ   LE ;abs = 000e
  807:      return errorWrongConfirm;
  000b a601     [2]             LDA   #1
  000d 8d       [7]             RTC   
  000e          LE:     
  808:  
  809:    /* Found the expected message. Return with success code */
  810:    return errorNoError;
  000e 4f       [1]             CLRA  
  811:  }
  000f 8d       [7]             RTC   
  812:  
  813:  /******************************************************************************
  814:  * The App_TransmitUartData() function will perform (single/multi buffered)
  815:  * data transmissions of data received by the UART. Data could also come from
  816:  * other sources such as sensors etc. This is completely determined by the
  817:  * application. The constant mDefaultValueOfMaxPendingDataPackets_c determine the maximum
  818:  * number of packets pending for transmission in the MAC. A global variable
  819:  * is incremented each time a data packet is sent to the MCPS, and decremented
  820:  * when the corresponding MCPS-Data Confirm message is received. If the counter
  821:  * reaches the defined maximum no more data buffers are allocated until the
  822:  * counter is decreased below the maximum number of pending packets.
  823:  *
  824:  * The function uses the device information, that was stored when the device,
  825:  * associated to us, for building an MCPS-Data Request message. The message
  826:  * is sent to the MCPS service access point in the MAC.
  827:  ******************************************************************************/
  828:  static void App_TransmitUartData(void)
  829:  {   
  0000 a7f8     [2]             AIS   #-8
  830:    static uint8_t keysBuffer[mMaxKeysToReceive_c];
  831:    static uint8_t keysReceived = 0;
  832:    const uint8_t broadcastaddress[8] = { 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
  0002 a6ff     [2]             LDA   #-1
  0004 95       [2]             TSX   
  0005 f7       [2]             STA   ,X
  0006 e701     [3]             STA   1,X
  0008 6f02     [5]             CLR   2,X
  000a 6f03     [5]             CLR   3,X
  000c 6f04     [5]             CLR   4,X
  000e 6f05     [5]             CLR   5,X
  0010 6f06     [5]             CLR   6,X
  0012 6f07     [5]             CLR   7,X
  833:  
  834:    
  835:    /* get data from UART */
  836:    if( keysReceived < mMaxKeysToReceive_c) 
  0014 c60000   [4]             LDA   keysReceived
  0017 a120     [2]             CMP   #32
  0019 2414     [3]             BCC   L2F ;abs = 002f
  837:    { 
  838:      if(UartX_GetByteFromRxBuffer(&keysBuffer[keysReceived])) 
  001b ab00     [2]             ADD   @keysBuffer
  001d 87       [2]             PSHA  
  001e 4f       [1]             CLRA  
  001f a900     [2]             ADC   @keysBuffer:MSB
  0021 88       [3]             PULX  
  0022 87       [2]             PSHA  
  0023 8a       [3]             PULH  
  0024 ac000000 [8]             CALL  Uart1_GetByteFromRxBuffer
  0028 4d       [1]             TSTA  
  0029 2704     [3]             BEQ   L2F ;abs = 002f
  839:      {
  840:      keysReceived++;
  002b 450000   [3]             LDHX  @keysReceived
  002e 7c       [4]             INC   ,X
  002f          L2F:    
  841:      }
  842:    }
  843:  	/* Use multi buffering for increased TX performance. It does not really
  844:       have any effect at a UART baud rate of 19200bps but serves as an
  845:       example of how the throughput may be improved in a real-world 
  846:       application where the data rate is of concern. */
  847:    if( (mcPendingPackets < mDefaultValueOfMaxPendingDataPackets_c) && (mpPacket == NULL) ) 
  002f c60000   [4]             LDA   mcPendingPackets
  0032 a102     [2]             CMP   #2
  0034 240e     [3]             BCC   L44 ;abs = 0044
  0036 320000   [5]             LDHX  mpPacket
  0039 2609     [3]             BNE   L44 ;abs = 0044
  848:    {
  849:      /* If the maximum number of pending data buffes is below maximum limit 
  850:         and we do not have a data buffer already then allocate one. */
  851:      mpPacket = MSG_Alloc(gMaxRxTxDataLength_c);
  003b a68d     [2]             LDA   #-115
  003d ac000000 [8]             CALL  MM_Alloc
  0041 960000   [5]             STHX  mpPacket
  0044          L44:    
  852:    }
  853:  
  854:    if(mpPacket != NULL)
  0044 320000   [5]             LDHX  mpPacket
  0047 277e     [3]             BEQ   LC7 ;abs = 00c7
  855:    {
  856:        /* get data from UART */        
  857:        mpPacket->msgData.dataReq.pMsdu = (uint8_t*)(&(mpPacket->msgData.dataReq.pMsdu)) + sizeof(uint8_t*);
  0049 af1c     [2]             AIX   #28
  004b 9f       [1]             TXA   
  004c 8b       [2]             PSHH  
  004d 320000   [5]             LDHX  mpPacket
  0050 e71b     [3]             STA   27,X
  0052 86       [3]             PULA  
  0053 e71a     [3]             STA   26,X
  858:        FLib_MemCpy(mpPacket->msgData.dataReq.pMsdu, (uint8_t*) keysBuffer, keysReceived);
  0055 9ece1a   [5]             LDHX  26,X
  0058 89       [2]             PSHX  
  0059 8b       [2]             PSHH  
  005a 450000   [3]             LDHX  @keysBuffer
  005d c60000   [4]             LDA   keysReceived
  0060 ac000000 [8]             CALL  FLib_MemCpy
  0064 a702     [2]             AIS   #2
  859:  
  860:        /* Data was available in the UART receive buffer. Now create an
  861:           MCPS-Data Request message containing the UART data. */
  862:        mpPacket->msgType = gMcpsDataReq_c;
  0066 320000   [5]             LDHX  mpPacket
  0069 7f       [4]             CLR   ,X
  863:        /* Create the header using device information stored when creating 
  864:           the association response. In this simple example the use of short
  865:           addresses is hardcoded. In a real world application we must be
  866:           flexible, and use the address mode required by the given situation. */
  867:        
  868:        
  869:        FLib_MemCpy(mpPacket->msgData.dataReq.dstAddr, (void *)broadcastaddress, 2);
  006a af01     [2]             AIX   #1
  006c 89       [2]             PSHX  
  006d 8b       [2]             PSHH  
  006e 95       [2]             TSX   
  006f af02     [2]             AIX   #2
  0071 a602     [2]             LDA   #2
  0073 ac000000 [8]             CALL  FLib_MemCpy
  0077 a702     [2]             AIS   #2
  870:        FLib_MemCpy(mpPacket->msgData.dataReq.srcAddr, (void *)maShortAddress, 2);
  0079 320000   [5]             LDHX  mpPacket
  007c af0c     [2]             AIX   #12
  007e 89       [2]             PSHX  
  007f 8b       [2]             PSHH  
  0080 450000   [3]             LDHX  @maShortAddress
  0083 a602     [2]             LDA   #2
  0085 ac000000 [8]             CALL  FLib_MemCpy
  0089 a702     [2]             AIS   #2
  871:        FLib_MemCpy(mpPacket->msgData.dataReq.dstPanId, (void *)maPanId, 2);
  008b 320000   [5]             LDHX  mpPacket
  008e af09     [2]             AIX   #9
  0090 ac0000d9 [8]             CALL  App_TransmitUartData:217
  872:        FLib_MemCpy(mpPacket->msgData.dataReq.srcPanId, (void *)maPanId, 2);
  0094 320000   [5]             LDHX  mpPacket
  0097 af14     [2]             AIX   #20
  0099 ac0000d9 [8]             CALL  App_TransmitUartData:217
  873:        mpPacket->msgData.dataReq.dstAddrMode = gAddrModeShort_c;
  009d a602     [2]             LDA   #2
  009f 320000   [5]             LDHX  mpPacket
  00a2 e70b     [3]             STA   11,X
  874:        mpPacket->msgData.dataReq.srcAddrMode = gAddrModeShort_c;
  00a4 e716     [3]             STA   22,X
  875:        mpPacket->msgData.dataReq.msduLength = keysReceived;
  00a6 c60000   [4]             LDA   keysReceived
  00a9 e717     [3]             STA   23,X
  876:        /* Request MAC level acknowledgement, and 
  877:           indirect transmission of the data packet */
  878:        mpPacket->msgData.dataReq.txOptions = 0;
  00ab 6f19     [5]             CLR   25,X
  879:        /* Give the data packet a handle. The handle is
  880:           returned in the MCPS-Data Confirm message. */
  881:        mpPacket->msgData.dataReq.msduHandle = mMsduHandle++;
  00ad c60000   [4]             LDA   mMsduHandle
  00b0 e718     [3]             STA   24,X
  00b2 4c       [1]             INCA  
  00b3 c70000   [4]             STA   mMsduHandle
  882:  #ifdef gMAC2006_d
  883:  	  mpPacket->msgData.dataReq.securityLevel = 0;
  884:  #endif //gMAC2006_d	  
  885:        
  886:        /* Send the Data Request to the MCPS */
  887:        (void)MSG_Send(NWK_MCPS, mpPacket);
  00b6 ac000000 [8]             CALL  NWK_MCPS_SapHandler
  888:        /* Prepare for another data buffer */
  889:        mpPacket = NULL;
  00ba 5f       [1]             CLRX  
  00bb 8c       [1]             CLRH  
  00bc 960000   [5]             STHX  mpPacket
  890:        mcPendingPackets++;
  00bf 450000   [3]             LDHX  @mcPendingPackets
  00c2 7c       [4]             INC   ,X
  891:        /* Receive another pressed keys */
  892:        keysReceived = 0;
  00c3 4f       [1]             CLRA  
  00c4 c70000   [4]             STA   keysReceived
  00c7          LC7:    
  893:    }
  894:    
  895:    /* If the keysBuffer[] wasn't send over the air because there are too many pending packets, */
  896:    /* try to send it later   */
  897:    if (keysReceived)
  00c7 c60000   [4]             LDA   keysReceived
  00ca 270a     [3]             BEQ   LD6 ;abs = 00d6
  898:    {
  899:    TS_SendEvent(gAppTaskID_c, gAppEvtRxFromUart_c);
  00cc c60000   [4]             LDA   gAppTaskID_c
  00cf ae02     [2]             LDX   #2
  00d1 8c       [1]             CLRH  
  00d2 ac000000 [8]             CALL  TS_SendEvent
  00d6          LD6:    
  900:    }
  901:  }
  00d6 a708     [2]             AIS   #8
  00d8 8d       [7]             RTC   
  00d9          LD9:    
  00d9 89       [2]             PSHX  
  00da 8b       [2]             PSHH  
  00db 450000   [3]             LDHX  @maPanId
  00de a602     [2]             LDA   #2
  00e0 ac000000 [8]             CALL  FLib_MemCpy
  00e4 a702     [2]             AIS   #2
  00e6 8d       [7]             RTC   
  902:  
  903:  /*****************************************************************************
  904:  * Function to handle a generic key press. Called for all keys.
  905:  *****************************************************************************/
  906:  static void App_HandleGenericKey(void)
  907:  {
  908:    if(gState == stateInit)
  0000 c60000   [4]             LDA   gState
  0003 262a     [3]             BNE   L2F ;abs = 002f
  909:    {
  910:      StopLed1Flashing();
  0005 a601     [2]             LDA   #1
  0007 ac000000 [8]             CALL  LED_StopFlash
  911:      StopLed2Flashing();
  000b a602     [2]             LDA   #2
  000d ac000000 [8]             CALL  LED_StopFlash
  912:      StopLed3Flashing();
  0011 a604     [2]             LDA   #4
  0013 ac000000 [8]             CALL  LED_StopFlash
  913:      StopLed4Flashing();
  0017 a608     [2]             LDA   #8
  0019 ac000000 [8]             CALL  LED_StopFlash
  914:      Led1Off();
  001d 1000     [5]             BSET  0,0
  915:      Led2Off();
  001f 1800     [5]             BSET  4,0
  916:      Led3Off();
  0021 1006     [5]             BSET  0,6
  917:      Led4Off();
  0023 1206     [5]             BSET  1,6
  918:      LCD_ClearDisplay();
  919:      LCD_WriteString(1,"Application");
  920:      LCD_WriteString(2,"    started");     
  921:      TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);       
  0025 c60000   [4]             LDA   gAppTaskID_c
  0028 ae01     [2]             LDX   #1
  002a 8c       [1]             CLRH  
  002b ac000000 [8]             CALL  TS_SendEvent
  002f          L2F:    
  922:    }
  923:  }
  002f 8d       [7]             RTC   
  924:  
  925:  /*****************************************************************************
  926:  * Handles all key events for this device.
  927:  * Interface assumptions: None
  928:  * Return value: None
  929:  *****************************************************************************/
  930:  #if (gMC1323xMatrixKBD_d == TRUE)
  931:  static void App_HandleKeys(uint8_t events, uint8_t pressedKey)   
  932:  {
  933:   (void)events;
  934:   (void)pressedKey;
  935:   App_HandleGenericKey();
  0000 ac000000 [8]             CALL  App_HandleGenericKey
  936:  }
  0004 8d       [7]             RTC   
  937:  #else
  938:  static void App_HandleKeys(key_event_t events)
  939:  {
  940:    switch ( events ) 
  941:      { 
  942:        case gKBD_EventSW1_c:
  943:        case gKBD_EventSW2_c:
  944:        case gKBD_EventSW3_c:
  945:        case gKBD_EventSW4_c:
  946:        case gKBD_EventLongSW1_c:
  947:        case gKBD_EventLongSW2_c:
  948:        case gKBD_EventLongSW3_c:
  949:        case gKBD_EventLongSW4_c:
  950:         App_HandleGenericKey();
  951:      break;
  952:      }    
  953:  }                          
  954:  #endif //gMC1323xMatrixKBD_d
  955:  /*****************************************************************************
  956:  * The DeepSleepWakeupStackProc(void) function is called each time the 
  957:  * application exits the DeepSleep mode .
  958:  * 
  959:  * Return value:
  960:  *     None
  961:  *****************************************************************************/
  962:  void DeepSleepWakeupStackProc(void){
  963:    return;
  964:  }
  0000 8d       [7]             RTC   
  965:  
  966:  /******************************************************************************
  967:  * The following functions are called by the MAC to put messages into the
  968:  * Application's queue. They need to be defined even if they are not used
  969:  * in order to avoid linker errors.
  970:  ******************************************************************************/
  971:  
  972:  uint8_t MLME_NWK_SapHandler(nwkMessage_t * pMsg)
  973:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  974:    /* Put the incoming MLME message in the applications input queue. */
  975:    MSG_Queue(&mMlmeNwkInputQueue, pMsg);
  0002 450000   [3]             LDHX  @mMlmeNwkInputQueue
  0005 89       [2]             PSHX  
  0006 8b       [2]             PSHH  
  0007 9efe03   [5]             LDHX  3,SP
  000a ac000000 [8]             CALL  List_AddTail
  000e a702     [2]             AIS   #2
  976:    TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMLME_c);
  0010 c60000   [4]             LDA   gAppTaskID_c
  0013 ae04     [2]             LDX   #4
  0015 8c       [1]             CLRH  
  0016 ac000000 [8]             CALL  TS_SendEvent
  977:    return gSuccess_c;
  001a 4f       [1]             CLRA  
  978:  }
  001b a702     [2]             AIS   #2
  001d 8d       [7]             RTC   
  979:  
  980:  uint8_t MCPS_NWK_SapHandler(mcpsToNwkMessage_t *pMsg)
  981:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  982:    /* Put the incoming MCPS message in the applications input queue. */
  983:    MSG_Queue(&mMcpsNwkInputQueue, pMsg);
  0002 450000   [3]             LDHX  @mMcpsNwkInputQueue
  0005 89       [2]             PSHX  
  0006 8b       [2]             PSHH  
  0007 9efe03   [5]             LDHX  3,SP
  000a ac000000 [8]             CALL  List_AddTail
  000e a702     [2]             AIS   #2
  984:    TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMCPS_c);
  0010 c60000   [4]             LDA   gAppTaskID_c
  0013 ae08     [2]             LDX   #8
  0015 8c       [1]             CLRH  
  0016 ac000000 [8]             CALL  TS_SendEvent
  985:    return gSuccess_c;
  001a 4f       [1]             CLRA  
  986:  }
  001b a702     [2]             AIS   #2
  001d 8d       [7]             RTC   
  987:  
  988:  uint8_t ASP_APP_SapHandler(aspToAppMsg_t *pMsg)
  989:  {
  990:    /* If the message is not handled anywhere it must be freed. */
  991:    MSG_Free(pMsg);
  0000 ac000000 [8]             CALL  MM_Free
  992:    return gSuccess_c;
  0004 4f       [1]             CLRA  
  993:  }
  0005 8d       [7]             RTC   
  994:  
  995:  /******************************************************************************/
  996:  
