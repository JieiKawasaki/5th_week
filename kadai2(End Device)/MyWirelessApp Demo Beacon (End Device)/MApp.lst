*** EVALUATION ***
ANSI-C/cC++ Compiler for HC08 V-5.0.41 Build 12319, Nov 15 2012

    1:  /*****************************************************************************
    2:  * MyWirelessApp Demo Beacon End Device application.
    3:  *
    4:  * (c) Copyright 2008, Freescale, Inc. All rights reserved.
    5:  *
    6:  *
    7:  * No part of this document must be reproduced in any form - including copied,
    8:  * transcribed, printed or by any electronic means - without specific written
    9:  * permission from Freescale Semiconductor.
   10:  *
   11:  *****************************************************************************/
   12:  
   13:  #include "MApp.h"
   14:  #include "Sound.h"
   15:  #include "NVM_Interface.h"
   16:  #include "CMT_interface.h"
   17:  #include "IIC_Interface.h" // New
   18:  //#include "IoConfig.h"
   19:  
   20:  
   21:  /************************************************************************************
   22:  *************************************************************************************
   23:  * Private macros
   24:  *************************************************************************************
   25:  ************************************************************************************/
   26:  
   27:  /* If there are too many pending packets to be send over the air, */
   28:  /* receive mMaxKeysToReceive_c chars. */
   29:  /* The chars will be send over the air when there are no pending packets*/
   30:  #define mMaxKeysToReceive_c 32
   31:  
   32:  //----------Sensor switch--------
   33:  #define gMPL3115A2_enable 0
   34:  #define gMMA8652_enable   1
   35:  #define gMAG3110_enable   0
   36:  #define gFXAS21000_enable 0
   37:  #define gMMA9553_enable   0
   38:  //-------------------------------
   39:  
   40:  /************************************************************************************
   41:  *************************************************************************************
   42:  * Private prototypes
   43:  *************************************************************************************
   44:  ************************************************************************************/
   45:  
   46:  /* Forward declarations of helper functions */
   47:  static void    UartRxCallBack(void);
   48:  static uint8_t App_StartScan(uint8_t scanType);
   49:  static uint8_t App_HandleScanActiveConfirm(nwkMessage_t *pMsg);
   50:  static uint8_t App_WaitMsg(nwkMessage_t *pMsg, uint8_t msgType);
   51:  static uint8_t App_SendAssociateRequest(void);
   52:  static uint8_t App_HandleAssociateConfirm(nwkMessage_t *pMsg);
   53:  static void    App_HandleMcpsInput(mcpsToNwkMessage_t *pMsgIn);
   54:  static void    App_TransmitSensorData(void);
   55:  #if (gMC1323xMatrixKBD_d == TRUE)
   56:  static void    App_HandleKeys(uint8_t events, uint8_t pressedKey);
   57:  #else
   58:  static void    App_HandleKeys(key_event_t events);
   59:  #endif //gMC1323xMatrixKBD_d
   60:  
   61:  static uint8_t App_HandleMlmeInput(nwkMessage_t *pMsg);
   62:  static uint8_t App_SendSyncRequest(void);
   63:  static void GenandTransData(uint8_t Length, uint8_t* pTxData, uint8_t* dest_addr);
   64:  
   65:  static void count_timer  (uint8_t timerId);
   66:  
   67:  /* added by yusk */
   68:  static void Router_TransmitUartData(void);
   69:  static uint8_t Router_HandleMlmeInput(nwkMessage_t *pMsg);
   70:  static uint8_t Router_SendAssociateResponse(nwkMessage_t *pMsgIn);
   71:  
   72:  /* added by j */
   73:  static uint8_t App_StartRooter(void);
   74:  static void App_HandleScanEdConfirm(nwkMessage_t *pMsg);
   75:  
   76:  volatile static uint8_t global_counter;
   77:  
   78:  static void count_timer(uint8_t timerId){
   79:  	uint8_t data[2];
   80:  	(void)timerId;  /* prevent compiler warning */
   81:  	global_counter++;
  0000 450000   [3]             LDHX  @global_counter
  0003 7c       [4]             INC   ,X
   82:  }
  0004 8d       [7]             RTC   
   83:  
   84:  /************************************************************************************
   85:  *************************************************************************************
   86:  * Private memory declarations
   87:  *************************************************************************************
   88:  ************************************************************************************/
   89:  
   90:  //Default Pan ID
   91:  static const uint8_t coordinaterPanId[2] = { (mDefaultValueOfPanId_c & 0xff), (mDefaultValueOfPanId_c >> 8)};
   92:  
   93:  /* The current logical channel (frequency band) */
   94:  static uint8_t mLogicalChannel;
   95:  
   96:  
   97:  /************************************************************************************
   98:  *************************************************************************************
   99:  * Private memory declarations
  100:  *************************************************************************************
  101:  ************************************************************************************/
  102:  
  103:  /* The short address and PAN ID of the coordinator*/
  104:  static const uint8_t maShortAddress[2] = { (mDefaultValueOfShortAddress_c & 0xff), (mDefaultValueOfShortAddress_c >> 8)};
  105:  static const uint8_t maPanId[2] = { (mDefaultValueOfPanId_c & 0xff), (mDefaultValueOfPanId_c >> 8)};
  106:  
  107:  /* The current logical channel (frequency band) */
  108:  static uint8_t mLogicalChannel;
  109:  
  110:  /* These byte arrays stores an associated
  111:     devices long and short addresses. */
  112:  static uint8_t maDeviceShortAddress[2];
  113:  static uint8_t maDeviceLongAddress[8];
  114:  
  115:  /* Data request packet for sending UART input to the coordinator */
  116:  static nwkToMcpsMessage_t *mpPacket;
  117:  
  118:  /* The MSDU handle is a unique data packet identifier */
  119:  static uint8_t mMsduHandle;
  120:  
  121:  /* Number of pending data packets */
  122:  static uint8_t mcPendingPackets;
  123:  
  124:  
  125:  /* Information about the PAN we are part of */
  126:  static panDescriptor_t mCoordInfo;
  127:  
  128:  /* This is either the short address assigned by the PAN coordinator
  129:     during association, or our own extended MAC address. */
  130:  static uint8_t maMyAddress[8];
  131:  
  132:  /* The devices address mode. If 2 (gAddrModeShort_c), then maMyAddress
  133:     contains the short address assigned by the PAN coordinator. If 3
  134:     (gAddrModeLong_c), then maMyAddress is equal to the extended address. */
  135:  static uint8_t mAddrMode;
  136:  
  137:  /* Data request packet for sending UART input to the coordinator */
  138:  static nwkToMcpsMessage_t *mpPacket;
  139:  
  140:  /* The MSDU handle is a unique data packet identifier */
  141:  static uint8_t mMsduHandle;
  142:  
  143:  /* Number of pending data packets */
  144:  static uint8_t mcPendingPackets;
  145:  
  146:  /* Application input queues */
  147:  static anchor_t mMlmeNwkInputQueue;
  148:  static anchor_t mMcpsNwkInputQueue;
  149:  
  150:  /************************************************************************************
  151:  *************************************************************************************
  152:  * Public memory declarations
  153:  *************************************************************************************
  154:  ************************************************************************************/
  155:  
  156:  /* The current state of the applications state machine */
  157:  uint8_t gState;
  158:  
  159:  uint8_t MPL3115A2_start_flag = 0;
  160:  uint8_t MMA8652_start_flag   = 0;
  161:  uint8_t MAG3110_start_flag   = 0;
  162:  uint8_t FXAS21000_start_flag = 0;
  163:  uint8_t MMA9553_start_flag   = 0;
  164:  
  165:  /* This data set contains application variables to be preserved across resets */
  166:  NvDataItemDescription_t const gaNvAppDataSet[] = {
  167:    {NULL, 0}       /* Required end-of-table marker. */
  168:  };
  169:  
  170:  STATIC tmrTimerID_t mTimerID = gTmrInvalidTimerID_c;
  171:  
  172:  /************************************************************************************
  173:  *************************************************************************************
  174:  * Public functions
  175:  *************************************************************************************
  176:  ************************************************************************************/
  177:  
  178:  void DeepSleepWakeupStackProc(void);
  179:  
  180:  /*****************************************************************************
  181:  * Initialization function for the App Task. This is called during
  182:  * initialization and should contain any application specific initialization
  183:  * (ie. hardware initialization/setup, table initialization, power up
  184:  * notificaiton.
  185:  *
  186:  * Interface assumptions: None
  187:  *
  188:  * Return value: None
  189:  *
  190:  *****************************************************************************/
  191:  void MApp_init(void)
  192:  { 
  193:    
  194:    /* The initial application state */
  195:    gState = stateInit;    
  0000 4f       [1]             CLRA  
  0001 c70000   [4]             STA   gState
  196:    /* Reset number of pending packets */
  197:    mcPendingPackets = 0;
  0004 c70000   [4]             STA   mcPendingPackets
  198:  
  199:    /* Initialize the MAC 802.15.4 extended address */
  200:    Init_MacExtendedAddress();
  0007 ac000000 [8]             CALL  Init_MacExtendedAddress
  201:    /* register keyboard callback function */
  202:    KBD_Init(App_HandleKeys);
  000b 450000   [3]             LDHX  @App_HandleKeys
  000e 89       [2]             PSHX  
  000f 8b       [2]             PSHH  
  0010 a600     [2]             LDA   @App_HandleKeys:PAGE
  0012 87       [2]             PSHA  
  0013 ac000000 [8]             CALL  KBD_Init
  0017 a703     [2]             AIS   #3
  203:    /* Initialize SPI Module */
  204:    SPI_Init();
  0019 ac000000 [8]             CALL  SPI1_Init
  205:    /* initialize LCD Module */
  206:    LCD_Init();
  207:    /* initialize LED Module */
  208:    LED_Init();
  001d ac000000 [8]             CALL  LED_Init
  209:    /* Initialize the LPM module */
  210:    PWRLib_Init();
  0021 ac000000 [8]             CALL  PWRLib_Init
  211:    /* Initialize the UART so that we can print out status messages */
  212:    UartX_SetBaud(gUartDefaultBaud_c);
  0025 ae34     [2]             LDX   #52
  0027 8c       [1]             CLRH  
  0028 ac000000 [8]             CALL  Uart1_SetBaud
  213:    UartX_SetRxCallBack(UartRxCallBack);
  002c 450000   [3]             LDHX  @UartRxCallBack
  002f 89       [2]             PSHX  
  0030 8b       [2]             PSHH  
  0031 a600     [2]             LDA   @UartRxCallBack:PAGE
  0033 87       [2]             PSHA  
  0034 ac000000 [8]             CALL  Uart1_SetRxCallBack
  0038 a703     [2]             AIS   #3
  214:    
  215:    /* Initialize the IIC module */
  216:    IIC_Bus_Reset();  // Reset IIC bus to prevent freezing sensor module using GPIO 
  003a ac000000 [8]             CALL  IIC_Bus_Reset
  217:    IIC_ModuleInit(); // New      
  003e ac000000 [8]             CALL  IIC_ModuleInit
  218:        
  219:  #if gMPL3115A2_enable
  220:    MPL3115A2_Init();
  221:  #endif
  222:    
  223:  #if gMMA8652_enable
  224:    MMA8652_Init();
  0042 ac000000 [8]             CALL  MMA8652_Init
  225:  #endif   
  226:  
  227:  #if gMAG3110_enable
  228:    MAG3110_Init();
  229:  #endif 
  230:    
  231:  #if gFXAS21000_enable
  232:    FXAS21000_Init();
  233:  #endif 
  234:   
  235:  #if gMMA9553_enable
  236:    MMA9553_Init();
  237:  #endif   
  238:    
  239:    /* initialize buzzer (NCB, SRB only) */  
  240:    BuzzerInit();  
  241:    /* Prepare input queues.*/
  242:    MSG_InitQueue(&mMlmeNwkInputQueue); 
  0046 450000   [3]             LDHX  @mMlmeNwkInputQueue
  0049 ac000000 [8]             CALL  List_ClearAnchor
  243:    MSG_InitQueue(&mMcpsNwkInputQueue);  
  004d 450000   [3]             LDHX  @mMcpsNwkInputQueue
  0050 ac000000 [8]             CALL  List_ClearAnchor
  244:    /* Enable MCU interrupts */
  245:    IrqControlLib_EnableAllIrqs();
  0054 9a       [1]             CLI   
  246:    /*signal app ready*/  
  247:    Led1Flashing();
  0055 a601     [2]             LDA   #1
  0057 ac000000 [8]             CALL  LED_StartFlash
  248:    Led2Flashing();
  005b a602     [2]             LDA   #2
  005d ac000000 [8]             CALL  LED_StartFlash
  249:    Led3Flashing();
  0061 a604     [2]             LDA   #4
  0063 ac000000 [8]             CALL  LED_StartFlash
  250:    Led4Flashing();
  0067 a608     [2]             LDA   #8
  0069 ac000000 [8]             CALL  LED_StartFlash
  251:      
  252:    UartUtil_Print("\n\rPress any switch on board to start running the application.\n\r", gAllowToBlock_d);  
  006d 450000   [3]             LDHX  @"\012\015Press any switch on board to start running the application.\012\015"
  0070 a601     [2]             LDA   #1
  0072 ac000000 [8]             CALL  UartUtil_Print
  253:    
  254:    LCD_WriteString(1,"Press any key");
  255:    LCD_WriteString(2,"to start.");
  256:    
  257:    mTimerID = TMR_AllocateTimer();
  0076 ac000000 [8]             CALL  TMR_AllocateTimer
  007a c70000   [4]             STA   mTimerID
  258:    TMR_StartIntervalTimer(mTimerID, 1000, count_timer);
  007d 87       [2]             PSHA  
  007e 4503e8   [3]             LDHX  #1000
  0081 89       [2]             PSHX  
  0082 8b       [2]             PSHH  
  0083 4f       [1]             CLRA  
  0084 87       [2]             PSHA  
  0085 87       [2]             PSHA  
  0086 450000   [3]             LDHX  @count_timer
  0089 89       [2]             PSHX  
  008a 8b       [2]             PSHH  
  008b a600     [2]             LDA   @count_timer:PAGE
  008d 87       [2]             PSHA  
  008e ac000000 [8]             CALL  TMR_StartIntervalTimer
  0092 a708     [2]             AIS   #8
  259:    
  260:  }
  0094 8d       [7]             RTC   
  261:  
  262:  /*****************************************************************************
  263:  *Mac Application Task event processor.  This function is called to
  264:  * process all events for the task. Events include timers, messages and any
  265:  * other user defined events
  266:  *
  267:  * Interface assumptions: None
  268:  *
  269:  * Return value: None
  270:  *****************************************************************************/
  271:  void AppTask(event_t events) 
  272:  { 
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  0002 a7fe     [2]             AIS   #-2
  273:  
  274:    /* Pointer for storing the messages from MLME, MCPS, and ASP. */
  275:    void *pMsgIn;
  276:    /* Stores the status code returned by some functions. */
  277:    uint8_t rc;
  278:    pMsgIn = NULL;
  0004 9e6f02   [6]             CLR   2,SP
  0007 9e6f01   [6]             CLR   1,SP
  279:    
  280:    /* Dequeue the MLME message */
  281:    if (events & gAppEvtMessageFromMLME_c)
  000a 9f       [1]             TXA   
  000b a504     [2]             BIT   #4
  000d 2726     [3]             BEQ   L35 ;abs = 0035
  282:    {
  283:      /* Get the message from MLME */
  284:      pMsgIn = MSG_DeQueue(&mMlmeNwkInputQueue);
  000f 450000   [3]             LDHX  @mMlmeNwkInputQueue
  0012 ac000000 [8]             CALL  List_RemoveHead
  0016 9eff01   [5]             STHX  1,SP
  285:      
  286:      /* Any time a beacon might arrive. Always handle the beacon frame first */
  287:      if (pMsgIn)
  0019 271a     [3]             BEQ   L35 ;abs = 0035
  288:      {               
  289:        rc = App_WaitMsg(pMsgIn, gNwkBeaconNotifyInd_c);
  001b a604     [2]             LDA   #4
  001d ac000000 [8]             CALL  App_WaitMsg
  290:        if(rc == errorNoError)
  0021 4d       [1]             TSTA  
  0022 2611     [3]             BNE   L35 ;abs = 0035
  291:        {
  292:          /* ALWAYS free the beacon frame contained in the beacon notify indication.*/
  293:          /* ALSO the application can use the beacon payload.*/
  294:          MSG_Free(((nwkMessage_t *)pMsgIn)->msgData.beaconNotifyInd.pBufferRoot);
  0024 9efe01   [5]             LDHX  1,SP
  0027 9ece0a   [5]             LDHX  10,X
  002a ac000000 [8]             CALL  MM_Free
  295:          UartUtil_Print("Received an MLME-Beacon Notify Indication\n\r", gAllowToBlock_d);
  002e 450000   [3]             LDHX  @"Received an MLME-Beacon Notify Indication\012\015"
  0031 ac00032d [8]             CALL  AppTask:813
  0035          L35:    
  296:        }
  297:      }
  298:    }
  299:    /* The application state machine */
  300:    switch(gState)
  0035 c60000   [4]             LDA   gState
  0038 a10b     [2]             CMP   #11
  003a 2249     [3]             BHI   L85 ;abs = 0085
  003c 4d       [1]             TSTA  
  003d 2749     [3]             BEQ   L88 ;abs = 0088
  003f 410152   [4]             CBEQA #1,L94 ;abs = 0094
  0042 a102     [2]             CMP   #2
  0044 2763     [3]             BEQ   LA9 ;abs = 00a9
  0046 a103     [2]             CMP   #3
  0048 2603     [3]             BNE   L4D ;abs = 004d
  004a cc0142   [4]             JMP   L142 ;abs = 0142
  004d          L4D:    
  004d a104     [2]             CMP   #4
  004f 2603     [3]             BNE   L54 ;abs = 0054
  0051 cc0164   [4]             JMP   L164 ;abs = 0164
  0054          L54:    
  0054 a105     [2]             CMP   #5
  0056 2603     [3]             BNE   L5B ;abs = 005b
  0058 cc01e2   [4]             JMP   L1E2 ;abs = 01e2
  005b          L5B:    
  005b a106     [2]             CMP   #6
  005d 2603     [3]             BNE   L62 ;abs = 0062
  005f cc020c   [4]             JMP   L20C ;abs = 020c
  0062          L62:    
  0062 a107     [2]             CMP   #7
  0064 2603     [3]             BNE   L69 ;abs = 0069
  0066 cc0218   [4]             JMP   L218 ;abs = 0218
  0069          L69:    
  0069 a108     [2]             CMP   #8
  006b 2603     [3]             BNE   L70 ;abs = 0070
  006d cc022b   [4]             JMP   L22B ;abs = 022b
  0070          L70:    
  0070 a109     [2]             CMP   #9
  0072 2603     [3]             BNE   L77 ;abs = 0077
  0074 cc0253   [4]             JMP   L253 ;abs = 0253
  0077          L77:    
  0077 a10a     [2]             CMP   #10
  0079 2603     [3]             BNE   L7E ;abs = 007e
  007b cc027d   [4]             JMP   L27D ;abs = 027d
  007e          L7E:    
  007e a10b     [2]             CMP   #11
  0080 2603     [3]             BNE   L85 ;abs = 0085
  0082 cc02c6   [4]             JMP   L2C6 ;abs = 02c6
  0085          L85:    
  0085 cc013f   [4]             JMP   L13F ;abs = 013f
  0088          L88:    
  301:    {
  302:    case stateInit:    
  303:      /* Print a welcome message to the UART */
  304:      UartUtil_Print("\n\rMyWirelessApp Demo Beacon End Device application is initialized and ready.\n\r\n\r", gAllowToBlock_d);            
  0088 450000   [3]             LDHX  @"\012\015MyWirelessApp Demo Beacon End Device application is initialized and ready.\012\015\012\015"
  008b ac00032d [8]             CALL  AppTask:813
  305:      /* Goto Active Scan state. */
  306:      gState = stateScanActiveStart;
  008f a601     [2]             LDA   #1
  307:      //gState = stateListen;
  308:      TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);
  309:      break;
  0091 cc01c3   [4]             JMP   L1C3 ;abs = 01c3
  0094          L94:    
  310:      
  311:    case stateScanActiveStart:
  312:      /* Start the Active scan, and goto wait for confirm state. */
  313:      UartUtil_Print("Start scanning for a PAN coordinator\n\r", gAllowToBlock_d);
  0094 450000   [3]             LDHX  @"Start scanning for a PAN coordinator\012\015"
  0097 ac00032d [8]             CALL  AppTask:813
  314:      /*print a message on the LCD also*/
  315:      LCD_ClearDisplay();
  316:      LCD_WriteString(1,"Start scanning");
  317:      LCD_WriteString(2,"for coordinator");
  318:      rc = App_StartScan(gScanModeActive_c);
  009b a601     [2]             LDA   #1
  009d ac000000 [8]             CALL  App_StartScan
  319:      if(rc == errorNoError)
  00a1 4d       [1]             TSTA  
  00a2 261e     [3]             BNE   LC2 ;abs = 00c2
  320:      {
  321:        gState = stateScanActiveWaitConfirm;
  00a4 a602     [2]             LDA   #2
  00a6 cc0161   [4]             JMP   L161 ;abs = 0161
  00a9          LA9:    
  322:      }
  323:      break;
  324:      
  325:    case stateScanActiveWaitConfirm:
  326:      /* Stay in this state until the Scan confirm message
  327:         arrives, and then goto the associate state. */
  328:      if (events & gAppEvtMessageFromMLME_c)
  00a9 95       [2]             TSX   
  00aa e603     [3]             LDA   3,X
  00ac a504     [2]             BIT   #4
  00ae 2603     [3]             BNE   LB3 ;abs = 00b3
  00b0 cc013f   [4]             JMP   L13F ;abs = 013f
  00b3          LB3:    
  329:      {
  330:        if (pMsgIn)
  00b3 9efe01   [5]             LDHX  1,SP
  00b6 2603     [3]             BNE   LBB ;abs = 00bb
  00b8 cc013f   [4]             JMP   L13F ;abs = 013f
  00bb          LBB:    
  331:        {                            
  332:          rc = App_WaitMsg(pMsgIn, gNwkScanCnf_c);
  00bb a60b     [2]             LDA   #11
  00bd ac000000 [8]             CALL  App_WaitMsg
  333:          if(rc == errorNoError)
  00c1 4d       [1]             TSTA  
  00c2          LC2:    
  00c2 267b     [3]             BNE   L13F ;abs = 013f
  334:          {
  335:            rc = App_HandleScanActiveConfirm(pMsgIn);
  00c4 9efe01   [5]             LDHX  1,SP
  00c7 ac000000 [8]             CALL  App_HandleScanActiveConfirm
  336:            if(rc == errorNoError)
  00cb 4d       [1]             TSTA  
  00cc 266a     [3]             BNE   L138 ;abs = 0138
  337:            {
  338:              UartUtil_Print("Found a coordinator with the following properties:\n\r", gAllowToBlock_d);
  00ce 450000   [3]             LDHX  @"Found a coordinator with the following properties:\012\015"
  00d1 ac00032d [8]             CALL  AppTask:813
  339:              UartUtil_Print("----------------------------------------------------", gAllowToBlock_d);
  00d5 450000   [3]             LDHX  @"----------------------------------------------------"
  00d8 ac00032d [8]             CALL  AppTask:813
  340:              UartUtil_Print("\n\rAddress............0x", gAllowToBlock_d); UartUtil_PrintHex(mCoordInfo.coordAddress, 
  00dc 450000   [3]             LDHX  @"\012\015Address............0x"
  00df ac00032d [8]             CALL  AppTask:813
  00e3 450000   [3]             LDHX  @mCoordInfo
  00e6 89       [2]             PSHX  
  00e7 8b       [2]             PSHH  
  00e8 c6000a   [4]             LDA   mCoordInfo:10
  00eb 410203   [4]             CBEQA #2,LF1 ;abs = 00f1
  341:                                                                   mCoordInfo.coordAddrMode == gAddrModeShort_c ? 2 : 8, 0);
  00ee ae08     [2]             LDX   #8
  00f0 65       [3]             SKIP2 LF3 ;abs = 00f3
  00f1          LF1:    
  00f1 ae02     [2]             LDX   #2
  00f3          LF3:    
  00f3 4f       [1]             CLRA  
  00f4 ac000000 [8]             CALL  UartUtil_PrintHex
  00f8 a702     [2]             AIS   #2
  342:              UartUtil_Print("\n\rPAN ID.............0x", gAllowToBlock_d); UartUtil_PrintHex(mCoordInfo.coordPanId, 2, 0);
  00fa 450000   [3]             LDHX  @"\012\015PAN ID.............0x"
  00fd ac00032d [8]             CALL  AppTask:813
  0101 450008   [3]             LDHX  @mCoordInfo:8
  0104 ac000334 [8]             CALL  AppTask:820
  343:              UartUtil_Print("\n\rLogical Channel....0x", gAllowToBlock_d); UartUtil_PrintHex(&mCoordInfo.logicalChannel, 1, 0);
  0108 450000   [3]             LDHX  @"\012\015Logical Channel....0x"
  010b ac00032d [8]             CALL  AppTask:813
  010f 45000b   [3]             LDHX  @mCoordInfo:11
  0112 ac000340 [8]             CALL  AppTask:832
  344:              UartUtil_Print("\n\rBeacon Spec........0x", gAllowToBlock_d); UartUtil_PrintHex(mCoordInfo.superFrameSpec, 2, 0);
  0116 450000   [3]             LDHX  @"\012\015Beacon Spec........0x"
  0119 ac00032d [8]             CALL  AppTask:813
  011d 45000f   [3]             LDHX  @mCoordInfo:15
  0120 ac000334 [8]             CALL  AppTask:820
  345:              UartUtil_Print("\n\rLink Quality.......0x", gAllowToBlock_d); UartUtil_PrintHex(&mCoordInfo.linkQuality, 1, 0);
  0124 450000   [3]             LDHX  @"\012\015Link Quality.......0x"
  0127 ac00032d [8]             CALL  AppTask:813
  012b 450012   [3]             LDHX  @mCoordInfo:18
  012e ac000340 [8]             CALL  AppTask:832
  346:              UartUtil_Print("\n\r\n\r", gAllowToBlock_d);
  0132 450000   [3]             LDHX  @"\012\015\012\015"
  347:  
  348:              /* Go to the Associate state */
  349:              gState = stateAssociate;
  350:              TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);
  351:            }
  0135 cc01da   [4]             JMP   L1DA ;abs = 01da
  0138          L138:   
  352:            else
  353:            {
  354:              UartUtil_Print("Scan did not find a suitable coordinator\n\r", gAllowToBlock_d);
  0138 450000   [3]             LDHX  @"Scan did not find a suitable coordinator\012\015"
  013b ac00032d [8]             CALL  AppTask:813
  013f          L13F:   
  013f cc020a   [4]             JMP   L20A ;abs = 020a
  0142          L142:   
  355:              /*print a message on the LCD also*/
  356:              LCD_ClearDisplay();
  357:              LCD_WriteString(1,"No coordinator");
  358:              LCD_WriteString(2,"found");
  359:            }            
  360:          }
  361:        }
  362:      }
  363:      break;
  364:  
  365:    case stateAssociate:
  366:      /* Associate to the PAN coordinator */
  367:      UartUtil_Print("Associating to PAN coordinator on channel 0x", gAllowToBlock_d);
  0142 450000   [3]             LDHX  @"Associating to PAN coordinator on channel 0x"
  0145 ac00032d [8]             CALL  AppTask:813
  368:      UartUtil_PrintHex(&(mCoordInfo.logicalChannel), 1, gPrtHexNewLine_c);
  0149 45000b   [3]             LDHX  @mCoordInfo:11
  014c 89       [2]             PSHX  
  014d 8b       [2]             PSHH  
  014e ae01     [2]             LDX   #1
  0150 a602     [2]             LDA   #2
  0152 ac000000 [8]             CALL  UartUtil_PrintHex
  0156 a702     [2]             AIS   #2
  369:      /*print a message on the LCD also*/
  370:      LCD_ClearDisplay();
  371:      LCD_WriteString(1,"Associating to ");
  372:      LCD_WriteString(2,"PAN coordinator");
  373:  
  374:      rc = App_SendAssociateRequest();
  0158 ac000000 [8]             CALL  App_SendAssociateRequest
  375:      if(rc == errorNoError)
  015c 4d       [1]             TSTA  
  015d 266b     [3]             BNE   L1CA ;abs = 01ca
  376:        gState = stateAssociateWaitConfirm;
  015f a604     [2]             LDA   #4
  0161          L161:   
  0161 cc0229   [4]             JMP   L229 ;abs = 0229
  0164          L164:   
  377:      break; 
  378:  
  379:    case stateAssociateWaitConfirm:
  380:      /* Stay in this state until the Associate confirm message
  381:         arrives, and then goto the Listen state. */
  382:      if (events & gAppEvtMessageFromMLME_c)
  0164 95       [2]             TSX   
  0165 e603     [3]             LDA   3,X
  0167 a504     [2]             BIT   #4
  0169 2603     [3]             BNE   L16E ;abs = 016e
  016b cc0204   [4]             JMP   L204 ;abs = 0204
  016e          L16E:   
  383:      {
  384:        if (pMsgIn)
  016e 9efe01   [5]             LDHX  1,SP
  0171 2603     [3]             BNE   L176 ;abs = 0176
  0173 cc0204   [4]             JMP   L204 ;abs = 0204
  0176          L176:   
  385:        {   
  386:          rc = App_WaitMsg(pMsgIn, gNwkAssociateCnf_c);    
  0176 a601     [2]             LDA   #1
  0178 ac000000 [8]             CALL  App_WaitMsg
  387:          if(rc == errorNoError)
  017c 4d       [1]             TSTA  
  017d 264b     [3]             BNE   L1CA ;abs = 01ca
  388:          {
  389:            rc = App_HandleAssociateConfirm(pMsgIn);
  017f 9efe01   [5]             LDHX  1,SP
  0182 ac000000 [8]             CALL  App_HandleAssociateConfirm
  390:            if (rc == errorNoError)
  0186 4d       [1]             TSTA  
  0187 264e     [3]             BNE   L1D7 ;abs = 01d7
  391:            {
  392:                UartUtil_Print("Successfully associated with the coordinator.\n\r", gAllowToBlock_d);
  0189 450000   [3]             LDHX  @"Successfully associated with the coordinator.\012\015"
  018c ac00032d [8]             CALL  AppTask:813
  393:                UartUtil_Print("We were assigned the short address 0x", gAllowToBlock_d);
  0190 450000   [3]             LDHX  @"We were assigned the short address 0x"
  0193 ac00032d [8]             CALL  AppTask:813
  394:                UartUtil_PrintHex(maMyAddress, mAddrMode == gAddrModeShort_c ? 2 : 8, 0);
  0197 450000   [3]             LDHX  @maMyAddress
  019a 89       [2]             PSHX  
  019b 8b       [2]             PSHH  
  019c c60000   [4]             LDA   mAddrMode
  019f 410203   [4]             CBEQA #2,L1A5 ;abs = 01a5
  01a2 ae08     [2]             LDX   #8
  01a4 65       [3]             SKIP2 L1A7 ;abs = 01a7
  01a5          L1A5:   
  01a5 ae02     [2]             LDX   #2
  01a7          L1A7:   
  01a7 4f       [1]             CLRA  
  01a8 ac000000 [8]             CALL  UartUtil_PrintHex
  01ac a702     [2]             AIS   #2
  395:                UartUtil_Print("\n\r\n\rReady to send and receive data over the UART.\n\r\n\r", gAllowToBlock_d);
  01ae 450000   [3]             LDHX  @"\012\015\012\015Ready to send and receive data over the UART.\012\015\012\015"
  01b1 ac00032d [8]             CALL  AppTask:813
  396:                /*print a message on the LCD also*/
  397:                LCD_ClearDisplay();
  398:                LCD_WriteString(1,"Ready to send");
  399:                LCD_WriteString(2,"and receive data");      
  400:                
  401:  //********************************************************
  402:                if (maMyAddress[0]==0x01){
  01b5 c60000   [4]             LDA   maMyAddress
  01b8 4b0b     [4]             DBNZA L1C5 ;abs = 01c5
  403:              	  UartUtil_Print("\n\rSwitch Role to Rooter\n\r", gAllowToBlock_d);
  01ba 450000   [3]             LDHX  @"\012\015Switch Role to Rooter\012\015"
  01bd ac00032d [8]             CALL  AppTask:813
  404:              	  gState = stateInitRooter;
  01c1 a606     [2]             LDA   #6
  01c3          L1C3:   
  405:              	  TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);
  406:                }else if(maMyAddress[0]==0x02){
  01c3 2050     [3]             BRA   L215 ;abs = 0215
  01c5          L1C5:   
  01c5 c60000   [4]             LDA   maMyAddress
  01c8 a102     [2]             CMP   #2
  01ca          L1CA:   
  01ca 263e     [3]             BNE   L20A ;abs = 020a
  407:              	  UartUtil_Print("\n\rSwitch Role to End-Device\n\r", gAllowToBlock_d);
  01cc 450000   [3]             LDHX  @"\012\015Switch Role to End-Device\012\015"
  01cf ac00032d [8]             CALL  AppTask:813
  408:              	  gState = stateListen;
  01d3 a605     [2]             LDA   #5
  01d5 203e     [3]             BRA   L215 ;abs = 0215
  01d7          L1D7:   
  409:              	  TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);
  410:                }
  411:  //********************************************************
  412:            } 
  413:            else 
  414:            {
  415:            
  416:          	  UartUtil_Print("\n\rAssociate Confirm wasn't successful... \n\r\n\r", gAllowToBlock_d);
  01d7 450000   [3]             LDHX  @"\012\015Associate Confirm wasn't successful... \012\015\012\015"
  01da          L1DA:   
  01da ac00032d [8]             CALL  AppTask:813
  417:          	  gState = stateAssociate;
  01de a603     [2]             LDA   #3
  01e0 2033     [3]             BRA   L215 ;abs = 0215
  01e2          L1E2:   
  418:          	  TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);
  419:            }
  420:          }
  421:        }
  422:      }
  423:      break; 
  424:          
  425:    case stateListen:
  426:      /* Transmit to coordinator data received from UART. */
  427:      if (events & gAppEvtMessageFromMLME_c)
  01e2 95       [2]             TSX   
  01e3 e603     [3]             LDA   3,X
  01e5 a504     [2]             BIT   #4
  01e7 2709     [3]             BEQ   L1F2 ;abs = 01f2
  428:      {  
  429:        if (pMsgIn)
  01e9 9efe01   [5]             LDHX  1,SP
  01ec 2704     [3]             BEQ   L1F2 ;abs = 01f2
  430:        {  
  431:          /* Process it */
  432:          rc = App_HandleMlmeInput(pMsgIn);
  01ee ac000000 [8]             CALL  App_HandleMlmeInput
  01f2          L1F2:   
  433:        }
  434:      } 
  435:      
  436:  
  437:  #if gMPL3115A2_enable    
  438:      MPL3115A2_dump(events);
  439:  #endif
  440:    
  441:  #if gMMA8652_enable    
  442:  	// Start to receive periodical data 
  443:  	if(MMA8652_start_flag){
  01f2 c60000   [4]             LDA   MMA8652_start_flag
  01f5 2708     [3]             BEQ   L1FF ;abs = 01ff
  444:  		MMA8652_start_flag = 0;
  01f7 4f       [1]             CLRA  
  01f8 c70000   [4]             STA   MMA8652_start_flag
  445:  		MMA8652_Start_Periodical_data();
  01fb ac000000 [8]             CALL  MMA8652_Start_Periodical_data
  01ff          L1FF:   
  446:  	}
  447:  	
  448:  	if (events & gAppEvt_FromMMA8652_c){
  01ff 95       [2]             TSX   
  0200 e602     [3]             LDA   2,X
  0202 a502     [2]             BIT   #2
  0204          L204:   
  0204 2775     [3]             BEQ   L27B ;abs = 027b
  449:  		/* get byte from UART */
  450:  		App_TransmitSensorData();
  0206 ac000000 [8]             CALL  App_TransmitSensorData
  020a          L20A:   
  020a 206f     [3]             BRA   L27B ;abs = 027b
  020c          L20C:   
  451:  	}
  452:      //MMA8652_dump(events);
  453:  #endif
  454:      
  455:  #if gMAG3110_enable    
  456:      MAG3110_dump(events);
  457:  #endif
  458:      
  459:  #if gFXAS21000_enable    
  460:      FXAS21000_dump(events);
  461:  #endif
  462:      
  463:  #if gMMA9553_enable    
  464:      MMA9553_dump(events);
  465:  #endif
  466:      
  467:      break;
  468:      
  469:    case stateInitRooter:
  470:       /* Print a welcome message to the UART */
  471:      UartUtil_Print(" MyWirelessApp Demo Beacon Coordinator application is initialized and ready.\n\r\n\r", gAllowToBlock_d);            
  020c 450000   [3]             LDHX  @" MyWirelessApp Demo Beacon Coordinator application is initialized and ready.\012\015\012\015"
  020f ac00032d [8]             CALL  AppTask:813
  472:      /* Goto Energy Detection state. */
  473:      gState = stateScanEdStart;
  0213 a607     [2]             LDA   #7
  0215          L215:   
  474:      TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);    
  475:      break;
  0215 cc02b7   [4]             JMP   L2B7 ;abs = 02b7
  0218          L218:   
  476:      
  477:    case stateScanEdStart:
  478:        /* Start the Energy Detection scan, and goto wait for confirm state. */
  479:        UartUtil_Print("Initiating the Energy Detection Scan\n\r", gAllowToBlock_d);
  0218 450000   [3]             LDHX  @"Initiating the Energy Detection Scan\012\015"
  021b ac00032d [8]             CALL  AppTask:813
  480:        /*Print the message on the LCD also*/
  481:        LCD_ClearDisplay();
  482:        LCD_WriteString(1,"Starting Energy");
  483:        LCD_WriteString(2,"Detection Scan");      
  484:        rc = App_StartScan(gScanModeED_c);
  021f 4f       [1]             CLRA  
  0220 ac000000 [8]             CALL  App_StartScan
  485:        if(rc == errorNoError)
  0224 4d       [1]             TSTA  
  0225 2654     [3]             BNE   L27B ;abs = 027b
  486:        {
  487:          gState = stateScanEdWaitConfirm;
  0227 a608     [2]             LDA   #8
  0229          L229:   
  0229 204d     [3]             BRA   L278 ;abs = 0278
  022b          L22B:   
  488:        }
  489:        break;
  490:        
  491:    case stateScanEdWaitConfirm:
  492:        /* Stay in this state until the MLME Scan confirm message arrives,
  493:           and has been processed. Then goto Start Coordinator state. */
  494:        if (events & gAppEvtMessageFromMLME_c)
  022b 95       [2]             TSX   
  022c e603     [3]             LDA   3,X
  022e a504     [2]             BIT   #4
  0230 2749     [3]             BEQ   L27B ;abs = 027b
  495:        {
  496:          if (pMsgIn)
  0232 9efe01   [5]             LDHX  1,SP
  0235 2744     [3]             BEQ   L27B ;abs = 027b
  497:          {
  498:            rc = App_WaitMsg(pMsgIn, gNwkScanCnf_c);
  0237 a60b     [2]             LDA   #11
  0239 ac000000 [8]             CALL  App_WaitMsg
  499:            if(rc == errorNoError)
  023d 4d       [1]             TSTA  
  023e 263b     [3]             BNE   L27B ;abs = 027b
  500:            {
  501:              /* Process the ED scan confirm. The logical
  502:                 channel is selected by this function. */
  503:              App_HandleScanEdConfirm(pMsgIn);
  0240 9efe01   [5]             LDHX  1,SP
  0243 ac000000 [8]             CALL  App_HandleScanEdConfirm
  504:              /* Go to the Start Coordinator state */
  505:              gState = stateStartRooter;
  0247 a609     [2]             LDA   #9
  0249 c70000   [4]             STA   gState
  506:              TS_SendEvent(gAppTaskID_c, gAppEvtStartCoordinator_c);
  024c c60000   [4]             LDA   gAppTaskID_c
  024f ae10     [2]             LDX   #16
  0251 206c     [3]             BRA   L2BF ;abs = 02bf
  0253          L253:   
  507:            }
  508:          }
  509:        }
  510:        break;
  511:    
  512:    case stateStartRooter:
  513:      if (events & gAppEvtStartCoordinator_c)
  0253 95       [2]             TSX   
  0254 e603     [3]             LDA   3,X
  0256 a510     [2]             BIT   #16
  0258 2721     [3]             BEQ   L27B ;abs = 027b
  514:      {
  515:        /* Start up as a PAN Coordinator on the selected channel. */
  516:        UartUtil_Print("\n\rStarting as PAN Rooter on channel 0x", gAllowToBlock_d);
  025a 450000   [3]             LDHX  @"\012\015Starting as PAN Rooter on channel 0x"
  025d ac00032d [8]             CALL  AppTask:813
  517:        UartUtil_PrintHex(&mLogicalChannel, 1, FALSE);
  0261 450000   [3]             LDHX  @mLogicalChannel
  0264 ac000340 [8]             CALL  AppTask:832
  518:        UartUtil_Print("\n\r", gAllowToBlock_d);
  0268 450000   [3]             LDHX  @"\012\015"
  026b ac00032d [8]             CALL  AppTask:813
  519:        /*print a message on the LCD also*/
  520:        LCD_ClearDisplay();
  521:        LCD_WriteString(1,"Starting");
  522:        LCD_WriteString(2,"PAN Rooter");
  523:        rc = App_StartRooter();
  026f ac000000 [8]             CALL  App_StartRooter
  524:        if(rc == errorNoError)
  0273 4d       [1]             TSTA  
  0274 266b     [3]             BNE   L2E1 ;abs = 02e1
  525:        {
  526:          /* If the Start request was sent successfully to
  527:             the MLME, then goto Wait for confirm state. */
  528:          gState = stateStartRooterWaitConfirm;
  0276 a60a     [2]             LDA   #10
  0278          L278:   
  0278 c70000   [4]             STA   gState
  027b          L27B:   
  027b 2064     [3]             BRA   L2E1 ;abs = 02e1
  027d          L27D:   
  529:        }
  530:      }
  531:      break; 
  532:      
  533:    case stateStartRooterWaitConfirm:
  534:      /* Stay in this state until the Start confirm message
  535:         arrives, and then goto the Listen state. */
  536:      if (events & gAppEvtMessageFromMLME_c)
  027d 95       [2]             TSX   
  027e e603     [3]             LDA   3,X
  0280 a504     [2]             BIT   #4
  0282 275d     [3]             BEQ   L2E1 ;abs = 02e1
  537:      {
  538:        if (pMsgIn)
  0284 9efe01   [5]             LDHX  1,SP
  0287 2758     [3]             BEQ   L2E1 ;abs = 02e1
  539:        {    
  540:          rc = App_WaitMsg(pMsgIn, gNwkStartCnf_c);
  0289 a60e     [2]             LDA   #14
  028b ac000000 [8]             CALL  App_WaitMsg
  541:          if(rc == errorNoError)
  028f 4d       [1]             TSTA  
  0290 264f     [3]             BNE   L2E1 ;abs = 02e1
  542:          {
  543:            UartUtil_Print("Started the Rooter with PAN ID 0x", gAllowToBlock_d);
  0292 450000   [3]             LDHX  @"Started the Rooter with PAN ID 0x"
  0295 ac00032d [8]             CALL  AppTask:813
  544:            UartUtil_PrintHex((uint8_t *)maPanId, 2, 0);
  0299 450000   [3]             LDHX  @maPanId
  029c ac000334 [8]             CALL  AppTask:820
  545:            UartUtil_Print(", and short address 0x", gAllowToBlock_d);
  02a0 450000   [3]             LDHX  @", and short address 0x"
  02a3 ac00032d [8]             CALL  AppTask:813
  546:            UartUtil_PrintHex((uint8_t *)maShortAddress, 2, 0);
  02a7 450000   [3]             LDHX  @maShortAddress
  02aa ac000334 [8]             CALL  AppTask:820
  547:            UartUtil_Print(".\n\r\n\rReady to send and receive data over the UART.\n\r\n\r", gAllowToBlock_d);
  02ae 450000   [3]             LDHX  @".\012\015\012\015Ready to send and receive data over the UART.\012\015\012\015"
  02b1 ac00032d [8]             CALL  AppTask:813
  548:            /*print a message on the LCD also*/
  549:            LCD_ClearDisplay();
  550:            LCD_WriteString(1,"Ready to send");
  551:            LCD_WriteString(2,"and receive data");
  552:            gState = stateRooterListen;
  02b5 a60b     [2]             LDA   #11
  02b7          L2B7:   
  02b7 c70000   [4]             STA   gState
  553:            TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);
  02ba c60000   [4]             LDA   gAppTaskID_c
  02bd ae01     [2]             LDX   #1
  02bf          L2BF:   
  02bf 8c       [1]             CLRH  
  02c0 ac000000 [8]             CALL  TS_SendEvent
  02c4 201b     [3]             BRA   L2E1 ;abs = 02e1
  02c6          L2C6:   
  554:          }
  555:        }
  556:      }
  557:      break; 
  558:      
  559:    /* added by yusk */
  560:    case stateRooterListen:
  561:      /* Stay in this state forever. 
  562:         Transmit the data received on UART */
  563:      if (events & gAppEvtMessageFromMLME_c)
  02c6 95       [2]             TSX   
  02c7 e603     [3]             LDA   3,X
  02c9 a504     [2]             BIT   #4
  02cb 2709     [3]             BEQ   L2D6 ;abs = 02d6
  564:      {
  565:        /* Get the message from MLME */
  566:        if (pMsgIn)
  02cd 9efe01   [5]             LDHX  1,SP
  02d0 2704     [3]             BEQ   L2D6 ;abs = 02d6
  567:        {      
  568:          /* Process it */
  569:          rc = Router_HandleMlmeInput(pMsgIn);
  02d2 ac000000 [8]             CALL  Router_HandleMlmeInput
  02d6          L2D6:   
  570:          /* Messages from the MLME must always be freed. */
  571:        }
  572:      }
  573:       if (events & gAppEvtRxFromUart_c)
  02d6 95       [2]             TSX   
  02d7 e603     [3]             LDA   3,X
  02d9 a502     [2]             BIT   #2
  02db 2704     [3]             BEQ   L2E1 ;abs = 02e1
  574:      {      
  575:        /* get byte from UART */
  576:        Router_TransmitUartData();
  02dd ac000000 [8]             CALL  Router_TransmitUartData
  02e1          L2E1:   
  577:      
  578:      }  
  579:      break;     
  580:    }
  581:    
  582:    if (pMsgIn)
  02e1 9efe01   [5]             LDHX  1,SP
  02e4 2704     [3]             BEQ   L2EA ;abs = 02ea
  583:    {
  584:      /* Messages must always be freed. */ 
  585:      MSG_Free(pMsgIn);
  02e6 ac000000 [8]             CALL  MM_Free
  02ea          L2EA:   
  586:    }
  587:    
  588:     /* Handle MCPS confirms and transmit data from UART */
  589:    if (events & gAppEvtMessageFromMCPS_c)
  02ea 95       [2]             TSX   
  02eb e603     [3]             LDA   3,X
  02ed a508     [2]             BIT   #8
  02ef 271b     [3]             BEQ   L30C ;abs = 030c
  590:    {      
  591:      /* Get the message from MCPS */
  592:      pMsgIn = MSG_DeQueue(&mMcpsNwkInputQueue);
  02f1 450000   [3]             LDHX  @mMcpsNwkInputQueue
  02f4 ac000000 [8]             CALL  List_RemoveHead
  593:      if (pMsgIn)
  02f8 650000   [3]             CPHX  #0
  02fb 270f     [3]             BEQ   L30C ;abs = 030c
  594:      {              
  595:        /* Process it */
  596:        App_HandleMcpsInput(pMsgIn);
  02fd 89       [2]             PSHX  
  02fe 8b       [2]             PSHH  
  02ff ac000000 [8]             CALL  App_HandleMcpsInput
  597:        /* Messages from the MCPS must always be freed. */
  598:        MSG_Free(pMsgIn);
  0303 9efe01   [5]             LDHX  1,SP
  0306 ac000000 [8]             CALL  MM_Free
  030a a702     [2]             AIS   #2
  030c          L30C:   
  599:      }
  600:    }
  601:    
  602:    /* Check for pending messages in the Queue */ 
  603:    if(MSG_Pending(&mMcpsNwkInputQueue))
  030c 320000   [5]             LDHX  mMcpsNwkInputQueue
  030f 270a     [3]             BEQ   L31B ;abs = 031b
  604:      TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMCPS_c);
  0311 c60000   [4]             LDA   gAppTaskID_c
  0314 ae08     [2]             LDX   #8
  0316 8c       [1]             CLRH  
  0317 ac000000 [8]             CALL  TS_SendEvent
  031b          L31B:   
  605:    if(MSG_Pending(&mMlmeNwkInputQueue))
  031b 320000   [5]             LDHX  mMlmeNwkInputQueue
  031e 270a     [3]             BEQ   L32A ;abs = 032a
  606:      TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMLME_c);  
  0320 c60000   [4]             LDA   gAppTaskID_c
  0323 ae04     [2]             LDX   #4
  0325 8c       [1]             CLRH  
  0326 ac000000 [8]             CALL  TS_SendEvent
  032a          L32A:   
  607:  }
  032a a704     [2]             AIS   #4
  032c 8d       [7]             RTC   
  032d          L32D:   
  032d a601     [2]             LDA   #1
  032f ac000000 [8]             CALL  UartUtil_Print
  0333 8d       [7]             RTC   
  0334          L334:   
  0334 89       [2]             PSHX  
  0335 8b       [2]             PSHH  
  0336 ae02     [2]             LDX   #2
  0338 4f       [1]             CLRA  
  0339 ac000000 [8]             CALL  UartUtil_PrintHex
  033d a702     [2]             AIS   #2
  033f 8d       [7]             RTC   
  0340          L340:   
  0340 89       [2]             PSHX  
  0341 8b       [2]             PSHH  
  0342 ae01     [2]             LDX   #1
  0344 4f       [1]             CLRA  
  0345 ac000000 [8]             CALL  UartUtil_PrintHex
  0349 a702     [2]             AIS   #2
  034b 8d       [7]             RTC   
  608:  
  609:  /************************************************************************************
  610:  *************************************************************************************
  611:  * Private functions
  612:  *************************************************************************************
  613:  ************************************************************************************/
  614:  
  615:  /*****************************************************************************
  616:  * UartRxCallBack
  617:  *
  618:  * This callback is triggered when a new byte is received over the UART
  619:  *
  620:  *****************************************************************************/
  621:  static void UartRxCallBack(void) 
  622:  {
  0000 8b       [2]             PSHH  
  623:    uint8_t pressedKey;
  624:    if(stateListen == gState){
  0001 c60000   [4]             LDA   gState
  0004 a105     [2]             CMP   #5
  0006 260c     [3]             BNE   L14 ;abs = 0014
  625:      TS_SendEvent(gAppTaskID_c, gAppEvtRxFromUart_c);
  0008 c60000   [4]             LDA   gAppTaskID_c
  000b ae02     [2]             LDX   #2
  000d 8c       [1]             CLRH  
  000e ac000000 [8]             CALL  TS_SendEvent
  626:    }else{
  627:  	  (void)UartX_GetByteFromRxBuffer(&pressedKey);
  628:    }
  629:  }
  0012 8a       [3]             PULH  
  0013 8d       [7]             RTC   
  0014          L14:    
  0014 95       [2]             TSX   
  0015 ac000000 [8]             CALL  Uart1_GetByteFromRxBuffer
  0019 8a       [3]             PULH  
  001a 8d       [7]             RTC   
  630:  
  631:  /******************************************************************************
  632:  * The App_HandleMlmeInput(nwkMessage_t *pMsg) function will handle various
  633:  * messages from the MLME, e.g. Beacon notifications; 
  634:  *
  635:  * The function may return either of the following values:
  636:  *   errorNoError:   The message was processed.
  637:  *   errorNoMessage: The message pointer is NULL.
  638:  *
  639:  ******************************************************************************/
  640:  static uint8_t App_HandleMlmeInput(nwkMessage_t *pMsg)
  641:  {
  642:    if(pMsg == NULL)
  0000 650000   [3]             CPHX  #0
  0003 2603     [3]             BNE   L8 ;abs = 0008
  643:      return errorNoMessage;
  0005 a603     [2]             LDA   #3
  0007 8d       [7]             RTC   
  0008          L8:     
  644:    
  645:    /* Handle the incoming message. The type determines the sort of processing. */
  646:    switch(pMsg->msgType)
  0008 f6       [3]             LDA   ,X
  0009 a104     [2]             CMP   #4
  000b 2607     [3]             BNE   L14 ;abs = 0014
  647:    {
  648:      case gNwkBeaconNotifyInd_c:   
  649:        /* Always free pBufferRoot */    
  650:        MSG_Free(((nwkMessage_t *)pMsg)->msgData.beaconNotifyInd.pBufferRoot);
  000d 9ece0a   [5]             LDHX  10,X
  0010 ac000000 [8]             CALL  MM_Free
  0014          L14:    
  651:        break;  
  652:           
  653:    }
  654:    return errorNoError;
  0014 4f       [1]             CLRA  
  655:  }
  0015 8d       [7]             RTC   
  656:  
  657:  /* added by yusk */
  658:  static uint8_t Router_HandleMlmeInput(nwkMessage_t *pMsg)
  659:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  660:    if(pMsg == NULL)
  0002 650000   [3]             CPHX  #0
  0005 2604     [3]             BNE   LB ;abs = 000b
  661:      return errorNoMessage;
  0007 a603     [2]             LDA   #3
  0009 2036     [3]             BRA   L41 ;abs = 0041
  000b          LB:     
  662:    
  663:    /* Handle the incoming message. The type determines the sort of processing.*/
  664:    switch(pMsg->msgType) {
  000b f6       [3]             LDA   ,X
  000c 2706     [3]             BEQ   L14 ;abs = 0014
  000e a10c     [2]             CMP   #12
  0010 262e     [3]             BNE   L40 ;abs = 0040
  0012 2012     [3]             BRA   L26 ;abs = 0026
  0014          L14:    
  665:    case gNwkAssociateInd_c:
  666:      UartUtil_Print("Received an MLME-Associate Indication from the MAC\n\r", gAllowToBlock_d);
  0014 450000   [3]             LDHX  @"Received an MLME-Associate Indication from the MAC\012\015"
  0017 a601     [2]             LDA   #1
  0019 ac000000 [8]             CALL  UartUtil_Print
  667:      /* A device sent us an Associate Request. We must send back a response.  */
  668:      return Router_SendAssociateResponse(pMsg);
  001d 9efe01   [5]             LDHX  1,SP
  0020 ac000000 [8]             CALL  Router_SendAssociateResponse
  0024 201b     [3]             BRA   L41 ;abs = 0041
  0026          L26:    
  669:      break;
  670:      
  671:    case gNwkCommStatusInd_c:
  672:      /* Sent by the MLME after the Association Response has been transmitted. */
  673:      UartUtil_Print("Received an MLME-Comm-Status Indication from the MAC - status = ", gAllowToBlock_d);
  0026 450000   [3]             LDHX  @"Received an MLME-Comm-Status Indication from the MAC - status = "
  0029 a601     [2]             LDA   #1
  002b ac000000 [8]             CALL  UartUtil_Print
  674:      UartUtil_PrintHex(&pMsg->msgData.commStatusInd.status, 1, gPrtHexNewLine_c);
  002f 9efe01   [5]             LDHX  1,SP
  0032 af15     [2]             AIX   #21
  0034 89       [2]             PSHX  
  0035 8b       [2]             PSHH  
  0036 ae01     [2]             LDX   #1
  0038 a602     [2]             LDA   #2
  003a ac000000 [8]             CALL  UartUtil_PrintHex
  003e a702     [2]             AIS   #2
  0040          L40:    
  675:      break;
  676:    }
  677:    return errorNoError;
  0040 4f       [1]             CLRA  
  0041          L41:    
  678:  }
  0041 a702     [2]             AIS   #2
  0043 8d       [7]             RTC   
  679:  
  680:  /* added by yusk */
  681:  static uint8_t Router_SendAssociateResponse(nwkMessage_t *pMsgIn)
  682:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  0002 a7fa     [2]             AIS   #-6
  683:    mlmeMessage_t *pMsg;
  684:    mlmeAssociateRes_t *pAssocRes;
  685:  
  686:    static uint8_t count;
  687:    
  688:    // static uint8_t nwk_addr; // deleted by yusk
  689:   
  690:    UartUtil_Print("Sending the MLME-Associate Response message to the MAC...", gAllowToBlock_d);
  0004 450000   [3]             LDHX  @"Sending the MLME-Associate Response message to the MAC..."
  0007 ac0000b5 [8]             CALL  Router_SendAssociateResponse:181
  691:   
  692:    /* Allocate a message for the MLME */
  693:    pMsg = MSG_AllocType(mlmeMessage_t);
  000b a60f     [2]             LDA   #15
  000d ac000000 [8]             CALL  MM_Alloc
  0011 9eff05   [5]             STHX  5,SP
  694:    if(pMsg != NULL)
  0014 2603     [3]             BNE   L19 ;abs = 0019
  0016 cc00a9   [4]             JMP   LA9 ;abs = 00a9
  0019          L19:    
  695:    {
  696:      /* This is a MLME-ASSOCIATE.res command */
  697:      pMsg->msgType = gMlmeAssociateRes_c;
  0019 a601     [2]             LDA   #1
  001b f7       [2]             STA   ,X
  698:      
  699:      /* Create the Associate response message data. */
  700:      pAssocRes = &pMsg->msgData.associateRes;
  001c af01     [2]             AIX   #1
  001e 9eff03   [5]             STHX  3,SP
  701:      
  702:      /* Assign a short address to the device. In this example we simply
  703:         choose 0x0001. Though, all devices and coordinators in a PAN must have
  704:         different short addresses. However, if a device do not want to use 
  705:         short addresses at all in the PAN, a short address of 0xFFFE must
  706:         be assigned to it. */
  707:      if(pMsgIn->msgData.associateInd.capabilityInfo & gCapInfoAllocAddr_c)
  0021 9efe07   [5]             LDHX  7,SP
  0024 e60b     [3]             LDA   11,X
  0026 2a1a     [3]             BPL   L42 ;abs = 0042
  708:      {
  709:        if(count != 0){
  0028 c60000   [4]             LDA   count
  002b 2703     [3]             BEQ   L30 ;abs = 0030
  002d cc00b0   [4]             JMP   LB0 ;abs = 00b0
  0030          L30:    
  710:      	  return errorAllocFailed;
  711:        }
  712:        /* Assign a unique short address less than 0xfffe if the device requests so. */
  713:        pAssocRes->assocShortAddress[1] = maMyAddress[1];
  0030 9efe03   [5]             LDHX  3,SP
  0033 c60001   [4]             LDA   maMyAddress:1
  0036 e709     [3]             STA   9,X
  714:        pAssocRes->assocShortAddress[0] = 0x02;
  0038 a602     [2]             LDA   #2
  003a e708     [3]             STA   8,X
  715:        // nwk_addr += 1; // deleted by yusk
  716:        count += 1;
  003c 450000   [3]             LDHX  @count
  003f 7c       [4]             INC   ,X
  717:      }
  0040 200a     [3]             BRA   L4C ;abs = 004c
  0042          L42:    
  718:      else
  719:      {
  720:        /* A short address of 0xfffe means that the device is granted access to
  721:           the PAN (Associate successful) but that long addressing is used.*/
  722:        pAssocRes->assocShortAddress[0] = 0xFE;
  0042 9efe03   [5]             LDHX  3,SP
  0045 a6fe     [2]             LDA   #-2
  0047 e708     [3]             STA   8,X
  723:        pAssocRes->assocShortAddress[1] = 0xFF;
  0049 4c       [1]             INCA  
  004a e709     [3]             STA   9,X
  004c          L4C:    
  724:      }
  725:      /* Get the 64 bit address of the device requesting association. */
  726:      FLib_MemCpy(pAssocRes->deviceAddress, pMsgIn->msgData.associateInd.deviceAddress, 8);
  004c 9efe03   [5]             LDHX  3,SP
  004f 89       [2]             PSHX  
  0050 8b       [2]             PSHH  
  0051 9efe09   [5]             LDHX  9,SP
  0054 af01     [2]             AIX   #1
  0056 a608     [2]             LDA   #8
  0058 ac000000 [8]             CALL  FLib_MemCpy
  005c a702     [2]             AIS   #2
  727:      /* Association granted. May also be gPanAtCapacity_c or gPanAccessDenied_c. */
  728:      pAssocRes->status = gSuccess_c;
  005e 9efe03   [5]             LDHX  3,SP
  0061 6f0b     [5]             CLR   11,X
  729:      /* Do not use security */
  730:  #ifndef gMAC2006_d
  731:      pAssocRes->securityEnable = FALSE;
  0063 6f0a     [5]             CLR   10,X
  732:  #else
  733:    pAssocRes->securityLevel = 0;
  734:  #endif //gMAC2006_d 
  735:      
  736:      /* Save device info. */
  737:      FLib_MemCpy(maDeviceShortAddress, pAssocRes->assocShortAddress, 2);
  0065 9eff01   [5]             STHX  1,SP
  0068 450000   [3]             LDHX  @maDeviceShortAddress
  006b 89       [2]             PSHX  
  006c 8b       [2]             PSHH  
  006d 9efe03   [5]             LDHX  3,SP
  0070 af08     [2]             AIX   #8
  0072 a602     [2]             LDA   #2
  0074 ac000000 [8]             CALL  FLib_MemCpy
  0078 a702     [2]             AIS   #2
  738:      FLib_MemCpy(maDeviceLongAddress,  pAssocRes->deviceAddress,     8);
  007a 450000   [3]             LDHX  @maDeviceLongAddress
  007d 89       [2]             PSHX  
  007e 8b       [2]             PSHH  
  007f 9efe05   [5]             LDHX  5,SP
  0082 a608     [2]             LDA   #8
  0084 ac000000 [8]             CALL  FLib_MemCpy
  0088 a702     [2]             AIS   #2
  739:      
  740:      /* Send the Associate Response to the MLME. */
  741:      if(MSG_Send(NWK_MLME, pMsg) == gSuccess_c)
  008a 9efe05   [5]             LDHX  5,SP
  008d ac000000 [8]             CALL  NWK_MLME_SapHandler
  0091 4d       [1]             TSTA  
  0092 260a     [3]             BNE   L9E ;abs = 009e
  742:      {
  743:        UartUtil_Print("Done\n\r", gAllowToBlock_d);
  0094 450000   [3]             LDHX  @"Done\012\015"
  0097 ac0000b5 [8]             CALL  Router_SendAssociateResponse:181
  744:        return errorNoError;
  009b 4f       [1]             CLRA  
  009c 2014     [3]             BRA   LB2 ;abs = 00b2
  009e          L9E:    
  745:      }
  746:      else
  747:      {
  748:        /* One or more parameters in the message were invalid. */
  749:        UartUtil_Print("Invalid parameter!\n\r", gAllowToBlock_d);
  009e 450000   [3]             LDHX  @"Invalid parameter!\012\015"
  00a1 ac0000b5 [8]             CALL  Router_SendAssociateResponse:181
  750:        return errorInvalidParameter;
  00a5 a605     [2]             LDA   #5
  00a7 2009     [3]             BRA   LB2 ;abs = 00b2
  00a9          LA9:    
  751:      }
  752:    }
  753:    else
  754:    {
  755:      /* Allocation of a message buffer failed. */
  756:      UartUtil_Print("Message allocation failed!\n\r", gAllowToBlock_d);
  00a9 450000   [3]             LDHX  @"Message allocation failed!\012\015"
  00ac ac0000b5 [8]             CALL  Router_SendAssociateResponse:181
  00b0          LB0:    
  757:      return errorAllocFailed;
  00b0 a604     [2]             LDA   #4
  00b2          LB2:    
  758:    }
  759:  }
  00b2 a708     [2]             AIS   #8
  00b4 8d       [7]             RTC   
  00b5          LB5:    
  00b5 a601     [2]             LDA   #1
  00b7 ac000000 [8]             CALL  UartUtil_Print
  00bb 8d       [7]             RTC   
  760:  
  761:  /************************************************************************************
  762:  *************************************************************************************
  763:  * Private functions
  764:  *************************************************************************************
  765:  ************************************************************************************/
  766:  
  767:  
  768:  /* added by yusk */
  769:  static void Router_TransmitUartData(void)
  770:  {   
  771:    static uint8_t keysBuffer[mMaxKeysToReceive_c];
  772:    static uint8_t keysReceived = 0;
  773:    // const uint8_t broadcastaddress[8] = { 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }; //deleted by yusk
  774:  
  775:    
  776:    /* get data from UART */
  777:    if( keysReceived < mMaxKeysToReceive_c) 
  0000 c60000   [4]             LDA   keysReceived
  0003 a120     [2]             CMP   #32
  0005 2414     [3]             BCC   L1B ;abs = 001b
  778:    { 
  779:      if(UartX_GetByteFromRxBuffer(&keysBuffer[keysReceived])) 
  0007 ab00     [2]             ADD   @keysBuffer
  0009 87       [2]             PSHA  
  000a 4f       [1]             CLRA  
  000b a900     [2]             ADC   @keysBuffer:MSB
  000d 88       [3]             PULX  
  000e 87       [2]             PSHA  
  000f 8a       [3]             PULH  
  0010 ac000000 [8]             CALL  Uart1_GetByteFromRxBuffer
  0014 4d       [1]             TSTA  
  0015 2704     [3]             BEQ   L1B ;abs = 001b
  780:      {
  781:      keysReceived++;
  0017 450000   [3]             LDHX  @keysReceived
  001a 7c       [4]             INC   ,X
  001b          L1B:    
  782:      }
  783:    }
  784:    /* Use multi buffering for increased TX performance. It does not really
  785:       have any effect at a UART baud rate of 19200bps but serves as an
  786:       example of how the throughput may be improved in a real-world 
  787:       application where the data rate is of concern. */
  788:    if( (mcPendingPackets < mDefaultValueOfMaxPendingDataPackets_c) && (mpPacket == NULL) ) 
  001b c60000   [4]             LDA   mcPendingPackets
  001e a102     [2]             CMP   #2
  0020 240e     [3]             BCC   L30 ;abs = 0030
  0022 320000   [5]             LDHX  mpPacket
  0025 2609     [3]             BNE   L30 ;abs = 0030
  789:    {
  790:      /* If the maximum number of pending data buffes is below maximum limit 
  791:         and we do not have a data buffer already then allocate one. */
  792:      mpPacket = MSG_Alloc(gMaxRxTxDataLength_c);
  0027 a68d     [2]             LDA   #-115
  0029 ac000000 [8]             CALL  MM_Alloc
  002d 960000   [5]             STHX  mpPacket
  0030          L30:    
  793:    }
  794:  
  795:    if(mpPacket != NULL)
  0030 320000   [5]             LDHX  mpPacket
  0033 276e     [3]             BEQ   LA3 ;abs = 00a3
  796:    {
  797:        /* get data from UART */        
  798:        mpPacket->msgData.dataReq.pMsdu = (uint8_t*)(&(mpPacket->msgData.dataReq.pMsdu)) + sizeof(uint8_t*);
  0035 af1c     [2]             AIX   #28
  0037 9f       [1]             TXA   
  0038 8b       [2]             PSHH  
  0039 320000   [5]             LDHX  mpPacket
  003c e71b     [3]             STA   27,X
  003e 86       [3]             PULA  
  003f e71a     [3]             STA   26,X
  799:        FLib_MemCpy(mpPacket->msgData.dataReq.pMsdu, (uint8_t*) keysBuffer, keysReceived);
  0041 9ece1a   [5]             LDHX  26,X
  0044 89       [2]             PSHX  
  0045 8b       [2]             PSHH  
  0046 450000   [3]             LDHX  @keysBuffer
  0049 c60000   [4]             LDA   keysReceived
  004c ac000000 [8]             CALL  FLib_MemCpy
  0050 a702     [2]             AIS   #2
  800:  
  801:        /* Data was available in the UART receive buffer. Now create an
  802:           MCPS-Data Request message containing the UART data. */
  803:        mpPacket->msgType = gMcpsDataReq_c;
  0052 320000   [5]             LDHX  mpPacket
  0055 7f       [4]             CLR   ,X
  804:        /* Create the header using device information stored when creating 
  805:           the association response. In this simple example the use of short
  806:           addresses is hardcoded. In a real world application we must be
  807:           flexible, and use the address mode required by the given situation. */
  808:        
  809:        
  810:        // FLib_MemCpy(mpPacket->msgData.dataReq.dstAddr, (void *)broadcastaddress, 2); // deleted by yusk
  811:        FLib_MemCpy(mpPacket->msgData.dataReq.srcAddr, (void *)maShortAddress, 2);
  0056 af0c     [2]             AIX   #12
  0058 89       [2]             PSHX  
  0059 8b       [2]             PSHH  
  005a 450000   [3]             LDHX  @maShortAddress
  005d a602     [2]             LDA   #2
  005f ac000000 [8]             CALL  FLib_MemCpy
  0063 a702     [2]             AIS   #2
  812:        FLib_MemCpy(mpPacket->msgData.dataReq.dstPanId, (void *)maPanId, 2);
  0065 320000   [5]             LDHX  mpPacket
  0068 af09     [2]             AIX   #9
  006a ac0000b3 [8]             CALL  Router_TransmitUartData:179
  813:        FLib_MemCpy(mpPacket->msgData.dataReq.srcPanId, (void *)maPanId, 2);
  006e 320000   [5]             LDHX  mpPacket
  0071 af14     [2]             AIX   #20
  0073 ac0000b3 [8]             CALL  Router_TransmitUartData:179
  814:        mpPacket->msgData.dataReq.dstAddrMode = gAddrModeShort_c;
  0077 a602     [2]             LDA   #2
  0079 320000   [5]             LDHX  mpPacket
  007c e70b     [3]             STA   11,X
  815:        mpPacket->msgData.dataReq.srcAddrMode = gAddrModeShort_c;
  007e e716     [3]             STA   22,X
  816:        mpPacket->msgData.dataReq.msduLength = keysReceived;
  0080 c60000   [4]             LDA   keysReceived
  0083 e717     [3]             STA   23,X
  817:        /* Request MAC level acknowledgement, and 
  818:           indirect transmission of the data packet */
  819:        mpPacket->msgData.dataReq.txOptions = gTxOptsAck_c | gTxOptsIndirect_c; // updated by yusk
  0085 a605     [2]             LDA   #5
  0087 e719     [3]             STA   25,X
  820:        /* Give the data packet a handle. The handle is
  821:           returned in the MCPS-Data Confirm message. */
  822:        mpPacket->msgData.dataReq.msduHandle = mMsduHandle++;
  0089 c60000   [4]             LDA   mMsduHandle
  008c e718     [3]             STA   24,X
  008e 4c       [1]             INCA  
  008f c70000   [4]             STA   mMsduHandle
  823:  #ifdef gMAC2006_d
  824:      mpPacket->msgData.dataReq.securityLevel = 0;
  825:  #endif //gMAC2006_d   
  826:        
  827:        /* Send the Data Request to the MCPS */
  828:        (void)MSG_Send(NWK_MCPS, mpPacket);
  0092 ac000000 [8]             CALL  NWK_MCPS_SapHandler
  829:        /* Prepare for another data buffer */
  830:        mpPacket = NULL;
  0096 5f       [1]             CLRX  
  0097 8c       [1]             CLRH  
  0098 960000   [5]             STHX  mpPacket
  831:        mcPendingPackets++;
  009b 450000   [3]             LDHX  @mcPendingPackets
  009e 7c       [4]             INC   ,X
  832:        /* Receive another pressed keys */
  833:        keysReceived = 0;
  009f 4f       [1]             CLRA  
  00a0 c70000   [4]             STA   keysReceived
  00a3          LA3:    
  834:    }
  835:    
  836:    /* If the keysBuffer[] wasn't send over the air because there are too many pending packets, */
  837:    /* try to send it later   */
  838:    if (keysReceived)
  00a3 c60000   [4]             LDA   keysReceived
  00a6 270a     [3]             BEQ   LB2 ;abs = 00b2
  839:    {
  840:    TS_SendEvent(gAppTaskID_c, gAppEvtRxFromUart_c);
  00a8 c60000   [4]             LDA   gAppTaskID_c
  00ab ae02     [2]             LDX   #2
  00ad 8c       [1]             CLRH  
  00ae ac000000 [8]             CALL  TS_SendEvent
  00b2          LB2:    
  841:    }
  842:  }
  00b2 8d       [7]             RTC   
  00b3          LB3:    
  00b3 89       [2]             PSHX  
  00b4 8b       [2]             PSHH  
  00b5 450000   [3]             LDHX  @maPanId
  00b8 a602     [2]             LDA   #2
  00ba ac000000 [8]             CALL  FLib_MemCpy
  00be a702     [2]             AIS   #2
  00c0 8d       [7]             RTC   
  843:  
  844:  
  845:  /******************************************************************************
  846:  * The App_StartScan(scanType) function will start the scan process of the
  847:  * specified type in the MAC. This is accomplished by allocating a MAC message,
  848:  * which is then assigned the desired scan parameters and sent to the MLME
  849:  * service access point.
  850:  * The function may return either of the following values:
  851:  *   errorNoError:          The Scan message was sent successfully.
  852:  *   errorInvalidParameter: The MLME service access point rejected the
  853:  *                          message due to an invalid parameter.
  854:  *   errorAllocFailed:      A message buffer could not be allocated.
  855:  *
  856:  ******************************************************************************/
  857:  static uint8_t App_StartScan(uint8_t scanType)
  858:  {
  0000 87       [2]             PSHA  
  0001 a7fe     [2]             AIS   #-2
  859:    mlmeMessage_t *pMsg;
  860:    mlmeScanReq_t *pScanReq;
  861:  
  862:    UartUtil_Print("Sending the MLME-Scan Request message to the MAC...", gAllowToBlock_d);
  0003 450000   [3]             LDHX  @"Sending the MLME-Scan Request message to the MAC..."
  0006 ac000056 [8]             CALL  App_StartScan:86
  863:  
  864:    /* Allocate a message for the MLME (We should check for NULL). */
  865:    pMsg = MSG_AllocType(mlmeMessage_t);
  000a a60f     [2]             LDA   #15
  000c ac000000 [8]             CALL  MM_Alloc
  0010 9eff01   [5]             STHX  1,SP
  866:    if(pMsg != NULL)
  0013 2735     [3]             BEQ   L4A ;abs = 004a
  867:    {
  868:      /* This is a MLME-SCAN.req command */
  869:      pMsg->msgType = gMlmeScanReq_c;
  0015 a608     [2]             LDA   #8
  0017 f7       [2]             STA   ,X
  870:      /* Create the Scan request message data. */
  871:      pScanReq = &pMsg->msgData.scanReq;
  872:      /* gScanModeED_c, gScanModeActive_c, gScanModePassive_c, or gScanModeOrphan_c */
  873:      pScanReq->scanType = scanType;
  0018 9ee603   [4]             LDA   3,SP
  001b e701     [3]             STA   1,X
  874:      /* ChannelsToScan & 0xFF - LSB, always 0x00 */
  875:      pScanReq->scanChannels[0] = (uint8_t)((mDefaultValueOfChannel_c)     & 0xFF);
  001d 6f02     [5]             CLR   2,X
  876:      /* ChannelsToScan>>8 & 0xFF  */
  877:      pScanReq->scanChannels[1] = (uint8_t)((mDefaultValueOfChannel_c>>8)  & 0xFF);
  001f 6f03     [5]             CLR   3,X
  878:      /* ChannelsToScan>>16 & 0xFF  */
  879:      pScanReq->scanChannels[2] = (uint8_t)((mDefaultValueOfChannel_c>>16) & 0xFF);
  0021 6f04     [5]             CLR   4,X
  880:      /* ChannelsToScan>>24 & 0xFF - MSB */
  881:      pScanReq->scanChannels[3] = (uint8_t)((mDefaultValueOfChannel_c>>24) & 0xFF);
  0023 a602     [2]             LDA   #2
  0025 e705     [3]             STA   5,X
  882:      /* Duration per channel 0-14 (dc). T[sec] = (16*960*((2^dc)+1))/1000000.
  883:         A scan duration of 2 on 16 channels approximately takes 1.2 secs. */
  884:      /* We know beforehand that we will talk to a coordinator with a Beacon
  885:         order of 1. Thus, choosing a Scan Duration of 2 per channel gives us
  886:         a very good chance (100% assuming no interference) of finding the
  887:         coordinator. 1 should be fine too though in an RF quiet environment. */
  888:      pScanReq->scanDuration = mDefaultValueOfScanDuration_c;
  0027 a607     [2]             LDA   #7
  0029 e706     [3]             STA   6,X
  889:  #ifdef gMAC2006_d
  890:  	pScanReq->securityLevel = 0;
  891:  #endif //gMAC2006_d	
  892:      
  893:      /* Send the Scan request to the MLME. */
  894:      if(MSG_Send(NWK_MLME, pMsg) == gSuccess_c)
  002b 9efe01   [5]             LDHX  1,SP
  002e ac000000 [8]             CALL  NWK_MLME_SapHandler
  0032 4d       [1]             TSTA  
  0033 260a     [3]             BNE   L3F ;abs = 003f
  895:      {
  896:        UartUtil_Print("Done\n\r", gAllowToBlock_d);
  0035 450000   [3]             LDHX  @"Done\012\015"
  0038 ac000056 [8]             CALL  App_StartScan:86
  897:        return errorNoError;
  003c 4f       [1]             CLRA  
  003d 2014     [3]             BRA   L53 ;abs = 0053
  003f          L3F:    
  898:      }
  899:      else
  900:      {
  901:        UartUtil_Print("Invalid parameter!\n\r", gAllowToBlock_d);
  003f 450000   [3]             LDHX  @"Invalid parameter!\012\015"
  0042 ac000056 [8]             CALL  App_StartScan:86
  902:        return errorInvalidParameter;
  0046 a605     [2]             LDA   #5
  0048 2009     [3]             BRA   L53 ;abs = 0053
  004a          L4A:    
  903:      }
  904:    }
  905:    else
  906:    {
  907:      /* Allocation of a message buffer failed. */
  908:      UartUtil_Print("Message allocation failed!\n\r", gAllowToBlock_d);
  004a 450000   [3]             LDHX  @"Message allocation failed!\012\015"
  004d ac000056 [8]             CALL  App_StartScan:86
  909:      return errorAllocFailed;
  0051 a604     [2]             LDA   #4
  0053          L53:    
  910:    }
  911:  }
  0053 a703     [2]             AIS   #3
  0055 8d       [7]             RTC   
  0056          L56:    
  0056 a601     [2]             LDA   #1
  0058 ac000000 [8]             CALL  UartUtil_Print
  005c 8d       [7]             RTC   
  912:  
  913:  /******************************************************************************
  914:  * The App_HandleScanActiveConfirm(nwkMessage_t *pMsg) function will handle the
  915:  * Active Scan confirm message received from the MLME when the Active scan has
  916:  * completed. The message contains a list of PAN descriptors. Based on link
  917:  * quality information in the pan descriptors the nearest coordinator is chosen.
  918:  * The corresponding pan descriptor is stored in the global variable mCoordInfo. 
  919:  *
  920:  * If a suitable coordinator was found, we synchronize to it immediately.
  921:  *
  922:  * The function may return either of the following values:
  923:  *   errorNoError:       A suitable pan descriptor was found.
  924:  *   errorNoScanResults: No scan results were present in the confirm message.
  925:  *
  926:  ******************************************************************************/
  927:  static uint8_t App_HandleScanActiveConfirm(nwkMessage_t *pMsg)
  928:  {
  0000 a7f3     [2]             AIS   #-13
  929:    void    *pBlock;
  930:    uint8_t panDescListSize = pMsg->msgData.scanCnf.resultListSize;
  0002 e603     [3]             LDA   3,X
  0004 9ee70a   [4]             STA   10,SP
  931:    uint8_t rc = errorNoScanResults;
  0007 a606     [2]             LDA   #6
  0009 9ee707   [4]             STA   7,SP
  932:    uint8_t j;
  933:    uint8_t bestLinkQuality = 0;  
  000c 9e6f09   [6]             CLR   9,SP
  934:    panDescriptorBlock_t *pDescBlock = pMsg->msgData.scanCnf.resList.pPanDescriptorBlocks;  
  000f 9ece08   [5]             LDHX  8,X
  0012 9eff05   [5]             STHX  5,SP
  935:    panDescriptor_t *pPanDesc;      
  936:   
  937:    /* Check if the scan resulted in any coordinator responses. */  
  938:    
  939:    if (panDescListSize > 0)
  0015 95       [2]             TSX   
  0016 6d09     [4]             TST   9,X
  0018 266d     [3]             BNE   L87 ;abs = 0087
  001a 206e     [3]             BRA   L8A ;abs = 008a
  001c          L1C:    
  940:    {    
  941:      /* Check all PAN descriptors. */
  942:      while (NULL != pDescBlock)
  943:      {
  944:        for (j = 0; j < pDescBlock->descriptorCount; j++)
  001c 95       [2]             TSX   
  001d 6f07     [5]             CLR   7,X
  001f 204b     [3]             BRA   L6C ;abs = 006c
  0021          L21:    
  945:        {            
  946:          pPanDesc = &pDescBlock->descriptorList[j];
  0021 95       [2]             TSX   
  0022 e607     [3]             LDA   7,X
  0024 ae16     [2]             LDX   #22
  0026 42       [5]             MUL   
  0027 9efe05   [5]             LDHX  5,SP
  002a 9eeb06   [4]             ADD   6,SP
  002d 87       [2]             PSHA  
  002e 8b       [2]             PSHH  
  002f 86       [3]             PULA  
  0030 a900     [2]             ADC   #0
  0032 88       [3]             PULX  
  947:  
  948:          /* Only attempt to associate if the coordinator accepts associations. */
  949:          if( pPanDesc->superFrameSpec[1] & gSuperFrameSpecMsbAssocPermit_c) 
  0033 87       [2]             PSHA  
  0034 8a       [3]             PULH  
  0035 e610     [3]             LDA   16,X
  0037 2a30     [3]             BPL   L69 ;abs = 0069
  950:          {
  951:            if ((pPanDesc->coordPanId[1]==coordinaterPanId[1])&&
  0039 e609     [3]             LDA   9,X
  003b a170     [2]             CMP   #112
  003d 262a     [3]             BNE   L69 ;abs = 0069
  952:                (pPanDesc->coordPanId[0]==coordinaterPanId[0]))
  003f e608     [3]             LDA   8,X
  0041 a104     [2]             CMP   #4
  0043 2624     [3]             BNE   L69 ;abs = 0069
  953:            {
  954:              /* Find the nearest coordinator using the link quality measure. */
  955:              if(pPanDesc->linkQuality > bestLinkQuality)
  0045 9ee609   [4]             LDA   9,SP
  0048 e112     [3]             CMP   18,X
  004a 241d     [3]             BCC   L69 ;abs = 0069
  956:              {
  957:                /* Save the information of the coordinator candidate. If we
  958:                   find a better candiate, the information will be replaced. */
  959:                FLib_MemCpy(&mCoordInfo, pPanDesc, sizeof(panDescriptor_t));
  004c 9eff01   [5]             STHX  1,SP
  004f 450000   [3]             LDHX  @mCoordInfo
  0052 89       [2]             PSHX  
  0053 8b       [2]             PSHH  
  0054 9efe03   [5]             LDHX  3,SP
  0057 a616     [2]             LDA   #22
  0059 ac000000 [8]             CALL  FLib_MemCpy
  005d a702     [2]             AIS   #2
  960:                bestLinkQuality = pPanDesc->linkQuality;
  005f 9efe01   [5]             LDHX  1,SP
  0062 e612     [3]             LDA   18,X
  0064 95       [2]             TSX   
  0065 e708     [3]             STA   8,X
  961:                rc = errorNoError;
  0067 6f06     [5]             CLR   6,X
  0069          L69:    
  0069 95       [2]             TSX   
  006a 6c07     [5]             INC   7,X
  006c          L6C:    
  006c 9efe05   [5]             LDHX  5,SP
  006f e66e     [3]             LDA   110,X
  0071 9ee108   [4]             CMP   8,SP
  0074 22ab     [3]             BHI   L21 ;abs = 0021
  962:              }
  963:            }
  964:          }      
  965:        }
  966:        
  967:        /* Free current block */
  968:        pBlock = pDescBlock;
  969:        pDescBlock = pDescBlock->pNext;              
  0076 89       [2]             PSHX  
  0077 8b       [2]             PSHH  
  0078 9ece6f   [5]             LDHX  111,X
  007b 9eff07   [5]             STHX  7,SP
  970:        MSG_Free(pBlock);
  007e 9efe01   [5]             LDHX  1,SP
  0081 ac000000 [8]             CALL  MM_Free
  0085 a702     [2]             AIS   #2
  0087          L87:    
  0087 9efe05   [5]             LDHX  5,SP
  008a          L8A:    
  008a 2690     [3]             BNE   L1C ;abs = 001c
  971:      }
  972:    }
  973:  
  974:    if(rc == errorNoError)
  008c 95       [2]             TSX   
  008d 6d06     [4]             TST   6,X
  008f 2703     [3]             BEQ   L94 ;abs = 0094
  0091 cc0150   [4]             JMP   L150 ;abs = 0150
  0094          L94:    
  975:    {
  976:      /* If we have found a beaconing coodinator we must setup the MAC to
  977:         synchronize to the beacon frames. This requires us to set the
  978:         PAN ID attribute of the MAC PIB to the PAN ID of the coordinator.
  979:         Furthermore, if we want to take advantage of the automatic
  980:         polling feature we must set the Auto Request MAC PIB attribute. */
  981:      if((mCoordInfo.superFrameSpec[0] & gSuperFrameSpecLsbBO_c) < 0xF) 
  0094 c6000f   [4]             LDA   mCoordInfo:15
  0097 a40f     [2]             AND   #15
  0099 a10f     [2]             CMP   #15
  009b 2503     [3]             BCS   LA0 ;abs = 00a0
  009d cc0150   [4]             JMP   L150 ;abs = 0150
  00a0          LA0:    
  982:      {
  983:        mlmeMessage_t *pMsgOut = MSG_AllocType(mlmeMessage_t);
  00a0 a60f     [2]             LDA   #15
  00a2 ac000000 [8]             CALL  MM_Alloc
  00a6 9eff03   [5]             STHX  3,SP
  984:        if(pMsgOut != NULL)
  00a9 2603     [3]             BNE   LAE ;abs = 00ae
  00ab cc0150   [4]             JMP   L150 ;abs = 0150
  00ae          LAE:    
  985:        {
  986:          uint8_t value = TRUE;
  00ae a601     [2]             LDA   #1
  00b0 95       [2]             TSX   
  00b1 e70a     [3]             STA   10,X
  987:          uint8_t mBeaconOrder;
  988:  		uint8_t mSuperFrameOrder;
  989:          /* Set MAC PIB auto request to TRUE. In this way the device will
  990:             automatically poll for data if the pending address list of the 
  991:             beacon frame contains our address. */
  992:          pMsgOut->msgType = gMlmeSetReq_c;
  00b3 9efe03   [5]             LDHX  3,SP
  00b6 a609     [2]             LDA   #9
  00b8 f7       [2]             STA   ,X
  993:          pMsgOut->msgData.setReq.pibAttribute = gMPibAutoRequest_c;
  00b9 a642     [2]             LDA   #66
  00bb e701     [3]             STA   1,X
  994:          pMsgOut->msgData.setReq.pibAttributeValue = &value;
  00bd 95       [2]             TSX   
  00be af0a     [2]             AIX   #10
  00c0 9f       [1]             TXA   
  00c1 8b       [2]             PSHH  
  00c2 9efe04   [5]             LDHX  4,SP
  00c5 e703     [3]             STA   3,X
  00c7 86       [3]             PULA  
  00c8 e702     [3]             STA   2,X
  995:          /* Get/Set/Reset Request messages are NOT freed by the MLME. */
  996:          (void)MSG_Send(NWK_MLME, pMsgOut);
  00ca ac000000 [8]             CALL  NWK_MLME_SapHandler
  997:          
  998:          /* Since we are going to receive data from the coordinator 
  999:             using automatic polling we must synchronize to the beacon
 1000:             and keep tracking it. Before synchronizing it is required
 1001:             that the MAC PIB PAN ID, and the MAC PIB coordinator
 1002:             address is set. */
 1003:          pMsgOut->msgData.setReq.pibAttribute = gMPibPanId_c;
  00ce 9efe03   [5]             LDHX  3,SP
  00d1 a650     [2]             LDA   #80
  00d3 e701     [3]             STA   1,X
 1004:          pMsgOut->msgData.setReq.pibAttributeValue = mCoordInfo.coordPanId;
  00d5 a608     [2]             LDA   @mCoordInfo:8:MSB
  00d7 e702     [3]             STA   2,X
  00d9 a608     [2]             LDA   @mCoordInfo:8
  00db e703     [3]             STA   3,X
 1005:          /* Get/Set/Reset Request messages are NOT freed by the MLME. */
 1006:          (void)MSG_Send(NWK_MLME, pMsgOut);
  00dd ac000000 [8]             CALL  NWK_MLME_SapHandler
 1007:  
 1008:          /* Set coordinator address PIB attribute according the the 
 1009:             address mode of the coordinator (short or long address). */
 1010:          pMsgOut->msgData.setReq.pibAttribute = 
 1011:            mCoordInfo.coordAddrMode == gAddrModeShort_c ? gMPibCoordShortAddress_c :
  00e1 c6000a   [4]             LDA   mCoordInfo:10
  00e4 410203   [4]             CBEQA #2,LEA ;abs = 00ea
 1012:                                                          gMPibCoordExtendedAddress_c;
  00e7 a64a     [2]             LDA   #74
  00e9 65       [3]             SKIP2 LEC ;abs = 00ec
  00ea          LEA:    
  00ea a64b     [2]             LDA   #75
  00ec          LEC:    
  00ec 9efe03   [5]             LDHX  3,SP
  00ef e701     [3]             STA   1,X
 1013:          pMsgOut->msgData.setReq.pibAttributeValue = mCoordInfo.coordAddress;
  00f1 a600     [2]             LDA   @mCoordInfo:MSB
  00f3 e702     [3]             STA   2,X
  00f5 a600     [2]             LDA   @mCoordInfo
  00f7 e703     [3]             STA   3,X
 1014:          /* Get/Set/Reset Request messages are NOT freed by the MLME. */
 1015:          (void)MSG_Send(NWK_MLME, pMsgOut);
  00f9 ac000000 [8]             CALL  NWK_MLME_SapHandler
 1016:  
 1017:  
 1018:          /* Set macBeaconOrder PIB attribute according to the 
 1019:             value found in beacon.*/
 1020:          mBeaconOrder = (mCoordInfo.superFrameSpec[0] & 0x0F);   
  00fd c6000f   [4]             LDA   mCoordInfo:15
  0100 a40f     [2]             AND   #15
  0102 95       [2]             TSX   
  0103 e70b     [3]             STA   11,X
 1021:          pMsgOut->msgData.setReq.pibAttribute = gMPibBeaconOrder_c;                                             
  0105 9efe03   [5]             LDHX  3,SP
  0108 a647     [2]             LDA   #71
  010a e701     [3]             STA   1,X
 1022:          pMsgOut->msgData.setReq.pibAttributeValue = &mBeaconOrder;
  010c 95       [2]             TSX   
  010d af0b     [2]             AIX   #11
  010f 9f       [1]             TXA   
  0110 8b       [2]             PSHH  
  0111 9efe04   [5]             LDHX  4,SP
  0114 e703     [3]             STA   3,X
  0116 86       [3]             PULA  
  0117 e702     [3]             STA   2,X
 1023:          /* Get/Set/Reset Request messages are NOT freed by the MLME. */
 1024:          (void)MSG_Send(NWK_MLME, pMsgOut);
  0119 ac000000 [8]             CALL  NWK_MLME_SapHandler
 1025:  
 1026:          /* Set macSuperFrameOrder PIB attribute according to the 
 1027:             value found in beacon.*/
 1028:          mSuperFrameOrder = (mCoordInfo.superFrameSpec[0] & 0xF0);   
  011d c6000f   [4]             LDA   mCoordInfo:15
  0120 a4f0     [2]             AND   #-16
  0122 95       [2]             TSX   
  0123 e70c     [3]             STA   12,X
 1029:          pMsgOut->msgData.setReq.pibAttribute = gMPibSuperFrameOrder_c;                                             
  0125 9efe03   [5]             LDHX  3,SP
  0128 a654     [2]             LDA   #84
  012a e701     [3]             STA   1,X
 1030:          pMsgOut->msgData.setReq.pibAttributeValue = &mSuperFrameOrder;
  012c 95       [2]             TSX   
  012d af0c     [2]             AIX   #12
  012f 9f       [1]             TXA   
  0130 8b       [2]             PSHH  
  0131 9efe04   [5]             LDHX  4,SP
  0134 e703     [3]             STA   3,X
  0136 86       [3]             PULA  
  0137 e702     [3]             STA   2,X
 1031:          /* Get/Set/Reset Request messages are NOT freed by the MLME. */
 1032:          (void)MSG_Send(NWK_MLME, pMsgOut);  
  0139 ac000000 [8]             CALL  NWK_MLME_SapHandler
 1033:          
 1034:          /* Now send the MLME-Sync Request. We choose to let the MAC track
 1035:             the beacons on the logical channel obtained by the active scan.*/
 1036:          pMsgOut->msgType = gMlmeSyncReq_c;
  013d 9efe03   [5]             LDHX  3,SP
  0140 a60b     [2]             LDA   #11
  0142 f7       [2]             STA   ,X
 1037:          pMsgOut->msgData.syncReq.trackBeacon = TRUE;
  0143 a601     [2]             LDA   #1
  0145 e702     [3]             STA   2,X
 1038:          pMsgOut->msgData.syncReq.logicalChannel = mCoordInfo.logicalChannel;
  0147 c6000b   [4]             LDA   mCoordInfo:11
  014a e701     [3]             STA   1,X
 1039:          (void)MSG_Send(NWK_MLME, pMsgOut);
  014c ac000000 [8]             CALL  NWK_MLME_SapHandler
  0150          L150:   
 1040:        }
 1041:      }
 1042:    }
 1043:    
 1044:    return rc;
  0150 95       [2]             TSX   
  0151 e606     [3]             LDA   6,X
 1045:  }
  0153 a70d     [2]             AIS   #13
  0155 8d       [7]             RTC   
 1046:  
 1047:  
 1048:  /******************************************************************************
 1049:  * The App_SendAssociateRequest(void) will create an Associate Request message
 1050:  * and send it to the coordinator it wishes to associate to. The function uses
 1051:  * information gained about the coordinator during the scan procedure.
 1052:  *
 1053:  * The function may return either of the following values:
 1054:  *   errorNoError:          The Associate Request message was sent successfully.
 1055:  *   errorInvalidParameter: The MLME service access point rejected the
 1056:  *                          message due to an invalid parameter.
 1057:  *   errorAllocFailed:      A message buffer could not be allocated.
 1058:  *
 1059:  ******************************************************************************/
 1060:  static uint8_t App_SendAssociateRequest(void)
 1061:  {
  0000 a7fc     [2]             AIS   #-4
 1062:    mlmeMessage_t *pMsg;
 1063:    mlmeAssociateReq_t *pAssocReq;
 1064:  
 1065:    UartUtil_Print("Sending the MLME-Associate Request message to the MAC...", gAllowToBlock_d);
  0002 450000   [3]             LDHX  @"Sending the MLME-Associate Request message to the MAC..."
  0005 ac000077 [8]             CALL  App_SendAssociateRequest:119
 1066:    
 1067:    /* Allocate a message for the MLME message. */
 1068:    pMsg = MSG_AllocType(mlmeMessage_t);
  0009 a60f     [2]             LDA   #15
  000b ac000000 [8]             CALL  MM_Alloc
  000f 9eff03   [5]             STHX  3,SP
 1069:    if(pMsg != NULL)
  0012 2757     [3]             BEQ   L6B ;abs = 006b
 1070:    {
 1071:      /* This is a MLME-ASSOCIATE.req command. */
 1072:      pMsg->msgType = gMlmeAssociateReq_c;
  0014 7f       [4]             CLR   ,X
 1073:      
 1074:      /* Create the Associate request message data. */
 1075:      pAssocReq = &pMsg->msgData.associateReq;
  0015 af01     [2]             AIX   #1
 1076:   
 1077:      /* Use the coordinator info we got from the Active Scan. */
 1078:      FLib_MemCpy(pAssocReq->coordAddress, mCoordInfo.coordAddress, 8);
  0017 89       [2]             PSHX  
  0018 8b       [2]             PSHH  
  0019 9eff03   [5]             STHX  3,SP
  001c 450000   [3]             LDHX  @mCoordInfo
  001f a608     [2]             LDA   #8
  0021 ac000000 [8]             CALL  FLib_MemCpy
  0025 a702     [2]             AIS   #2
 1079:      FLib_MemCpy(pAssocReq->coordPanId,   mCoordInfo.coordPanId, 2);
  0027 9efe01   [5]             LDHX  1,SP
  002a af08     [2]             AIX   #8
  002c 89       [2]             PSHX  
  002d 8b       [2]             PSHH  
  002e 450008   [3]             LDHX  @mCoordInfo:8
  0031 a602     [2]             LDA   #2
  0033 ac000000 [8]             CALL  FLib_MemCpy
  0037 a702     [2]             AIS   #2
 1080:      pAssocReq->coordAddrMode      = mCoordInfo.coordAddrMode;
  0039 c6000a   [4]             LDA   mCoordInfo:10
  003c 9efe01   [5]             LDHX  1,SP
  003f e70a     [3]             STA   10,X
 1081:      pAssocReq->logicalChannel     = mCoordInfo.logicalChannel;
  0041 c6000b   [4]             LDA   mCoordInfo:11
  0044 e70b     [3]             STA   11,X
 1082:  #ifndef gMAC2006_d
 1083:      pAssocReq->securityEnable     = FALSE;
  0046 6f0c     [5]             CLR   12,X
 1084:  #else
 1085:  	pAssocReq->securityLevel = 0;
 1086:  #endif //gMAC2006_d	
 1087:      /* We want the coordinator to assign a short address to us. */
 1088:      pAssocReq->capabilityInfo     = gCapInfoAllocAddr_c;
  0048 a680     [2]             LDA   #-128
  004a e70d     [3]             STA   13,X
 1089:        
 1090:      /* Send the Associate Request to the MLME. */
 1091:      if(MSG_Send(NWK_MLME, pMsg) == gSuccess_c)
  004c 9efe03   [5]             LDHX  3,SP
  004f ac000000 [8]             CALL  NWK_MLME_SapHandler
  0053 4d       [1]             TSTA  
  0054 260a     [3]             BNE   L60 ;abs = 0060
 1092:      {
 1093:        UartUtil_Print("Done\n\r", gAllowToBlock_d);
  0056 450000   [3]             LDHX  @"Done\012\015"
  0059 ac000077 [8]             CALL  App_SendAssociateRequest:119
 1094:        return errorNoError;
  005d 4f       [1]             CLRA  
  005e 2014     [3]             BRA   L74 ;abs = 0074
  0060          L60:    
 1095:      }
 1096:      else
 1097:      {
 1098:        /* One or more parameters in the message were invalid. */
 1099:        UartUtil_Print("Invalid parameter!\n\r", gAllowToBlock_d);
  0060 450000   [3]             LDHX  @"Invalid parameter!\012\015"
  0063 ac000077 [8]             CALL  App_SendAssociateRequest:119
 1100:        return errorInvalidParameter;
  0067 a605     [2]             LDA   #5
  0069 2009     [3]             BRA   L74 ;abs = 0074
  006b          L6B:    
 1101:      }
 1102:    }
 1103:    else
 1104:    {
 1105:      /* Allocation of a message buffer failed - 
 1106:         the state machine will call us again. */
 1107:      UartUtil_Print("Message allocation failed - retrying...\n\r", gAllowToBlock_d);
  006b 450000   [3]             LDHX  @"Message allocation failed - retrying...\012\015"
  006e ac000077 [8]             CALL  App_SendAssociateRequest:119
 1108:      return errorAllocFailed;
  0072 a604     [2]             LDA   #4
  0074          L74:    
 1109:    }
 1110:  }
  0074 a704     [2]             AIS   #4
  0076 8d       [7]             RTC   
  0077          L77:    
  0077 a601     [2]             LDA   #1
  0079 ac000000 [8]             CALL  UartUtil_Print
  007d 8d       [7]             RTC   
 1111:  
 1112:  /******************************************************************************
 1113:  * The App_HandleAssociateConfirm(nwkMessage_t *pMsg) function will handle the
 1114:  * Associate confirm message received from the MLME when the Association
 1115:  * procedure has completed. The message contains the short address that the
 1116:  * coordinator has assigned to us. This address is 0xfffe if we did not specify
 1117:  * the gCapInfoAllocAddr_c flag in the capability info field of the Associate
 1118:  * request. The address and address mode are saved in global variables. They
 1119:  * will be used in the next demo application when sending data.
 1120:  *
 1121:  ******************************************************************************/
 1122:  static uint8_t App_HandleAssociateConfirm(nwkMessage_t *pMsg)
 1123:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  0002 8b       [2]             PSHH  
 1124:  
 1125:  	mlmeMessage_t *pMsg_;
 1126:  	uint8_t ret;
 1127:  	uint8_t boolFlag;
 1128:  
 1129:  	
 1130:    /* This is our own extended address (MAC address). It cannot be modified. */
 1131:    extern uint8_t aExtendedAddress[8];
 1132:    
 1133:    /* If the coordinator assigns a short address of 0xfffe then,
 1134:       that means we must use our own extended address in all
 1135:       communications with the coordinator. Otherwise, we use
 1136:       the short address assigned to us. */
 1137:    if ( pMsg->msgData.associateCnf.status == gSuccess_c) 
  0003 6d03     [4]             TST   3,X
  0005 2663     [3]             BNE   L6A ;abs = 006a
 1138:    {
 1139:  
 1140:      if( (pMsg->msgData.associateCnf.assocShortAddress[0] >= 0xFE) && 
  0007 e601     [3]             LDA   1,X
  0009 a1fe     [2]             CMP   #-2
  000b 2516     [3]             BCS   L23 ;abs = 0023
 1141:          (pMsg->msgData.associateCnf.assocShortAddress[1] == 0xFF) )
  000d e602     [3]             LDA   2,X
  000f 4c       [1]             INCA  
  0010 2611     [3]             BNE   L23 ;abs = 0023
 1142:      {
 1143:        mAddrMode = gAddrModeLong_c;
  0012 a603     [2]             LDA   #3
  0014 c70000   [4]             STA   mAddrMode
 1144:        FLib_MemCpy(maMyAddress, (void *)aExtendedAddress, 8);
  0017 450000   [3]             LDHX  @maMyAddress
  001a 89       [2]             PSHX  
  001b 8b       [2]             PSHH  
  001c 450000   [3]             LDHX  @aExtendedAddress
  001f a608     [2]             LDA   #8
 1145:      }
  0021 200f     [3]             BRA   L32 ;abs = 0032
  0023          L23:    
 1146:      else
 1147:      {
 1148:        mAddrMode = gAddrModeShort_c;
  0023 a602     [2]             LDA   #2
  0025 c70000   [4]             STA   mAddrMode
 1149:        FLib_MemCpy(maMyAddress, pMsg->msgData.associateCnf.assocShortAddress, 2);
  0028 450000   [3]             LDHX  @maMyAddress
  002b 89       [2]             PSHX  
  002c 8b       [2]             PSHH  
  002d 9efe04   [5]             LDHX  4,SP
  0030 af01     [2]             AIX   #1
  0032          L32:    
  0032 ac000000 [8]             CALL  FLib_MemCpy
  0036 a702     [2]             AIS   #2
 1150:      }
 1151:      
 1152:      pMsg_=MSG_AllocType(mlmeMessage_t);
  0038 a60f     [2]             LDA   #15
  003a ac000000 [8]             CALL  MM_Alloc
 1153:      if (pMsg_ !=NULL)
  003e 650000   [3]             CPHX  #0
  0041 2725     [3]             BEQ   L68 ;abs = 0068
 1154:      {
 1155:      	pMsg_->msgType=gMlmeSetReq_c;
  0043 a609     [2]             LDA   #9
  0045 f7       [2]             STA   ,X
 1156:      	pMsg_->msgData.setReq.pibAttribute=gMPibRxOnWhenIdle_c;
  0046 a652     [2]             LDA   #82
  0048 e701     [3]             STA   1,X
 1157:      	boolFlag=TRUE;
  004a a601     [2]             LDA   #1
 1158:      	pMsg_->msgData.setReq.pibAttributeValue=&boolFlag;
  004c 89       [2]             PSHX  
  004d 8b       [2]             PSHH  
  004e 95       [2]             TSX   
  004f e702     [3]             STA   2,X
  0051 af02     [2]             AIX   #2
  0053 8b       [2]             PSHH  
  0054 9ee602   [4]             LDA   2,SP
  0057 87       [2]             PSHA  
  0058 8a       [3]             PULH  
  0059 9f       [1]             TXA   
  005a 9eee03   [4]             LDX   3,SP
  005d e703     [3]             STA   3,X
  005f 86       [3]             PULA  
  0060 e702     [3]             STA   2,X
 1159:      	ret=MSG_Send(NWK_MLME,pMsg_);
  0062 ac000000 [8]             CALL  NWK_MLME_SapHandler
  0066 a702     [2]             AIS   #2
  0068          L68:    
 1160:      }
 1161:      
 1162:      return gSuccess_c;
  0068 4f       [1]             CLRA  
  0069 65       [3]             SKIP2 L6C ;abs = 006c
  006a          L6A:    
 1163:    } 
 1164:    
 1165:    else 
 1166:    {
 1167:    return pMsg->msgData.associateCnf.status; 
  006a e603     [3]             LDA   3,X
  006c          L6C:    
 1168:    }
 1169:  }
  006c a703     [2]             AIS   #3
  006e 8d       [7]             RTC   
 1170:  
 1171:  
 1172:  /******************************************************************************
 1173:  * The App_HandleMcpsInput(mcpsToNwkMessage_t *pMsgIn) function will handle 
 1174:  * messages from the MCPS, e.g. Data Confirm, and Data Indication.
 1175:  *
 1176:  ******************************************************************************/
 1177:  static void App_HandleMcpsInput(mcpsToNwkMessage_t *pMsgIn)
 1178:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  0002 a7fe     [2]             AIS   #-2
 1179:    switch(pMsgIn->msgType)
  0004 f6       [3]             LDA   ,X
  0005 2704     [3]             BEQ   LB ;abs = 000b
  0007 4b1f     [4]             DBNZA L28 ;abs = 0028
  0009 200b     [3]             BRA   L16 ;abs = 0016
  000b          LB:     
 1180:    {
 1181:      /* The MCPS-Data confirm is sent by the MAC to the network 
 1182:         or application layer when data has been sent. */
 1183:    case gMcpsDataCnf_c:
 1184:      if(mcPendingPackets)
  000b c60000   [4]             LDA   mcPendingPackets
  000e 2718     [3]             BEQ   L28 ;abs = 0028
 1185:        mcPendingPackets--;
  0010 450000   [3]             LDHX  @mcPendingPackets
  0013 7a       [4]             DEC   ,X
  0014 2012     [3]             BRA   L28 ;abs = 0028
  0016          L16:    
 1186:      break;
 1187:  
 1188:    case gMcpsDataInd_c:
 1189:      /* Copy the received data to the UART. */
 1190:      UartUtil_Tx(pMsgIn->msgData.dataInd.pMsdu, pMsgIn->msgData.dataInd.msduLength);
  0016 9ece1b   [5]             LDHX  27,X
  0019 9eff01   [5]             STHX  1,SP
  001c 9efe03   [5]             LDHX  3,SP
  001f e617     [3]             LDA   23,X
  0021 9efe01   [5]             LDHX  1,SP
  0024 ac000000 [8]             CALL  UartUtil_Tx
  0028          L28:    
 1191:      break;
 1192:    }
 1193:  }
  0028 a704     [2]             AIS   #4
  002a 8d       [7]             RTC   
 1194:  
 1195:  /******************************************************************************
 1196:  * The App_WaitMsg(nwkMessage_t *pMsg, uint8_t msgType) function does not, as
 1197:  * the name implies, wait for a message, thus blocking the execution of the
 1198:  * state machine. Instead the function analyzes the supplied message to 
 1199:  * determine whether or not the message is of the expected type.
 1200:  * The function may return either of the following values:
 1201:  *   errorNoError: The message was of the expected type.
 1202:  *   errorNoMessage: The message pointer is NULL.
 1203:  *   errorWrongConfirm: The message is not of the expected type.
 1204:  *
 1205:  ******************************************************************************/
 1206:  static uint8_t App_WaitMsg(nwkMessage_t *pMsg, uint8_t msgType)
 1207:  {
 1208:    /* Do we have a message? If not, the exit with error code */
 1209:    if(pMsg == NULL)
  0000 650000   [3]             CPHX  #0
  0003 2603     [3]             BNE   L8 ;abs = 0008
 1210:      return errorNoMessage;
  0005 a603     [2]             LDA   #3
  0007 8d       [7]             RTC   
  0008          L8:     
 1211:  
 1212:    /* Is it the expected message type? If not then exit with error code */
 1213:    if(pMsg->msgType != msgType)
  0008 f1       [3]             CMP   ,X
  0009 2703     [3]             BEQ   LE ;abs = 000e
 1214:      return errorWrongConfirm;
  000b a601     [2]             LDA   #1
  000d 8d       [7]             RTC   
  000e          LE:     
 1215:  
 1216:    /* Found the expected message. Return with success code */
 1217:    return errorNoError;
  000e 4f       [1]             CLRA  
 1218:  }
  000f 8d       [7]             RTC   
 1219:  
 1220:  
 1221:  void App_TransmitSensorData(void){
  0000 a7f5     [2]             AIS   #-11
 1222:  	
 1223:  	uint8_t i;
 1224:  
 1225:  	static uint8_t sens_count=0;
 1226:  	static int16_t x_avg=0;
 1227:  	static int16_t y_avg=0;
 1228:  	static int16_t z_avg=0;
 1229:  
 1230:  	uint8_t sens_data[7];
 1231:  
 1232:  	volatile int16_t val;
 1233:  
 1234:  	UartUtil_Print("\n\r-----------------------------------------------\n\r", gAllowToBlock_d); 
  0002 450000   [3]             LDHX  @"\012\015-----------------------------------------------\012\015"
  0005 ac0001b3 [8]             CALL  App_TransmitSensorData:435
 1235:  	for(i=1; i<4; i++){
  0009 a601     [2]             LDA   #1
  000b 95       [2]             TSX   
  000c e701     [3]             STA   1,X
  000e          LE:     
 1236:  		val = MMA8652_CatchSensorData(i);
  000e 95       [2]             TSX   
  000f e601     [3]             LDA   1,X
  0011 ac000000 [8]             CALL  MMA8652_CatchSensorData
  0015 9eff0a   [5]             STHX  10,SP
 1237:  		switch(i){
  0018 95       [2]             TSX   
  0019 e601     [3]             LDA   1,X
  001b a103     [2]             CMP   #3
  001d 2251     [3]             BHI   L70 ;abs = 0070
  001f 410109   [4]             CBEQA #1,L2B ;abs = 002b
  0022 41021b   [4]             CBEQA #2,L40 ;abs = 0040
  0025 a103     [2]             CMP   #3
  0027 2647     [3]             BNE   L70 ;abs = 0070
  0029 202a     [3]             BRA   L55 ;abs = 0055
  002b          L2B:    
 1238:  		case 1:
 1239:  			x_avg = (x_avg * sens_count + val)/(sens_count + 1);
  002b 320000   [5]             LDHX  x_avg
  002e ac0001a4 [8]             CALL  App_TransmitSensorData:420
  0032 89       [2]             PSHX  
  0033 8b       [2]             PSHH  
  0034 ac000181 [8]             CALL  App_TransmitSensorData:385
  0038 960000   [5]             STHX  x_avg
 1240:  			UartUtil_Print("MMA8652(2g: Int2,Float10) \n\rX axis : 0x", gAllowToBlock_d); 
  003b 450000   [3]             LDHX  @"MMA8652(2g: Int2,Float10) \012\015X axis : 0x"
 1241:  			break;
  003e 2028     [3]             BRA   L68 ;abs = 0068
  0040          L40:    
 1242:  		case 2:
 1243:  			y_avg = (y_avg * sens_count + val)/(sens_count + 1);
  0040 320000   [5]             LDHX  y_avg
  0043 ac0001a4 [8]             CALL  App_TransmitSensorData:420
  0047 89       [2]             PSHX  
  0048 8b       [2]             PSHH  
  0049 ac000181 [8]             CALL  App_TransmitSensorData:385
  004d 960000   [5]             STHX  y_avg
 1244:  			UartUtil_Print(" /1024 [g]\n\rY axis : 0x", gAllowToBlock_d);  				
  0050 450000   [3]             LDHX  @" /1024 [g]\012\015Y axis : 0x"
 1245:  			break;
  0053 2013     [3]             BRA   L68 ;abs = 0068
  0055          L55:    
 1246:  		case 3:
 1247:  			z_avg = (z_avg * sens_count + val)/(sens_count + 1);
  0055 320000   [5]             LDHX  z_avg
  0058 ac0001a4 [8]             CALL  App_TransmitSensorData:420
  005c 89       [2]             PSHX  
  005d 8b       [2]             PSHH  
  005e ac000181 [8]             CALL  App_TransmitSensorData:385
  0062 960000   [5]             STHX  z_avg
 1248:  			UartUtil_Print(" /1024 [g]\n\rZ axis : 0x", gAllowToBlock_d);  		
  0065 450000   [3]             LDHX  @" /1024 [g]\012\015Z axis : 0x"
  0068          L68:    
  0068 ac0001b3 [8]             CALL  App_TransmitSensorData:435
 1249:  			break;
  006c a702     [2]             AIS   #2
  006e 2007     [3]             BRA   L77 ;abs = 0077
  0070          L70:    
 1250:  		default:
 1251:  			UartUtil_Print("???????????????", gAllowToBlock_d);  		
  0070 450000   [3]             LDHX  @"???????????????"
  0073 ac0001b3 [8]             CALL  App_TransmitSensorData:435
  0077          L77:    
 1252:  			break;
 1253:  		}
 1254:  		UartUtil_PrintHex((uint8_t *)&val, 2, 1);
  0077 95       [2]             TSX   
  0078 af09     [2]             AIX   #9
  007a 89       [2]             PSHX  
  007b 8b       [2]             PSHH  
  007c ae02     [2]             LDX   #2
  007e a601     [2]             LDA   #1
  0080 ac000000 [8]             CALL  UartUtil_PrintHex
  0084 a702     [2]             AIS   #2
 1255:  		if(i==3){
  0086 95       [2]             TSX   
  0087 e601     [3]             LDA   1,X
  0089 a103     [2]             CMP   #3
  008b 2607     [3]             BNE   L94 ;abs = 0094
 1256:  			UartUtil_Print(" /1024 [g]", gAllowToBlock_d);  					
  008d 450000   [3]             LDHX  @" /1024 [g]"
  0090 ac0001b3 [8]             CALL  App_TransmitSensorData:435
  0094          L94:    
  0094 95       [2]             TSX   
  0095 6c01     [5]             INC   1,X
  0097 e601     [3]             LDA   1,X
  0099 a104     [2]             CMP   #4
  009b 2403     [3]             BCC   LA0 ;abs = 00a0
  009d cc000e   [4]             JMP   LE ;abs = 000e
  00a0          LA0:    
 1257:  		}
 1258:  	}
 1259:  
 1260:  	UartUtil_Print("\n\r-----------------------------------------------\n\r", gAllowToBlock_d); 
  00a0 450000   [3]             LDHX  @"\012\015-----------------------------------------------\012\015"
  00a3 ac0001b3 [8]             CALL  App_TransmitSensorData:435
 1261:  
 1262:  	sens_count++;
  00a7 450000   [3]             LDHX  @sens_count
  00aa 7c       [4]             INC   ,X
 1263:  
 1264:  	if (global_counter>=5){
  00ab c60000   [4]             LDA   global_counter
  00ae a105     [2]             CMP   #5
  00b0 2403     [3]             BCC   LB5 ;abs = 00b5
  00b2 cc017e   [4]             JMP   L17E ;abs = 017e
  00b5          LB5:    
 1265:  		global_counter=0;
  00b5 4f       [1]             CLRA  
  00b6 c70000   [4]             STA   global_counter
 1266:  
 1267:  		sens_data[0]=0x81;
  00b9 a681     [2]             LDA   #-127
  00bb 95       [2]             TSX   
  00bc e702     [3]             STA   2,X
 1268:  		sens_data[1]=(x_avg >> 8) & 0xFF;
  00be c60000   [4]             LDA   x_avg
  00c1 e703     [3]             STA   3,X
 1269:  		sens_data[2]=x_avg & 0xFF;
  00c3 c60001   [4]             LDA   x_avg:1
  00c6 e704     [3]             STA   4,X
 1270:  		sens_data[3]=(y_avg >> 8) & 0xFF;
  00c8 c60000   [4]             LDA   y_avg
  00cb e705     [3]             STA   5,X
 1271:  		sens_data[4]=y_avg & 0xFF;
  00cd c60001   [4]             LDA   y_avg:1
  00d0 e706     [3]             STA   6,X
 1272:  		sens_data[5]=(z_avg >> 8) & 0xFF;
  00d2 c60000   [4]             LDA   z_avg
  00d5 e707     [3]             STA   7,X
 1273:  		sens_data[6]=z_avg & 0xFF;
  00d7 c60001   [4]             LDA   z_avg:1
  00da e708     [3]             STA   8,X
 1274:  
 1275:  		UartUtil_Print("\n\r***************Average*************\n\r", gAllowToBlock_d); 
  00dc 450000   [3]             LDHX  @"\012\015***************Average*************\012\015"
  00df ac0001b3 [8]             CALL  App_TransmitSensorData:435
 1276:  
 1277:  		for(i=1; i<4; i++){
  00e3 a601     [2]             LDA   #1
  00e5 95       [2]             TSX   
  00e6 e701     [3]             STA   1,X
  00e8          LE8:    
 1278:  			switch(i){			
  00e8 95       [2]             TSX   
  00e9 e601     [3]             LDA   1,X
  00eb a103     [2]             CMP   #3
  00ed 221b     [3]             BHI   L10A ;abs = 010a
  00ef 410109   [4]             CBEQA #1,LFB ;abs = 00fb
  00f2 41020b   [4]             CBEQA #2,L100 ;abs = 0100
  00f5 a103     [2]             CMP   #3
  00f7 2611     [3]             BNE   L10A ;abs = 010a
  00f9 200a     [3]             BRA   L105 ;abs = 0105
  00fb          LFB:    
 1279:  			case 1:
 1280:  				UartUtil_Print("MMA8652(2g: Int2,Float10) \n\rX axis : 0x", gAllowToBlock_d); 
  00fb 450000   [3]             LDHX  @"MMA8652(2g: Int2,Float10) \012\015X axis : 0x"
 1281:  				break;
  00fe 200d     [3]             BRA   L10D ;abs = 010d
  0100          L100:   
 1282:  			case 2:
 1283:  				UartUtil_Print(" /1024 [g]\n\rY axis : 0x", gAllowToBlock_d);  
  0100 450000   [3]             LDHX  @" /1024 [g]\012\015Y axis : 0x"
 1284:  				break;
  0103 2008     [3]             BRA   L10D ;abs = 010d
  0105          L105:   
 1285:  			case 3:
 1286:  				UartUtil_Print(" /1024 [g]\n\rZ axis : 0x", gAllowToBlock_d);  		
  0105 450000   [3]             LDHX  @" /1024 [g]\012\015Z axis : 0x"
 1287:  				break;
  0108 2003     [3]             BRA   L10D ;abs = 010d
  010a          L10A:   
 1288:  			default:
 1289:  				UartUtil_Print("???????????????", gAllowToBlock_d);  		
  010a 450000   [3]             LDHX  @"???????????????"
  010d          L10D:   
  010d ac0001b3 [8]             CALL  App_TransmitSensorData:435
 1290:  				break;
 1291:  			}//switch(i){	 	
 1292:  
 1293:  			UartUtil_PrintHex((uint8_t *)&sens_data[2*i-1], 2, 1); 	
  0111 95       [2]             TSX   
  0112 e601     [3]             LDA   1,X
  0114 48       [1]             LSLA  
  0115 af02     [2]             AIX   #2
  0117 4a       [1]             DECA  
  0118 9ee701   [4]             STA   1,SP
  011b 9f       [1]             TXA   
  011c 9eeb01   [4]             ADD   1,SP
  011f 87       [2]             PSHA  
  0120 8b       [2]             PSHH  
  0121 86       [3]             PULA  
  0122 a900     [2]             ADC   #0
  0124 87       [2]             PSHA  
  0125 ae02     [2]             LDX   #2
  0127 a601     [2]             LDA   #1
  0129 ac000000 [8]             CALL  UartUtil_PrintHex
  012d a702     [2]             AIS   #2
 1294:  
 1295:  			if(i==3){
  012f 95       [2]             TSX   
  0130 e601     [3]             LDA   1,X
  0132 a103     [2]             CMP   #3
  0134 2607     [3]             BNE   L13D ;abs = 013d
 1296:  				UartUtil_Print(" /1024 [g]", gAllowToBlock_d);  					
  0136 450000   [3]             LDHX  @" /1024 [g]"
  0139 ac0001b3 [8]             CALL  App_TransmitSensorData:435
  013d          L13D:   
  013d 95       [2]             TSX   
  013e 6c01     [5]             INC   1,X
  0140 e601     [3]             LDA   1,X
  0142 a104     [2]             CMP   #4
  0144 25a2     [3]             BCS   LE8 ;abs = 00e8
 1297:  			}
 1298:  
 1299:  		} //for(i=1; i<4; i++){
 1300:  
 1301:  
 1302:  		UartUtil_Print("\n\r*********************************\n\r", gAllowToBlock_d); 		
  0146 450000   [3]             LDHX  @"\012\015*********************************\012\015"
  0149 ac0001b3 [8]             CALL  App_TransmitSensorData:435
 1303:  
 1304:  
 1305:  		GenandTransData(7, sens_data, (void*)mCoordInfo.coordAddress);
  014d a607     [2]             LDA   #7
  014f 87       [2]             PSHA  
  0150 95       [2]             TSX   
  0151 af03     [2]             AIX   #3
  0153 89       [2]             PSHX  
  0154 8b       [2]             PSHH  
  0155 450000   [3]             LDHX  @mCoordInfo
  0158 ac000000 [8]             CALL  GenandTransData
  015c a703     [2]             AIS   #3
 1306:  		sens_count=0;
  015e 4f       [1]             CLRA  
  015f c70000   [4]             STA   sens_count
 1307:  		for(i=0;i<7;i++){
  0162 95       [2]             TSX   
  0163 6f01     [5]             CLR   1,X
  0165          L165:   
 1308:  			sens_data[i]=0;
  0165 95       [2]             TSX   
  0166 af02     [2]             AIX   #2
  0168 9f       [1]             TXA   
  0169 9eeb02   [4]             ADD   2,SP
  016c 87       [2]             PSHA  
  016d 8b       [2]             PSHH  
  016e 86       [3]             PULA  
  016f a900     [2]             ADC   #0
  0171 87       [2]             PSHA  
  0172 8a       [3]             PULH  
  0173 88       [3]             PULX  
  0174 7f       [4]             CLR   ,X
  0175 95       [2]             TSX   
  0176 6c01     [5]             INC   1,X
  0178 e601     [3]             LDA   1,X
  017a a107     [2]             CMP   #7
  017c 25e7     [3]             BCS   L165 ;abs = 0165
  017e          L17E:   
 1309:  		}
 1310:  	}
 1311:  	
 1312:  }
  017e a70b     [2]             AIS   #11
  0180 8d       [7]             RTC   
  0181          L181:   
  0181 9efe0f   [5]             LDHX  15,SP
  0184 9f       [1]             TXA   
  0185 8b       [2]             PSHH  
  0186 95       [2]             TSX   
  0187 eb05     [3]             ADD   5,X
  0189 e705     [3]             STA   5,X
  018b 86       [3]             PULA  
  018c e904     [3]             ADC   4,X
  018e ee06     [3]             LDX   6,X
  0190 8c       [1]             CLRH  
  0191 af01     [2]             AIX   #1
  0193 9ee706   [4]             STA   6,SP
  0196 9ee605   [4]             LDA   5,SP
  0199 87       [2]             PSHA  
  019a 9ee607   [4]             LDA   7,SP
  019d 87       [2]             PSHA  
  019e cd0000   [6]             JSR   _IDIVS_STAR08
  01a1 a702     [2]             AIS   #2
  01a3 8d       [7]             RTC   
  01a4          L1A4:   
  01a4 89       [2]             PSHX  
  01a5 8b       [2]             PSHH  
  01a6 ce0000   [4]             LDX   sens_count
  01a9 8c       [1]             CLRH  
  01aa 9eef06   [4]             STX   6,SP
  01ad cd0000   [6]             JSR   _IMUL_STAR08
  01b0 a702     [2]             AIS   #2
  01b2 8d       [7]             RTC   
  01b3          L1B3:   
  01b3 a601     [2]             LDA   #1
  01b5 ac000000 [8]             CALL  UartUtil_Print
  01b9 8d       [7]             RTC   
 1313:  
 1314:  static void GenandTransData(uint8_t Length, uint8_t* pTxData, uint8_t* dest_addr){
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
 1315:   
 1316:  	/* Use multi buffering for increased TX performance. It does not really
 1317:       have any effect at a UART baud rate of 19200bps but serves as an
 1318:       example of how the throughput may be improved in a real-world 
 1319:       application where the data rate is of concern. */
 1320:    if( (mcPendingPackets < mDefaultValueOfMaxPendingDataPackets_c) && (mpPacket == NULL) ) 
  0002 c60000   [4]             LDA   mcPendingPackets
  0005 a102     [2]             CMP   #2
  0007 240e     [3]             BCC   L17 ;abs = 0017
  0009 320000   [5]             LDHX  mpPacket
  000c 2609     [3]             BNE   L17 ;abs = 0017
 1321:    {
 1322:      /* If the maximum number of pending data buffes is below maximum limit 
 1323:         and we do not have a data buffer already then allocate one. */
 1324:      mpPacket = MSG_Alloc(gMaxRxTxDataLength_c);
  000e a68d     [2]             LDA   #-115
  0010 ac000000 [8]             CALL  MM_Alloc
  0014 960000   [5]             STHX  mpPacket
  0017          L17:    
 1325:    }
 1326:    
 1327:    if(mpPacket != NULL)
  0017 320000   [5]             LDHX  mpPacket
  001a 277e     [3]             BEQ   L9A ;abs = 009a
 1328:    {
 1329:      /* get data from UART */        
 1330:        mpPacket->msgData.dataReq.pMsdu = (uint8_t*)(&(mpPacket->msgData.dataReq.pMsdu)) + sizeof(uint8_t*);
  001c af1c     [2]             AIX   #28
  001e 9f       [1]             TXA   
  001f 8b       [2]             PSHH  
  0020 320000   [5]             LDHX  mpPacket
  0023 e71b     [3]             STA   27,X
  0025 86       [3]             PULA  
  0026 e71a     [3]             STA   26,X
 1331:        FLib_MemCpy(mpPacket->msgData.dataReq.pMsdu, (uint8_t*) pTxData, Length);
  0028 9ece1a   [5]             LDHX  26,X
  002b 89       [2]             PSHX  
  002c 8b       [2]             PSHH  
  002d 9efe08   [5]             LDHX  8,SP
  0030 9ee60a   [4]             LDA   10,SP
  0033 ac000000 [8]             CALL  FLib_MemCpy
  0037 a702     [2]             AIS   #2
 1332:        /* Data was available in the UART receive buffer. Now create an
 1333:           MCPS-Data Request message containing the UART data. */
 1334:        mpPacket->msgType = gMcpsDataReq_c;
  0039 320000   [5]             LDHX  mpPacket
  003c 7f       [4]             CLR   ,X
 1335:        /* Create the header using coordinator information gained during 
 1336:           the scan procedure. Also use the short address we were assigned
 1337:           by the coordinator during association. */
 1338:        FLib_MemCpy(mpPacket->msgData.dataReq.dstAddr,dest_addr, 8);
  003d af01     [2]             AIX   #1
  003f 89       [2]             PSHX  
  0040 8b       [2]             PSHH  
  0041 9efe03   [5]             LDHX  3,SP
  0044 a608     [2]             LDA   #8
  0046 ac000000 [8]             CALL  FLib_MemCpy
  004a a702     [2]             AIS   #2
 1339:        FLib_MemCpy(mpPacket->msgData.dataReq.srcAddr, maMyAddress, 8);
  004c 320000   [5]             LDHX  mpPacket
  004f af0c     [2]             AIX   #12
  0051 89       [2]             PSHX  
  0052 8b       [2]             PSHH  
  0053 450000   [3]             LDHX  @maMyAddress
  0056 a608     [2]             LDA   #8
  0058 ac000000 [8]             CALL  FLib_MemCpy
  005c a702     [2]             AIS   #2
 1340:        FLib_MemCpy(mpPacket->msgData.dataReq.dstPanId, mCoordInfo.coordPanId, 2);
  005e 320000   [5]             LDHX  mpPacket
  0061 af09     [2]             AIX   #9
  0063 ac00009d [8]             CALL  GenandTransData:157
 1341:        FLib_MemCpy(mpPacket->msgData.dataReq.srcPanId, mCoordInfo.coordPanId, 2);
  0067 320000   [5]             LDHX  mpPacket
  006a af14     [2]             AIX   #20
  006c ac00009d [8]             CALL  GenandTransData:157
 1342:        mpPacket->msgData.dataReq.dstAddrMode = mCoordInfo.coordAddrMode;
  0070 c6000a   [4]             LDA   mCoordInfo:10
  0073 320000   [5]             LDHX  mpPacket
  0076 e70b     [3]             STA   11,X
 1343:        mpPacket->msgData.dataReq.srcAddrMode = mAddrMode;
  0078 c60000   [4]             LDA   mAddrMode
  007b e716     [3]             STA   22,X
 1344:        mpPacket->msgData.dataReq.msduLength = Length;
  007d 9ee608   [4]             LDA   8,SP
  0080 e717     [3]             STA   23,X
 1345:        /* Request MAC level acknowledgement of the data packet */
 1346:        mpPacket->msgData.dataReq.txOptions = 0;
  0082 6f19     [5]             CLR   25,X
 1347:        /* Give the data packet a handle. The handle is
 1348:           returned in the MCPS-Data Confirm message. */
 1349:        mpPacket->msgData.dataReq.msduHandle = mMsduHandle++;
  0084 c60000   [4]             LDA   mMsduHandle
  0087 e718     [3]             STA   24,X
  0089 4c       [1]             INCA  
  008a c70000   [4]             STA   mMsduHandle
 1350:  #ifdef gMAC2006_d
 1351:  	  mpPacket->msgData.dataReq.securityLevel = 0;
 1352:  #endif //gMAC2006_d	  
 1353:        
 1354:        /* Send the Data Request to the MCPS */
 1355:        (void)MSG_Send(NWK_MCPS, mpPacket);
  008d ac000000 [8]             CALL  NWK_MCPS_SapHandler
 1356:        /* Prepare for another data buffer */
 1357:        mpPacket = NULL;
  0091 5f       [1]             CLRX  
  0092 8c       [1]             CLRH  
  0093 960000   [5]             STHX  mpPacket
 1358:        mcPendingPackets++;
  0096 450000   [3]             LDHX  @mcPendingPackets
  0099 7c       [4]             INC   ,X
  009a          L9A:    
 1359:    }
 1360:     
 1361:  
 1362:  }
  009a a702     [2]             AIS   #2
  009c 8d       [7]             RTC   
  009d          L9D:    
  009d 89       [2]             PSHX  
  009e 8b       [2]             PSHH  
  009f 450008   [3]             LDHX  @mCoordInfo:8
  00a2 a602     [2]             LDA   #2
  00a4 ac000000 [8]             CALL  FLib_MemCpy
  00a8 a702     [2]             AIS   #2
  00aa 8d       [7]             RTC   
 1363:  
 1364:  /*****************************************************************************
 1365:  * Function to handle a generic key press. Called for all keys.
 1366:  *****************************************************************************/
 1367:  static void App_HandleGenericKey(void)
 1368:  {
 1369:    if(gState == stateInit)
  0000 c60000   [4]             LDA   gState
  0003 262a     [3]             BNE   L2F ;abs = 002f
 1370:    {
 1371:     StopLed1Flashing();
  0005 a601     [2]             LDA   #1
  0007 ac000000 [8]             CALL  LED_StopFlash
 1372:     StopLed2Flashing();
  000b a602     [2]             LDA   #2
  000d ac000000 [8]             CALL  LED_StopFlash
 1373:     StopLed3Flashing();
  0011 a604     [2]             LDA   #4
  0013 ac000000 [8]             CALL  LED_StopFlash
 1374:     StopLed4Flashing();
  0017 a608     [2]             LDA   #8
  0019 ac000000 [8]             CALL  LED_StopFlash
 1375:     Led1Off();
  001d 1000     [5]             BSET  0,0
 1376:     Led2Off();
  001f 1800     [5]             BSET  4,0
 1377:     Led3Off();
  0021 1006     [5]             BSET  0,6
 1378:     Led4Off();
  0023 1206     [5]             BSET  1,6
 1379:     LCD_ClearDisplay();
 1380:     LCD_WriteString(1,"Application");
 1381:     LCD_WriteString(2,"    started");     
 1382:     TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);       
  0025 c60000   [4]             LDA   gAppTaskID_c
  0028 ae01     [2]             LDX   #1
  002a 8c       [1]             CLRH  
  002b ac000000 [8]             CALL  TS_SendEvent
  002f          L2F:    
 1383:    }
 1384:  }
  002f 8d       [7]             RTC   
 1385:  
 1386:  /*****************************************************************************
 1387:  * Handles all key events for this device.
 1388:  * Interface assumptions: None
 1389:  * Return value: None
 1390:  *****************************************************************************/
 1391:  #if (gMC1323xMatrixKBD_d == TRUE)
 1392:  static void App_HandleKeys(uint8_t events, uint8_t pressedKey)   
 1393:  {
 1394:   (void)events;
 1395:   (void)pressedKey;
 1396:   App_HandleGenericKey();
  0000 ac000000 [8]             CALL  App_HandleGenericKey
 1397:  }
  0004 8d       [7]             RTC   
 1398:  #else
 1399:  static void App_HandleKeys(key_event_t events)
 1400:  {
 1401:    switch ( events ) 
 1402:      { 
 1403:        case gKBD_EventSW1_c:
 1404:        case gKBD_EventSW2_c:
 1405:        case gKBD_EventSW3_c:
 1406:        case gKBD_EventSW4_c:
 1407:        case gKBD_EventLongSW1_c:
 1408:        case gKBD_EventLongSW2_c:
 1409:        case gKBD_EventLongSW3_c:
 1410:        case gKBD_EventLongSW4_c:
 1411:         App_HandleGenericKey();
 1412:  	  break; 
 1413:      }    
 1414:  }
 1415:  #endif //gMC1323xMatrixKBD_d
 1416:  
 1417:  /*****************************************************************************
 1418:  * The DeepSleepWakeupStackProc(void) function is called each time the 
 1419:  * application exits the DeepSleep mode .
 1420:  * 
 1421:  * Return value:
 1422:  *     None
 1423:  *****************************************************************************/
 1424:  void DeepSleepWakeupStackProc(void){
 1425:    return;
 1426:  }
  0000 8d       [7]             RTC   
 1427:  
 1428:  /******************************************************************************
 1429:  * The following functions are called by the MAC to put messages into the
 1430:  * Application's queue. They need to be defined even if they are not used
 1431:  * in order to avoid linker errors.
 1432:  ******************************************************************************/
 1433:  
 1434:  uint8_t MLME_NWK_SapHandler(nwkMessage_t * pMsg)
 1435:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
 1436:    /* Put the incoming MLME message in the applications input queue. */
 1437:    MSG_Queue(&mMlmeNwkInputQueue, pMsg);
  0002 450000   [3]             LDHX  @mMlmeNwkInputQueue
  0005 89       [2]             PSHX  
  0006 8b       [2]             PSHH  
  0007 9efe03   [5]             LDHX  3,SP
  000a ac000000 [8]             CALL  List_AddTail
  000e a702     [2]             AIS   #2
 1438:    TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMLME_c);
  0010 c60000   [4]             LDA   gAppTaskID_c
  0013 ae04     [2]             LDX   #4
  0015 8c       [1]             CLRH  
  0016 ac000000 [8]             CALL  TS_SendEvent
 1439:    return gSuccess_c;
  001a 4f       [1]             CLRA  
 1440:  }
  001b a702     [2]             AIS   #2
  001d 8d       [7]             RTC   
 1441:  
 1442:  uint8_t MCPS_NWK_SapHandler(mcpsToNwkMessage_t *pMsg)
 1443:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
 1444:    /* Put the incoming MCPS message in the applications input queue. */
 1445:    MSG_Queue(&mMcpsNwkInputQueue, pMsg);
  0002 450000   [3]             LDHX  @mMcpsNwkInputQueue
  0005 89       [2]             PSHX  
  0006 8b       [2]             PSHH  
  0007 9efe03   [5]             LDHX  3,SP
  000a ac000000 [8]             CALL  List_AddTail
  000e a702     [2]             AIS   #2
 1446:    TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMCPS_c);
  0010 c60000   [4]             LDA   gAppTaskID_c
  0013 ae08     [2]             LDX   #8
  0015 8c       [1]             CLRH  
  0016 ac000000 [8]             CALL  TS_SendEvent
 1447:    return gSuccess_c;
  001a 4f       [1]             CLRA  
 1448:  }
  001b a702     [2]             AIS   #2
  001d 8d       [7]             RTC   
 1449:  
 1450:  uint8_t ASP_APP_SapHandler(aspToAppMsg_t *pMsg)
 1451:  {
 1452:    /* If the message is not handled anywhere it must be freed. */
 1453:    MSG_Free(pMsg);
  0000 ac000000 [8]             CALL  MM_Free
 1454:    return gSuccess_c;
  0004 4f       [1]             CLRA  
 1455:  }
  0005 8d       [7]             RTC   
 1456:  
 1457:  /******************************************************************************
 1458:  * The App_StartScan(scanType) function will start the scan process of the
 1459:  * specified type in the MAC. This is accomplished by allocating a MAC message,
 1460:  * which is then assigned the desired scan parameters and sent to the MLME
 1461:  * service access point. The MAC PIB attributes "macShortAddress", and 
 1462:  * "macAssociatePermit" are modified.
 1463:  *
 1464:  * The function may return either of the following values:
 1465:  *   errorNoError:          The Scan message was sent successfully.
 1466:  *   errorInvalidParameter: The MLME service access point rejected the
 1467:  *                          message due to an invalid parameter.
 1468:  *   errorAllocFailed:      A message buffer could not be allocated.
 1469:  *
 1470:  ******************************************************************************/
 1471:  static uint8_t App_StartRooter(void)
 1472:  {
  0000 a7fb     [2]             AIS   #-5
 1473:    /* Message for the MLME will be allocated and attached to this pointer */
 1474:    mlmeMessage_t *pMsg;
 1475:  
 1476:    UartUtil_Print("Sending the MLME-Start Request message to the MAC...", gAllowToBlock_d);
  0002 450000   [3]             LDHX  @"Sending the MLME-Start Request message to the MAC..."
  0005 ac0000af [8]             CALL  App_StartRooter:175
 1477:    
 1478:    /* Allocate a message for the MLME (We should check for NULL). */
 1479:    pMsg = MSG_AllocType(mlmeMessage_t);
  0009 a60f     [2]             LDA   #15
  000b ac000000 [8]             CALL  MM_Alloc
  000f 9eff01   [5]             STHX  1,SP
 1480:    if(pMsg != NULL)
  0012 2603     [3]             BNE   L17 ;abs = 0017
  0014 cc00a3   [4]             JMP   LA3 ;abs = 00a3
  0017          L17:    
 1481:    {
 1482:      /* Pointer which is used for easy access inside the allocated message */
 1483:      mlmeStartReq_t *pStartReq;
 1484:      /* Return value from MSG_send - used for avoiding compiler warnings */
 1485:      uint8_t ret;
 1486:      /* Boolean value that will be written to the MAC PIB */
 1487:      uint8_t boolFlag;
 1488:      
 1489:      /* Set-up MAC PIB attributes. Please note that Set, Get,
 1490:         and Reset messages are not freed by the MLME. */
 1491:      
 1492:      /* We must always set the short address to something
 1493:         else than 0xFFFF before starting a PAN. */
 1494:      pMsg->msgType = gMlmeSetReq_c;
  0017 a609     [2]             LDA   #9
  0019 f7       [2]             STA   ,X
 1495:      pMsg->msgData.setReq.pibAttribute = gMPibShortAddress_c;
  001a a653     [2]             LDA   #83
  001c e701     [3]             STA   1,X
 1496:      pMsg->msgData.setReq.pibAttributeValue = (uint8_t *)maShortAddress;
  001e a600     [2]             LDA   @maShortAddress:MSB
  0020 e702     [3]             STA   2,X
  0022 a600     [2]             LDA   @maShortAddress
  0024 e703     [3]             STA   3,X
 1497:      ret = MSG_Send(NWK_MLME, pMsg);
  0026 89       [2]             PSHX  
  0027 8b       [2]             PSHH  
  0028 ac000000 [8]             CALL  NWK_MLME_SapHandler
 1498:      
 1499:      /* We must set the Association Permit flag to TRUE 
 1500:         in order to allow devices to associate to us. */
 1501:      pMsg->msgType = gMlmeSetReq_c;
  002c 9efe01   [5]             LDHX  1,SP
  002f a609     [2]             LDA   #9
  0031 f7       [2]             STA   ,X
 1502:      pMsg->msgData.setReq.pibAttribute = gMPibAssociationPermit_c;
  0032 a641     [2]             LDA   #65
  0034 e701     [3]             STA   1,X
 1503:      boolFlag = TRUE;
  0036 a601     [2]             LDA   #1
  0038 95       [2]             TSX   
  0039 e704     [3]             STA   4,X
 1504:      pMsg->msgData.setReq.pibAttributeValue = &boolFlag;
  003b af04     [2]             AIX   #4
  003d 8b       [2]             PSHH  
  003e 9ee602   [4]             LDA   2,SP
  0041 87       [2]             PSHA  
  0042 8a       [3]             PULH  
  0043 9f       [1]             TXA   
  0044 9eee03   [4]             LDX   3,SP
  0047 e703     [3]             STA   3,X
  0049 86       [3]             PULA  
  004a e702     [3]             STA   2,X
 1505:      ret = MSG_Send(NWK_MLME, pMsg);
  004c ac000000 [8]             CALL  NWK_MLME_SapHandler
 1506:      
 1507:      /* This is a MLME-START.req command */
 1508:      pMsg->msgType = gMlmeStartReq_c;
  0050 9efe03   [5]             LDHX  3,SP
  0053 a60a     [2]             LDA   #10
  0055 f7       [2]             STA   ,X
 1509:      
 1510:      /* Create the Start request message data. */
 1511:      pStartReq = &pMsg->msgData.startReq;
  0056 af01     [2]             AIX   #1
  0058 9eff06   [5]             STHX  6,SP
 1512:      /* PAN ID - LSB, MSB. The example shows a PAN ID of 0xBEEF. */
 1513:      FLib_MemCpy(pStartReq->panId, (void *)maPanId, 2);
  005b 89       [2]             PSHX  
  005c 8b       [2]             PSHH  
  005d 450000   [3]             LDHX  @maPanId
  0060 a602     [2]             LDA   #2
  0062 ac000000 [8]             CALL  FLib_MemCpy
  0066 a702     [2]             AIS   #2
 1514:      /* Logical Channel - the default of 11 will be overridden */
 1515:      pStartReq->logicalChannel = mLogicalChannel;
  0068 9efe06   [5]             LDHX  6,SP
  006b c60000   [4]             LDA   mLogicalChannel
  006e e702     [3]             STA   2,X
 1516:      /* Beacon Order: 0xF = turn off beacons, less than 0xF = turn on beacons */
 1517:      pStartReq->beaconOrder = 0x0F;  
  0070 a60f     [2]             LDA   #15
  0072 e703     [3]             STA   3,X
 1518:      /* Superframe Order: Must be equal or less than the beacon order */
 1519:      pStartReq->superFrameOrder = mDefaultValueOfSuperframeOrder_c;
  0074 a606     [2]             LDA   #6
  0076 e704     [3]             STA   4,X
 1520:      /* Be a PAN coordinator */
 1521:      pStartReq->panCoordinator = TRUE;
  0078 a601     [2]             LDA   #1
  007a e705     [3]             STA   5,X
 1522:      /* Dont use battery life extension */
 1523:      pStartReq->batteryLifeExt = FALSE;
  007c 6f06     [5]             CLR   6,X
 1524:      /* This is not a Realignment command */
 1525:      pStartReq->coordRealignment = FALSE;
  007e 6f07     [5]             CLR   7,X
 1526:      /* Dont use security */
 1527:  #ifndef gMAC2006_d	
 1528:      pStartReq->securityEnable = FALSE;
  0080 6f08     [5]             CLR   8,X
 1529:  #else
 1530:  	pStartReq->coordRealignSecurityLevel = 0;
 1531:    pStartReq->beaconSecurityLevel = 0;	
 1532:  #endif //gMAC2006_d	
 1533:        
 1534:      /* Send the Start request to the MLME. */
 1535:      if(MSG_Send(NWK_MLME, pMsg) == gSuccess_c)
  0082 9efe03   [5]             LDHX  3,SP
  0085 ac000000 [8]             CALL  NWK_MLME_SapHandler
  0089 4d       [1]             TSTA  
  008a a702     [2]             AIS   #2
  008c 260a     [3]             BNE   L98 ;abs = 0098
 1536:      {
 1537:        UartUtil_Print("Done\n\r", gAllowToBlock_d);
  008e 450000   [3]             LDHX  @"Done\012\015"
  0091 ac0000af [8]             CALL  App_StartRooter:175
 1538:        return errorNoError;
  0095 4f       [1]             CLRA  
  0096 2014     [3]             BRA   LAC ;abs = 00ac
  0098          L98:    
 1539:      }
 1540:      else
 1541:      {
 1542:        /* One or more parameters in the Start Request message were invalid. */
 1543:        UartUtil_Print("Invalid parameter!\n\r", gAllowToBlock_d);
  0098 450000   [3]             LDHX  @"Invalid parameter!\012\015"
  009b ac0000af [8]             CALL  App_StartRooter:175
 1544:        return errorInvalidParameter;
  009f a605     [2]             LDA   #5
  00a1 2009     [3]             BRA   LAC ;abs = 00ac
  00a3          LA3:    
 1545:      }
 1546:    }
 1547:    else
 1548:    {
 1549:      /* Allocation of a message buffer failed. */
 1550:      UartUtil_Print("Message allocation failed!\n\r", gAllowToBlock_d);
  00a3 450000   [3]             LDHX  @"Message allocation failed!\012\015"
  00a6 ac0000af [8]             CALL  App_StartRooter:175
 1551:      return errorAllocFailed;
  00aa a604     [2]             LDA   #4
  00ac          LAC:    
 1552:    }
 1553:  }
  00ac a705     [2]             AIS   #5
  00ae 8d       [7]             RTC   
  00af          LAF:    
  00af a601     [2]             LDA   #1
  00b1 ac000000 [8]             CALL  UartUtil_Print
  00b5 8d       [7]             RTC   
 1554:  
 1555:  
 1556:  /******************************************************************************
 1557:  * The App_SendAssociateResponse(nwkMessage_t *pMsgIn) will create the response
 1558:  * message to an Associate Indication (device sends an Associate Request to its
 1559:  * MAC. The request is transmitted to the coordinator where it is converted into
 1560:  * an Associate Indication). This function will extract the devices long address,
 1561:  * and various other flags from the incoming indication message for building the
 1562:  * response message.
 1563:  *
 1564:  * The function may return either of the following values:
 1565:  *   errorNoError:          The Associate Response message was sent successfully.
 1566:  *   errorInvalidParameter: The MLME service access point rejected the
 1567:  *                          message due to an invalid parameter.
 1568:  *   errorAllocFailed:      A message buffer could not be allocated.
 1569:  *
 1570:  ******************************************************************************/
 1571:  static uint8_t App_SendAssociateResponse(nwkMessage_t *pMsgIn)
 1572:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  0002 a7fc     [2]             AIS   #-4
 1573:    mlmeMessage_t *pMsg;
 1574:    mlmeAssociateRes_t *pAssocRes;
 1575:    
 1576:    static uint8_t nwk_addr;
 1577:   
 1578:    UartUtil_Print("Sending the MLME-Associate Response message to the MAC...", gAllowToBlock_d);
  0004 450000   [3]             LDHX  @"Sending the MLME-Associate Response message to the MAC..."
  0007 ac0000ad [8]             CALL  App_SendAssociateResponse:173
 1579:   
 1580:    /* Allocate a message for the MLME */
 1581:    pMsg = MSG_AllocType(mlmeMessage_t);
  000b a60f     [2]             LDA   #15
  000d ac000000 [8]             CALL  MM_Alloc
  0011 9eff03   [5]             STHX  3,SP
 1582:    if(pMsg != NULL)
  0014 2603     [3]             BNE   L19 ;abs = 0019
  0016 cc00a1   [4]             JMP   LA1 ;abs = 00a1
  0019          L19:    
 1583:    {
 1584:      /* This is a MLME-ASSOCIATE.res command */
 1585:      pMsg->msgType = gMlmeAssociateRes_c;
  0019 a601     [2]             LDA   #1
  001b f7       [2]             STA   ,X
 1586:      
 1587:      /* Create the Associate response message data. */
 1588:      pAssocRes = &pMsg->msgData.associateRes;
  001c af01     [2]             AIX   #1
 1589:      
 1590:      /* Assign a short address to the device. In this example we simply
 1591:         choose 0x0001. Though, all devices and coordinators in a PAN must have
 1592:         different short addresses. However, if a device do not want to use 
 1593:         short addresses at all in the PAN, a short address of 0xFFFE must
 1594:         be assigned to it. */
 1595:      if(pMsgIn->msgData.associateInd.capabilityInfo & gCapInfoAllocAddr_c)
  001e 9eff01   [5]             STHX  1,SP
  0021 9efe05   [5]             LDHX  5,SP
  0024 e60b     [3]             LDA   11,X
  0026 2a15     [3]             BPL   L3D ;abs = 003d
 1596:      {
 1597:        /* Assign a unique short address less than 0xfffe if the device requests so. */
 1598:        pAssocRes->assocShortAddress[0] = nwk_addr;
  0028 c60000   [4]             LDA   nwk_addr
  002b 9efe01   [5]             LDHX  1,SP
  002e e708     [3]             STA   8,X
 1599:        pAssocRes->assocShortAddress[1] = 0x01;
  0030 a601     [2]             LDA   #1
  0032 e709     [3]             STA   9,X
 1600:        nwk_addr += 1;
  0034 450000   [3]             LDHX  @nwk_addr
  0037 7c       [4]             INC   ,X
 1601:      }
  0038 9efe01   [5]             LDHX  1,SP
  003b 200a     [3]             BRA   L47 ;abs = 0047
  003d          L3D:    
 1602:      else
 1603:      {
 1604:        /* A short address of 0xfffe means that the device is granted access to
 1605:           the PAN (Associate successful) but that long addressing is used.*/
 1606:        pAssocRes->assocShortAddress[0] = 0xFE;
  003d a6fe     [2]             LDA   #-2
  003f 9efe01   [5]             LDHX  1,SP
  0042 e708     [3]             STA   8,X
 1607:        pAssocRes->assocShortAddress[1] = 0xFF;
  0044 4c       [1]             INCA  
  0045 e709     [3]             STA   9,X
  0047          L47:    
 1608:      }
 1609:      /* Get the 64 bit address of the device requesting association. */
 1610:      FLib_MemCpy(pAssocRes->deviceAddress, pMsgIn->msgData.associateInd.deviceAddress, 8);
  0047 89       [2]             PSHX  
  0048 8b       [2]             PSHH  
  0049 9eff03   [5]             STHX  3,SP
  004c 9efe07   [5]             LDHX  7,SP
  004f af01     [2]             AIX   #1
  0051 a608     [2]             LDA   #8
  0053 ac000000 [8]             CALL  FLib_MemCpy
  0057 a702     [2]             AIS   #2
 1611:      /* Association granted. May also be gPanAtCapacity_c or gPanAccessDenied_c. */
 1612:      pAssocRes->status = gSuccess_c;
  0059 9efe01   [5]             LDHX  1,SP
  005c 6f0b     [5]             CLR   11,X
 1613:      /* Do not use security */
 1614:  #ifndef gMAC2006_d
 1615:      pAssocRes->securityEnable = FALSE;
  005e 6f0a     [5]             CLR   10,X
 1616:  #else
 1617:  	pAssocRes->securityLevel = 0;
 1618:  #endif //gMAC2006_d	
 1619:      
 1620:      /* Save device info. */
 1621:      FLib_MemCpy(maDeviceShortAddress, pAssocRes->assocShortAddress, 2);
  0060 450000   [3]             LDHX  @maDeviceShortAddress
  0063 89       [2]             PSHX  
  0064 8b       [2]             PSHH  
  0065 9efe03   [5]             LDHX  3,SP
  0068 af08     [2]             AIX   #8
  006a a602     [2]             LDA   #2
  006c ac000000 [8]             CALL  FLib_MemCpy
  0070 a702     [2]             AIS   #2
 1622:      FLib_MemCpy(maDeviceLongAddress,  pAssocRes->deviceAddress,     8);
  0072 450000   [3]             LDHX  @maDeviceLongAddress
  0075 89       [2]             PSHX  
  0076 8b       [2]             PSHH  
  0077 9efe03   [5]             LDHX  3,SP
  007a a608     [2]             LDA   #8
  007c ac000000 [8]             CALL  FLib_MemCpy
  0080 a702     [2]             AIS   #2
 1623:      
 1624:      /* Send the Associate Response to the MLME. */
 1625:      if(MSG_Send(NWK_MLME, pMsg) == gSuccess_c)
  0082 9efe03   [5]             LDHX  3,SP
  0085 ac000000 [8]             CALL  NWK_MLME_SapHandler
  0089 4d       [1]             TSTA  
  008a 260a     [3]             BNE   L96 ;abs = 0096
 1626:      {
 1627:        UartUtil_Print("Done\n\r", gAllowToBlock_d);
  008c 450000   [3]             LDHX  @"Done\012\015"
  008f ac0000ad [8]             CALL  App_SendAssociateResponse:173
 1628:        return errorNoError;
  0093 4f       [1]             CLRA  
  0094 2014     [3]             BRA   LAA ;abs = 00aa
  0096          L96:    
 1629:      }
 1630:      else
 1631:      {
 1632:        /* One or more parameters in the message were invalid. */
 1633:        UartUtil_Print("Invalid parameter!\n\r", gAllowToBlock_d);
  0096 450000   [3]             LDHX  @"Invalid parameter!\012\015"
  0099 ac0000ad [8]             CALL  App_SendAssociateResponse:173
 1634:        return errorInvalidParameter;
  009d a605     [2]             LDA   #5
  009f 2009     [3]             BRA   LAA ;abs = 00aa
  00a1          LA1:    
 1635:      }
 1636:    }
 1637:    else
 1638:    {
 1639:      /* Allocation of a message buffer failed. */
 1640:      UartUtil_Print("Message allocation failed!\n\r", gAllowToBlock_d);
  00a1 450000   [3]             LDHX  @"Message allocation failed!\012\015"
  00a4 ac0000ad [8]             CALL  App_SendAssociateResponse:173
 1641:      return errorAllocFailed;
  00a8 a604     [2]             LDA   #4
  00aa          LAA:    
 1642:    }
 1643:  }
  00aa a706     [2]             AIS   #6
  00ac 8d       [7]             RTC   
  00ad          LAD:    
  00ad a601     [2]             LDA   #1
  00af ac000000 [8]             CALL  UartUtil_Print
  00b3 8d       [7]             RTC   
 1644:  
 1645:  /******************************************************************************
 1646:  * The App_HandleScanEdConfirm(nwkMessage_t *pMsg) function will handle the
 1647:  * ED scan confirm message received from the MLME when the ED scan has completed.
 1648:  * The message contains the ED scan result list. This function will search the
 1649:  * list in order to select the logical channel with the least energy. The
 1650:  * selected channel is stored in the global variable called 'mLogicalChannel'.
 1651:  *
 1652:  ******************************************************************************/
 1653:  static void App_HandleScanEdConfirm(nwkMessage_t *pMsg)
 1654:  {  
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  0002 a7fb     [2]             AIS   #-5
 1655:    uint8_t n, minEnergy;
 1656:    uint8_t *pEdList;
 1657:    uint8_t ChannelMask;
 1658:    
 1659:    UartUtil_Print("Received the MLME-Scan Confirm message from the MAC\n\r", gAllowToBlock_d);
  0004 450000   [3]             LDHX  @"Received the MLME-Scan Confirm message from the MAC\012\015"
  0007 ac0000b0 [8]             CALL  App_HandleScanEdConfirm:176
 1660:      
 1661:    /* Get a pointer to the energy detect results */
 1662:    pEdList = pMsg->msgData.scanCnf.resList.pEnergyDetectList;
  000b 9efe06   [5]             LDHX  6,SP
  000e 9ece08   [5]             LDHX  8,X
  0011 9eff03   [5]             STHX  3,SP
 1663:    
 1664:    /* Set the minimum energy to a large value */
 1665:    minEnergy = 0xFF;
  0014 a6ff     [2]             LDA   #-1
  0016 95       [2]             TSX   
  0017 e704     [3]             STA   4,X
 1666:  
 1667:    /* Select default channel */
 1668:    mLogicalChannel = 11;
  0019 a60b     [2]             LDA   #11
  001b c70000   [4]             STA   mLogicalChannel
 1669:   
 1670:    /* Search for the channel with least energy */
 1671:    for(n=0; n<16; n++)
  001e 6f01     [5]             CLR   1,X
  0020          L20:    
 1672:    {
 1673:      ChannelMask = n + 11;
  0020 95       [2]             TSX   
  0021 e601     [3]             LDA   1,X
  0023 ab0b     [2]             ADD   #11
 1674:  	if((pEdList[n] < minEnergy)&&((uint8_t)((mDefaultValueOfChannel_c>>ChannelMask) & 0x1)))
  0025 f7       [2]             STA   ,X
  0026 e601     [3]             LDA   1,X
  0028 eb03     [3]             ADD   3,X
  002a 87       [2]             PSHA  
  002b 4f       [1]             CLRA  
  002c e902     [3]             ADC   2,X
  002e 87       [2]             PSHA  
  002f e604     [3]             LDA   4,X
  0031 8a       [3]             PULH  
  0032 88       [3]             PULX  
  0033 f1       [3]             CMP   ,X
  0034 232e     [3]             BLS   L64 ;abs = 0064
  0036 4f       [1]             CLRA  
  0037 450200   [3]             LDHX  #512
  003a 87       [2]             PSHA  
  003b 87       [2]             PSHA  
  003c 89       [2]             PSHX  
  003d 8b       [2]             PSHH  
  003e 95       [2]             TSX   
  003f e604     [3]             LDA   4,X
  0041 cd0000   [6]             JSR   _LLSR
  0044 9ee604   [4]             LDA   4,SP
  0047 a501     [2]             BIT   #1
  0049 a708     [2]             AIS   #8
  004b 2717     [3]             BEQ   L64 ;abs = 0064
 1675:      {
 1676:        minEnergy = pEdList[n];
  004d e605     [3]             LDA   5,X
  004f eb07     [3]             ADD   7,X
  0051 87       [2]             PSHA  
  0052 4f       [1]             CLRA  
  0053 e906     [3]             ADC   6,X
  0055 87       [2]             PSHA  
  0056 8a       [3]             PULH  
  0057 88       [3]             PULX  
  0058 fe       [3]             LDX   ,X
  0059 9eef05   [4]             STX   5,SP
 1677:        /* Channel numbering is 11 to 26 both inclusive */
 1678:        mLogicalChannel = n + 11; 
  005c 95       [2]             TSX   
  005d e601     [3]             LDA   1,X
  005f ab0b     [2]             ADD   #11
  0061 c70000   [4]             STA   mLogicalChannel
  0064          L64:    
  0064 95       [2]             TSX   
  0065 6c01     [5]             INC   1,X
  0067 e601     [3]             LDA   1,X
  0069 a110     [2]             CMP   #16
  006b 25b3     [3]             BCS   L20 ;abs = 0020
 1679:      }
 1680:    }
 1681:    
 1682:    /* Print out the result of the ED scan */
 1683:    UartUtil_Print("ED scan returned the following results:\n\r  [", gAllowToBlock_d);
  006d 450000   [3]             LDHX  @"ED scan returned the following results:\012\015  ["
  0070 ac0000b0 [8]             CALL  App_HandleScanEdConfirm:176
 1684:    UartUtil_PrintHex(pEdList, 16, gPrtHexBigEndian_c | gPrtHexSpaces_c);
  0074 9efe03   [5]             LDHX  3,SP
  0077 89       [2]             PSHX  
  0078 8b       [2]             PSHH  
  0079 ae10     [2]             LDX   #16
  007b a609     [2]             LDA   #9
  007d ac000000 [8]             CALL  UartUtil_PrintHex
  0081 a702     [2]             AIS   #2
 1685:    UartUtil_Print("]\n\r\n\r", gAllowToBlock_d);
  0083 450000   [3]             LDHX  @"]\012\015\012\015"
  0086 ac0000b0 [8]             CALL  App_HandleScanEdConfirm:176
 1686:    
 1687:    /* Print out the selected logical channel */
 1688:    UartUtil_Print("Based on the ED scan the logical channel 0x", gAllowToBlock_d);
  008a 450000   [3]             LDHX  @"Based on the ED scan the logical channel 0x"
  008d ac0000b0 [8]             CALL  App_HandleScanEdConfirm:176
 1689:    UartUtil_PrintHex(&mLogicalChannel, 1, 0);
  0091 450000   [3]             LDHX  @mLogicalChannel
  0094 89       [2]             PSHX  
  0095 8b       [2]             PSHH  
  0096 ae01     [2]             LDX   #1
  0098 4f       [1]             CLRA  
  0099 ac000000 [8]             CALL  UartUtil_PrintHex
  009d a702     [2]             AIS   #2
 1690:    UartUtil_Print(" was selected\n\r", gAllowToBlock_d);
  009f 450000   [3]             LDHX  @" was selected\012\015"
  00a2 ac0000b0 [8]             CALL  App_HandleScanEdConfirm:176
 1691:    
 1692:    /* The list of detected energies must be freed. */
 1693:    MSG_Free(pEdList);
  00a6 9efe03   [5]             LDHX  3,SP
  00a9 ac000000 [8]             CALL  MM_Free
 1694:  }
  00ad a707     [2]             AIS   #7
  00af 8d       [7]             RTC   
  00b0          LB0:    
  00b0 a601     [2]             LDA   #1
  00b2 ac000000 [8]             CALL  UartUtil_Print
  00b6 8d       [7]             RTC   
 1695:  
 1696:  /******************************************************************************/
 1697:  
 1698:  
 1699:  
