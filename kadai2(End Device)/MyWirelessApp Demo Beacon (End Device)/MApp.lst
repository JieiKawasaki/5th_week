*** EVALUATION ***
ANSI-C/cC++ Compiler for HC08 V-5.0.41 Build 12319, Nov 15 2012

    1:  /*****************************************************************************
    2:  * MyWirelessApp Demo Beacon End Device application.
    3:  *
    4:  * (c) Copyright 2008, Freescale, Inc. All rights reserved.
    5:  *
    6:  *
    7:  * No part of this document must be reproduced in any form - including copied,
    8:  * transcribed, printed or by any electronic means - without specific written
    9:  * permission from Freescale Semiconductor.
   10:  *
   11:  *****************************************************************************/
   12:  
   13:  #include "MApp.h"
   14:  #include "Sound.h"
   15:  #include "NVM_Interface.h"
   16:  #include "CMT_interface.h"
   17:  #include "IIC_Interface.h" // New
   18:  //#include "IoConfig.h"
   19:  
   20:  
   21:  /************************************************************************************
   22:  *************************************************************************************
   23:  * Private macros
   24:  *************************************************************************************
   25:  ************************************************************************************/
   26:  
   27:  /* If there are too many pending packets to be send over the air, */
   28:  /* receive mMaxKeysToReceive_c chars. */
   29:  /* The chars will be send over the air when there are no pending packets*/
   30:  #define mMaxKeysToReceive_c 32
   31:  
   32:  //----------Sensor switch--------
   33:  #define gMPL3115A2_enable 0
   34:  #define gMMA8652_enable   1
   35:  #define gMAG3110_enable   0
   36:  #define gFXAS21000_enable 0
   37:  #define gMMA9553_enable   0
   38:  //-------------------------------
   39:  
   40:  /************************************************************************************
   41:  *************************************************************************************
   42:  * Private prototypes
   43:  *************************************************************************************
   44:  ************************************************************************************/
   45:  
   46:  /* Forward declarations of helper functions */
   47:  static void    UartRxCallBack(void);
   48:  static uint8_t App_StartScan(uint8_t scanType);
   49:  static uint8_t App_HandleScanActiveConfirm(nwkMessage_t *pMsg);
   50:  static uint8_t App_WaitMsg(nwkMessage_t *pMsg, uint8_t msgType);
   51:  static uint8_t App_SendAssociateRequest(void);
   52:  static uint8_t App_HandleAssociateConfirm(nwkMessage_t *pMsg);
   53:  static void    App_HandleMcpsInput(mcpsToNwkMessage_t *pMsgIn);
   54:  static void    App_TransmitSensorData(void);
   55:  #if (gMC1323xMatrixKBD_d == TRUE)
   56:  static void    App_HandleKeys(uint8_t events, uint8_t pressedKey);
   57:  #else
   58:  static void    App_HandleKeys(key_event_t events);
   59:  #endif //gMC1323xMatrixKBD_d
   60:  
   61:  static uint8_t App_HandleMlmeInput(nwkMessage_t *pMsg);
   62:  static uint8_t App_SendSyncRequest(void);
   63:  static void GenandTransData(uint8_t Length, uint8_t* pTxData, uint8_t* dest_addr);
   64:  
   65:  static void count_timer  (uint8_t timerId);
   66:  
   67:  /* added by yusk */
   68:  static void Router_TransmitUartData(void);
   69:  static uint8_t Router_HandleMlmeInput(nwkMessage_t *pMsg);
   70:  static uint8_t Router_SendAssociateResponse(nwkMessage_t *pMsgIn);
   71:  
   72:  /* added by ueda */
   73:  static void Router_HandleMcpsInput(mcpsToNwkMessage_t *pMsgIn);
   74:  
   75:  /* added by j */
   76:  static uint8_t App_StartRooter(void);
   77:  static void App_HandleScanEdConfirm(nwkMessage_t *pMsg);
   78:  
   79:  volatile static uint8_t global_counter;
   80:  
   81:  static void count_timer(uint8_t timerId){
   82:  	uint8_t data[2];
   83:  	(void)timerId;  /* prevent compiler warning */
   84:  	global_counter++;
  0000 450000   [3]             LDHX  @global_counter
  0003 7c       [4]             INC   ,X
   85:  }
  0004 8d       [7]             RTC   
   86:  
   87:  /************************************************************************************
   88:  *************************************************************************************
   89:  * Private memory declarations
   90:  *************************************************************************************
   91:  ************************************************************************************/
   92:  
   93:  //Default Pan ID
   94:  static const uint8_t coordinaterPanId[2] = { (mDefaultValueOfPanId_c & 0xff), (mDefaultValueOfPanId_c >> 8)};
   95:  
   96:  /* The current logical channel (frequency band) */
   97:  static uint8_t mLogicalChannel;
   98:  
   99:  
  100:  /************************************************************************************
  101:  *************************************************************************************
  102:  * Private memory declarations
  103:  *************************************************************************************
  104:  ************************************************************************************/
  105:  
  106:  /* The short address and PAN ID of the coordinator*/
  107:  static const uint8_t maShortAddress[2] = { (mDefaultValueOfShortAddress_c & 0xff), (mDefaultValueOfShortAddress_c >> 8)};
  108:  static const uint8_t maPanId[2] = { (mDefaultValueOfPanId_c & 0xff), (mDefaultValueOfPanId_c >> 8)};
  109:  
  110:  /* The current logical channel (frequency band) */
  111:  static uint8_t mLogicalChannel;
  112:  
  113:  /* These byte arrays stores an associated
  114:     devices long and short addresses. */
  115:  static uint8_t maDeviceShortAddress[2];
  116:  static uint8_t maDeviceLongAddress[8];
  117:  
  118:  /* Data request packet for sending UART input to the coordinator */
  119:  static nwkToMcpsMessage_t *mpPacket;
  120:  
  121:  /* The MSDU handle is a unique data packet identifier */
  122:  static uint8_t mMsduHandle;
  123:  
  124:  /* Number of pending data packets */
  125:  static uint8_t mcPendingPackets;
  126:  
  127:  
  128:  /* Information about the PAN we are part of */
  129:  static panDescriptor_t mCoordInfo;
  130:  
  131:  /* This is either the short address assigned by the PAN coordinator
  132:     during association, or our own extended MAC address. */
  133:  static uint8_t maMyAddress[8];
  134:  
  135:  /* The devices address mode. If 2 (gAddrModeShort_c), then maMyAddress
  136:     contains the short address assigned by the PAN coordinator. If 3
  137:     (gAddrModeLong_c), then maMyAddress is equal to the extended address. */
  138:  static uint8_t mAddrMode;
  139:  
  140:  /* Data request packet for sending UART input to the coordinator */
  141:  static nwkToMcpsMessage_t *mpPacket;
  142:  
  143:  /* The MSDU handle is a unique data packet identifier */
  144:  static uint8_t mMsduHandle;
  145:  
  146:  /* Number of pending data packets */
  147:  static uint8_t mcPendingPackets;
  148:  
  149:  /* Application input queues */
  150:  static anchor_t mMlmeNwkInputQueue;
  151:  static anchor_t mMcpsNwkInputQueue;
  152:  
  153:  /************************************************************************************
  154:  *************************************************************************************
  155:  * Public memory declarations
  156:  *************************************************************************************
  157:  ************************************************************************************/
  158:  
  159:  /* The current state of the applications state machine */
  160:  uint8_t gState;
  161:  
  162:  uint8_t MPL3115A2_start_flag = 0;
  163:  uint8_t MMA8652_start_flag   = 0;
  164:  uint8_t MAG3110_start_flag   = 0;
  165:  uint8_t FXAS21000_start_flag = 0;
  166:  uint8_t MMA9553_start_flag   = 0;
  167:  
  168:  /* This data set contains application variables to be preserved across resets */
  169:  NvDataItemDescription_t const gaNvAppDataSet[] = {
  170:    {NULL, 0}       /* Required end-of-table marker. */
  171:  };
  172:  
  173:  STATIC tmrTimerID_t mTimerID = gTmrInvalidTimerID_c;
  174:  
  175:  /************************************************************************************
  176:  *************************************************************************************
  177:  * Public functions
  178:  *************************************************************************************
  179:  ************************************************************************************/
  180:  
  181:  void DeepSleepWakeupStackProc(void);
  182:  
  183:  /*****************************************************************************
  184:  * Initialization function for the App Task. This is called during
  185:  * initialization and should contain any application specific initialization
  186:  * (ie. hardware initialization/setup, table initialization, power up
  187:  * notificaiton.
  188:  *
  189:  * Interface assumptions: None
  190:  *
  191:  * Return value: None
  192:  *
  193:  *****************************************************************************/
  194:  void MApp_init(void)
  195:  { 
  196:    
  197:    /* The initial application state */
  198:    gState = stateInit;    
  0000 4f       [1]             CLRA  
  0001 c70000   [4]             STA   gState
  199:    /* Reset number of pending packets */
  200:    mcPendingPackets = 0;
  0004 c70000   [4]             STA   mcPendingPackets
  201:  
  202:    /* Initialize the MAC 802.15.4 extended address */
  203:    Init_MacExtendedAddress();
  0007 ac000000 [8]             CALL  Init_MacExtendedAddress
  204:    /* register keyboard callback function */
  205:    KBD_Init(App_HandleKeys);
  000b 450000   [3]             LDHX  @App_HandleKeys
  000e 89       [2]             PSHX  
  000f 8b       [2]             PSHH  
  0010 a600     [2]             LDA   @App_HandleKeys:PAGE
  0012 87       [2]             PSHA  
  0013 ac000000 [8]             CALL  KBD_Init
  0017 a703     [2]             AIS   #3
  206:    /* Initialize SPI Module */
  207:    SPI_Init();
  0019 ac000000 [8]             CALL  SPI1_Init
  208:    /* initialize LCD Module */
  209:    LCD_Init();
  210:    /* initialize LED Module */
  211:    LED_Init();
  001d ac000000 [8]             CALL  LED_Init
  212:    /* Initialize the LPM module */
  213:    PWRLib_Init();
  0021 ac000000 [8]             CALL  PWRLib_Init
  214:    /* Initialize the UART so that we can print out status messages */
  215:    UartX_SetBaud(gUartDefaultBaud_c);
  0025 ae34     [2]             LDX   #52
  0027 8c       [1]             CLRH  
  0028 ac000000 [8]             CALL  Uart1_SetBaud
  216:    UartX_SetRxCallBack(UartRxCallBack);
  002c 450000   [3]             LDHX  @UartRxCallBack
  002f 89       [2]             PSHX  
  0030 8b       [2]             PSHH  
  0031 a600     [2]             LDA   @UartRxCallBack:PAGE
  0033 87       [2]             PSHA  
  0034 ac000000 [8]             CALL  Uart1_SetRxCallBack
  0038 a703     [2]             AIS   #3
  217:    
  218:    /* Initialize the IIC module */
  219:    IIC_Bus_Reset();  // Reset IIC bus to prevent freezing sensor module using GPIO 
  003a ac000000 [8]             CALL  IIC_Bus_Reset
  220:    IIC_ModuleInit(); // New      
  003e ac000000 [8]             CALL  IIC_ModuleInit
  221:        
  222:  #if gMPL3115A2_enable
  223:    MPL3115A2_Init();
  224:  #endif
  225:    
  226:  #if gMMA8652_enable
  227:    MMA8652_Init();
  0042 ac000000 [8]             CALL  MMA8652_Init
  228:  #endif   
  229:  
  230:  #if gMAG3110_enable
  231:    MAG3110_Init();
  232:  #endif 
  233:    
  234:  #if gFXAS21000_enable
  235:    FXAS21000_Init();
  236:  #endif 
  237:   
  238:  #if gMMA9553_enable
  239:    MMA9553_Init();
  240:  #endif   
  241:    
  242:    /* initialize buzzer (NCB, SRB only) */  
  243:    BuzzerInit();  
  244:    /* Prepare input queues.*/
  245:    MSG_InitQueue(&mMlmeNwkInputQueue); 
  0046 450000   [3]             LDHX  @mMlmeNwkInputQueue
  0049 ac000000 [8]             CALL  List_ClearAnchor
  246:    MSG_InitQueue(&mMcpsNwkInputQueue);  
  004d 450000   [3]             LDHX  @mMcpsNwkInputQueue
  0050 ac000000 [8]             CALL  List_ClearAnchor
  247:    /* Enable MCU interrupts */
  248:    IrqControlLib_EnableAllIrqs();
  0054 9a       [1]             CLI   
  249:    /*signal app ready*/  
  250:    Led1Flashing();
  0055 a601     [2]             LDA   #1
  0057 ac000000 [8]             CALL  LED_StartFlash
  251:    Led2Flashing();
  005b a602     [2]             LDA   #2
  005d ac000000 [8]             CALL  LED_StartFlash
  252:    Led3Flashing();
  0061 a604     [2]             LDA   #4
  0063 ac000000 [8]             CALL  LED_StartFlash
  253:    Led4Flashing();
  0067 a608     [2]             LDA   #8
  0069 ac000000 [8]             CALL  LED_StartFlash
  254:  
  255:    UartUtil_Print("\n\rPress any switch on board to start running the application.\n\r", gAllowToBlock_d);  
  006d 450000   [3]             LDHX  @"\012\015Press any switch on board to start running the application.\012\015"
  0070 a601     [2]             LDA   #1
  0072 ac000000 [8]             CALL  UartUtil_Print
  256:    
  257:    LCD_WriteString(1,"Press any key");
  258:    LCD_WriteString(2,"to start.");
  259:    
  260:    mTimerID = TMR_AllocateTimer();
  0076 ac000000 [8]             CALL  TMR_AllocateTimer
  007a c70000   [4]             STA   mTimerID
  261:    TMR_StartIntervalTimer(mTimerID, 1000, count_timer);
  007d 87       [2]             PSHA  
  007e 4503e8   [3]             LDHX  #1000
  0081 89       [2]             PSHX  
  0082 8b       [2]             PSHH  
  0083 4f       [1]             CLRA  
  0084 87       [2]             PSHA  
  0085 87       [2]             PSHA  
  0086 450000   [3]             LDHX  @count_timer
  0089 89       [2]             PSHX  
  008a 8b       [2]             PSHH  
  008b a600     [2]             LDA   @count_timer:PAGE
  008d 87       [2]             PSHA  
  008e ac000000 [8]             CALL  TMR_StartIntervalTimer
  0092 a708     [2]             AIS   #8
  262:    
  263:  }
  0094 8d       [7]             RTC   
  264:  
  265:  /*****************************************************************************
  266:  *Mac Application Task event processor.  This function is called to
  267:  * process all events for the task. Events include timers, messages and any
  268:  * other user defined events
  269:  *
  270:  * Interface assumptions: None
  271:  *
  272:  * Return value: None
  273:  *****************************************************************************/
  274:  void AppTask(event_t events) 
  275:  { 
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  0002 a7fe     [2]             AIS   #-2
  276:  
  277:    /* Pointer for storing the messages from MLME, MCPS, and ASP. */
  278:    void *pMsgIn;
  279:    /* Stores the status code returned by some functions. */
  280:    uint8_t rc;
  281:    pMsgIn = NULL;
  0004 9e6f02   [6]             CLR   2,SP
  0007 9e6f01   [6]             CLR   1,SP
  282:    
  283:    /* Dequeue the MLME message */
  284:    if (events & gAppEvtMessageFromMLME_c)
  000a 9f       [1]             TXA   
  000b a504     [2]             BIT   #4
  000d 2726     [3]             BEQ   L35 ;abs = 0035
  285:    {
  286:      /* Get the message from MLME */
  287:      pMsgIn = MSG_DeQueue(&mMlmeNwkInputQueue);
  000f 450000   [3]             LDHX  @mMlmeNwkInputQueue
  0012 ac000000 [8]             CALL  List_RemoveHead
  0016 9eff01   [5]             STHX  1,SP
  288:      
  289:      /* Any time a beacon might arrive. Always handle the beacon frame first */
  290:      if (pMsgIn)
  0019 271a     [3]             BEQ   L35 ;abs = 0035
  291:      {               
  292:        rc = App_WaitMsg(pMsgIn, gNwkBeaconNotifyInd_c);
  001b a604     [2]             LDA   #4
  001d ac000000 [8]             CALL  App_WaitMsg
  293:        if(rc == errorNoError)
  0021 4d       [1]             TSTA  
  0022 2611     [3]             BNE   L35 ;abs = 0035
  294:        {
  295:          /* ALWAYS free the beacon frame contained in the beacon notify indication.*/
  296:          /* ALSO the application can use the beacon payload.*/
  297:          MSG_Free(((nwkMessage_t *)pMsgIn)->msgData.beaconNotifyInd.pBufferRoot);
  0024 9efe01   [5]             LDHX  1,SP
  0027 9ece0a   [5]             LDHX  10,X
  002a ac000000 [8]             CALL  MM_Free
  298:          UartUtil_Print("Received an MLME-Beacon Notify Indication\n\r", gAllowToBlock_d);
  002e 450000   [3]             LDHX  @"Received an MLME-Beacon Notify Indication\012\015"
  0031 ac00032d [8]             CALL  AppTask:813
  0035          L35:    
  299:        }
  300:      }
  301:    }
  302:    /* The application state machine */
  303:    switch(gState)
  0035 c60000   [4]             LDA   gState
  0038 a10b     [2]             CMP   #11
  003a 2249     [3]             BHI   L85 ;abs = 0085
  003c 4d       [1]             TSTA  
  003d 2749     [3]             BEQ   L88 ;abs = 0088
  003f 410152   [4]             CBEQA #1,L94 ;abs = 0094
  0042 a102     [2]             CMP   #2
  0044 2763     [3]             BEQ   LA9 ;abs = 00a9
  0046 a103     [2]             CMP   #3
  0048 2603     [3]             BNE   L4D ;abs = 004d
  004a cc0142   [4]             JMP   L142 ;abs = 0142
  004d          L4D:    
  004d a104     [2]             CMP   #4
  004f 2603     [3]             BNE   L54 ;abs = 0054
  0051 cc0164   [4]             JMP   L164 ;abs = 0164
  0054          L54:    
  0054 a105     [2]             CMP   #5
  0056 2603     [3]             BNE   L5B ;abs = 005b
  0058 cc01e2   [4]             JMP   L1E2 ;abs = 01e2
  005b          L5B:    
  005b a106     [2]             CMP   #6
  005d 2603     [3]             BNE   L62 ;abs = 0062
  005f cc020c   [4]             JMP   L20C ;abs = 020c
  0062          L62:    
  0062 a107     [2]             CMP   #7
  0064 2603     [3]             BNE   L69 ;abs = 0069
  0066 cc0218   [4]             JMP   L218 ;abs = 0218
  0069          L69:    
  0069 a108     [2]             CMP   #8
  006b 2603     [3]             BNE   L70 ;abs = 0070
  006d cc022b   [4]             JMP   L22B ;abs = 022b
  0070          L70:    
  0070 a109     [2]             CMP   #9
  0072 2603     [3]             BNE   L77 ;abs = 0077
  0074 cc0253   [4]             JMP   L253 ;abs = 0253
  0077          L77:    
  0077 a10a     [2]             CMP   #10
  0079 2603     [3]             BNE   L7E ;abs = 007e
  007b cc027d   [4]             JMP   L27D ;abs = 027d
  007e          L7E:    
  007e a10b     [2]             CMP   #11
  0080 2603     [3]             BNE   L85 ;abs = 0085
  0082 cc02c6   [4]             JMP   L2C6 ;abs = 02c6
  0085          L85:    
  0085 cc013f   [4]             JMP   L13F ;abs = 013f
  0088          L88:    
  304:    {
  305:    case stateInit:    
  306:      /* Print a welcome message to the UART */
  307:      UartUtil_Print("\n\rMyWirelessApp Demo Beacon End Device application is initialized and ready.\n\r\n\r", gAllowToBlock_d);            
  0088 450000   [3]             LDHX  @"\012\015MyWirelessApp Demo Beacon End Device application is initialized and ready.\012\015\012\015"
  008b ac00032d [8]             CALL  AppTask:813
  308:      /* Goto Active Scan state. */
  309:      gState = stateScanActiveStart;
  008f a601     [2]             LDA   #1
  310:      //gState = stateListen;
  311:      TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);
  312:      break;
  0091 cc01c3   [4]             JMP   L1C3 ;abs = 01c3
  0094          L94:    
  313:      
  314:    case stateScanActiveStart:
  315:      /* Start the Active scan, and goto wait for confirm state. */
  316:      UartUtil_Print("Start scanning for a PAN coordinator\n\r", gAllowToBlock_d);
  0094 450000   [3]             LDHX  @"Start scanning for a PAN coordinator\012\015"
  0097 ac00032d [8]             CALL  AppTask:813
  317:      /*print a message on the LCD also*/
  318:      LCD_ClearDisplay();
  319:      LCD_WriteString(1,"Start scanning");
  320:      LCD_WriteString(2,"for coordinator");
  321:      rc = App_StartScan(gScanModeActive_c);
  009b a601     [2]             LDA   #1
  009d ac000000 [8]             CALL  App_StartScan
  322:      if(rc == errorNoError)
  00a1 4d       [1]             TSTA  
  00a2 261e     [3]             BNE   LC2 ;abs = 00c2
  323:      {
  324:        gState = stateScanActiveWaitConfirm;
  00a4 a602     [2]             LDA   #2
  00a6 cc0161   [4]             JMP   L161 ;abs = 0161
  00a9          LA9:    
  325:      }
  326:      break;
  327:      
  328:    case stateScanActiveWaitConfirm:
  329:      /* Stay in this state until the Scan confirm message
  330:         arrives, and then goto the associate state. */
  331:      if (events & gAppEvtMessageFromMLME_c)
  00a9 95       [2]             TSX   
  00aa e603     [3]             LDA   3,X
  00ac a504     [2]             BIT   #4
  00ae 2603     [3]             BNE   LB3 ;abs = 00b3
  00b0 cc013f   [4]             JMP   L13F ;abs = 013f
  00b3          LB3:    
  332:      {
  333:        if (pMsgIn)
  00b3 9efe01   [5]             LDHX  1,SP
  00b6 2603     [3]             BNE   LBB ;abs = 00bb
  00b8 cc013f   [4]             JMP   L13F ;abs = 013f
  00bb          LBB:    
  334:        {                            
  335:          rc = App_WaitMsg(pMsgIn, gNwkScanCnf_c);
  00bb a60b     [2]             LDA   #11
  00bd ac000000 [8]             CALL  App_WaitMsg
  336:          if(rc == errorNoError)
  00c1 4d       [1]             TSTA  
  00c2          LC2:    
  00c2 267b     [3]             BNE   L13F ;abs = 013f
  337:          {
  338:            rc = App_HandleScanActiveConfirm(pMsgIn);
  00c4 9efe01   [5]             LDHX  1,SP
  00c7 ac000000 [8]             CALL  App_HandleScanActiveConfirm
  339:            if(rc == errorNoError)
  00cb 4d       [1]             TSTA  
  00cc 266a     [3]             BNE   L138 ;abs = 0138
  340:            {
  341:              UartUtil_Print("Found a coordinator with the following properties:\n\r", gAllowToBlock_d);
  00ce 450000   [3]             LDHX  @"Found a coordinator with the following properties:\012\015"
  00d1 ac00032d [8]             CALL  AppTask:813
  342:              UartUtil_Print("----------------------------------------------------", gAllowToBlock_d);
  00d5 450000   [3]             LDHX  @"----------------------------------------------------"
  00d8 ac00032d [8]             CALL  AppTask:813
  343:              UartUtil_Print("\n\rAddress............0x", gAllowToBlock_d); UartUtil_PrintHex(mCoordInfo.coordAddress, 
  00dc 450000   [3]             LDHX  @"\012\015Address............0x"
  00df ac00032d [8]             CALL  AppTask:813
  00e3 450000   [3]             LDHX  @mCoordInfo
  00e6 89       [2]             PSHX  
  00e7 8b       [2]             PSHH  
  00e8 c6000a   [4]             LDA   mCoordInfo:10
  00eb 410203   [4]             CBEQA #2,LF1 ;abs = 00f1
  344:                                                                   mCoordInfo.coordAddrMode == gAddrModeShort_c ? 2 : 8, 0);
  00ee ae08     [2]             LDX   #8
  00f0 65       [3]             SKIP2 LF3 ;abs = 00f3
  00f1          LF1:    
  00f1 ae02     [2]             LDX   #2
  00f3          LF3:    
  00f3 4f       [1]             CLRA  
  00f4 ac000000 [8]             CALL  UartUtil_PrintHex
  00f8 a702     [2]             AIS   #2
  345:              UartUtil_Print("\n\rPAN ID.............0x", gAllowToBlock_d); UartUtil_PrintHex(mCoordInfo.coordPanId, 2, 0);
  00fa 450000   [3]             LDHX  @"\012\015PAN ID.............0x"
  00fd ac00032d [8]             CALL  AppTask:813
  0101 450008   [3]             LDHX  @mCoordInfo:8
  0104 ac000334 [8]             CALL  AppTask:820
  346:              UartUtil_Print("\n\rLogical Channel....0x", gAllowToBlock_d); UartUtil_PrintHex(&mCoordInfo.logicalChannel, 1, 0);
  0108 450000   [3]             LDHX  @"\012\015Logical Channel....0x"
  010b ac00032d [8]             CALL  AppTask:813
  010f 45000b   [3]             LDHX  @mCoordInfo:11
  0112 ac000340 [8]             CALL  AppTask:832
  347:              UartUtil_Print("\n\rBeacon Spec........0x", gAllowToBlock_d); UartUtil_PrintHex(mCoordInfo.superFrameSpec, 2, 0);
  0116 450000   [3]             LDHX  @"\012\015Beacon Spec........0x"
  0119 ac00032d [8]             CALL  AppTask:813
  011d 45000f   [3]             LDHX  @mCoordInfo:15
  0120 ac000334 [8]             CALL  AppTask:820
  348:              UartUtil_Print("\n\rLink Quality.......0x", gAllowToBlock_d); UartUtil_PrintHex(&mCoordInfo.linkQuality, 1, 0);
  0124 450000   [3]             LDHX  @"\012\015Link Quality.......0x"
  0127 ac00032d [8]             CALL  AppTask:813
  012b 450012   [3]             LDHX  @mCoordInfo:18
  012e ac000340 [8]             CALL  AppTask:832
  349:              UartUtil_Print("\n\r\n\r", gAllowToBlock_d);
  0132 450000   [3]             LDHX  @"\012\015\012\015"
  350:  
  351:              /* Go to the Associate state */
  352:              gState = stateAssociate;
  353:              TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);
  354:            }
  0135 cc01da   [4]             JMP   L1DA ;abs = 01da
  0138          L138:   
  355:            else
  356:            {
  357:              UartUtil_Print("Scan did not find a suitable coordinator\n\r", gAllowToBlock_d);
  0138 450000   [3]             LDHX  @"Scan did not find a suitable coordinator\012\015"
  013b ac00032d [8]             CALL  AppTask:813
  013f          L13F:   
  013f cc020a   [4]             JMP   L20A ;abs = 020a
  0142          L142:   
  358:              /*print a message on the LCD also*/
  359:              LCD_ClearDisplay();
  360:              LCD_WriteString(1,"No coordinator");
  361:              LCD_WriteString(2,"found");
  362:            }            
  363:          }
  364:        }
  365:      }
  366:      break;
  367:  
  368:    case stateAssociate:
  369:      /* Associate to the PAN coordinator */
  370:      UartUtil_Print("Associating to PAN coordinator on channel 0x", gAllowToBlock_d);
  0142 450000   [3]             LDHX  @"Associating to PAN coordinator on channel 0x"
  0145 ac00032d [8]             CALL  AppTask:813
  371:      UartUtil_PrintHex(&(mCoordInfo.logicalChannel), 1, gPrtHexNewLine_c);
  0149 45000b   [3]             LDHX  @mCoordInfo:11
  014c 89       [2]             PSHX  
  014d 8b       [2]             PSHH  
  014e ae01     [2]             LDX   #1
  0150 a602     [2]             LDA   #2
  0152 ac000000 [8]             CALL  UartUtil_PrintHex
  0156 a702     [2]             AIS   #2
  372:      /*print a message on the LCD also*/
  373:      LCD_ClearDisplay();
  374:      LCD_WriteString(1,"Associating to ");
  375:      LCD_WriteString(2,"PAN coordinator");
  376:  
  377:      rc = App_SendAssociateRequest();
  0158 ac000000 [8]             CALL  App_SendAssociateRequest
  378:      if(rc == errorNoError)
  015c 4d       [1]             TSTA  
  015d 266b     [3]             BNE   L1CA ;abs = 01ca
  379:        gState = stateAssociateWaitConfirm;
  015f a604     [2]             LDA   #4
  0161          L161:   
  0161 cc0229   [4]             JMP   L229 ;abs = 0229
  0164          L164:   
  380:      break; 
  381:  
  382:    case stateAssociateWaitConfirm:
  383:      /* Stay in this state until the Associate confirm message
  384:         arrives, and then goto the Listen state. */
  385:      if (events & gAppEvtMessageFromMLME_c)
  0164 95       [2]             TSX   
  0165 e603     [3]             LDA   3,X
  0167 a504     [2]             BIT   #4
  0169 2603     [3]             BNE   L16E ;abs = 016e
  016b cc0204   [4]             JMP   L204 ;abs = 0204
  016e          L16E:   
  386:      {
  387:        if (pMsgIn)
  016e 9efe01   [5]             LDHX  1,SP
  0171 2603     [3]             BNE   L176 ;abs = 0176
  0173 cc0204   [4]             JMP   L204 ;abs = 0204
  0176          L176:   
  388:        {   
  389:          rc = App_WaitMsg(pMsgIn, gNwkAssociateCnf_c);    
  0176 a601     [2]             LDA   #1
  0178 ac000000 [8]             CALL  App_WaitMsg
  390:          if(rc == errorNoError)
  017c 4d       [1]             TSTA  
  017d 264b     [3]             BNE   L1CA ;abs = 01ca
  391:          {
  392:            rc = App_HandleAssociateConfirm(pMsgIn);
  017f 9efe01   [5]             LDHX  1,SP
  0182 ac000000 [8]             CALL  App_HandleAssociateConfirm
  393:            if (rc == errorNoError)
  0186 4d       [1]             TSTA  
  0187 264e     [3]             BNE   L1D7 ;abs = 01d7
  394:            {
  395:                UartUtil_Print("Successfully associated with the coordinator.\n\r", gAllowToBlock_d);
  0189 450000   [3]             LDHX  @"Successfully associated with the coordinator.\012\015"
  018c ac00032d [8]             CALL  AppTask:813
  396:                UartUtil_Print("We were assigned the short address 0x", gAllowToBlock_d);
  0190 450000   [3]             LDHX  @"We were assigned the short address 0x"
  0193 ac00032d [8]             CALL  AppTask:813
  397:                UartUtil_PrintHex(maMyAddress, mAddrMode == gAddrModeShort_c ? 2 : 8, 0);
  0197 450000   [3]             LDHX  @maMyAddress
  019a 89       [2]             PSHX  
  019b 8b       [2]             PSHH  
  019c c60000   [4]             LDA   mAddrMode
  019f 410203   [4]             CBEQA #2,L1A5 ;abs = 01a5
  01a2 ae08     [2]             LDX   #8
  01a4 65       [3]             SKIP2 L1A7 ;abs = 01a7
  01a5          L1A5:   
  01a5 ae02     [2]             LDX   #2
  01a7          L1A7:   
  01a7 4f       [1]             CLRA  
  01a8 ac000000 [8]             CALL  UartUtil_PrintHex
  01ac a702     [2]             AIS   #2
  398:                UartUtil_Print("\n\r\n\rReady to send and receive data over the UART.\n\r\n\r", gAllowToBlock_d);
  01ae 450000   [3]             LDHX  @"\012\015\012\015Ready to send and receive data over the UART.\012\015\012\015"
  01b1 ac00032d [8]             CALL  AppTask:813
  399:                /*print a message on the LCD also*/
  400:                LCD_ClearDisplay();
  401:                LCD_WriteString(1,"Ready to send");
  402:                LCD_WriteString(2,"and receive data");      
  403:                
  404:  //********************************************************
  405:                if (maMyAddress[0]==0x01){
  01b5 c60000   [4]             LDA   maMyAddress
  01b8 4b0b     [4]             DBNZA L1C5 ;abs = 01c5
  406:              	  UartUtil_Print("\n\rSwitch Role to Rooter\n\r", gAllowToBlock_d);
  01ba 450000   [3]             LDHX  @"\012\015Switch Role to Rooter\012\015"
  01bd ac00032d [8]             CALL  AppTask:813
  407:              	  gState = stateInitRooter;
  01c1 a606     [2]             LDA   #6
  01c3          L1C3:   
  408:              	  TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);
  409:                }else if(maMyAddress[0]==0x02){
  01c3 2050     [3]             BRA   L215 ;abs = 0215
  01c5          L1C5:   
  01c5 c60000   [4]             LDA   maMyAddress
  01c8 a102     [2]             CMP   #2
  01ca          L1CA:   
  01ca 263e     [3]             BNE   L20A ;abs = 020a
  410:              	  UartUtil_Print("\n\rSwitch Role to End-Device\n\r", gAllowToBlock_d);
  01cc 450000   [3]             LDHX  @"\012\015Switch Role to End-Device\012\015"
  01cf ac00032d [8]             CALL  AppTask:813
  411:              	  gState = stateListen;
  01d3 a605     [2]             LDA   #5
  01d5 203e     [3]             BRA   L215 ;abs = 0215
  01d7          L1D7:   
  412:              	  TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);
  413:                }
  414:  //********************************************************
  415:            } 
  416:            else 
  417:            {
  418:            
  419:          	  UartUtil_Print("\n\rAssociate Confirm wasn't successful... \n\r\n\r", gAllowToBlock_d);
  01d7 450000   [3]             LDHX  @"\012\015Associate Confirm wasn't successful... \012\015\012\015"
  01da          L1DA:   
  01da ac00032d [8]             CALL  AppTask:813
  420:          	  gState = stateAssociate;
  01de a603     [2]             LDA   #3
  01e0 2033     [3]             BRA   L215 ;abs = 0215
  01e2          L1E2:   
  421:          	  TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);
  422:            }
  423:          }
  424:        }
  425:      }
  426:      break; 
  427:          
  428:    case stateListen:
  429:      /* Transmit to coordinator data received from UART. */
  430:      if (events & gAppEvtMessageFromMLME_c)
  01e2 95       [2]             TSX   
  01e3 e603     [3]             LDA   3,X
  01e5 a504     [2]             BIT   #4
  01e7 2709     [3]             BEQ   L1F2 ;abs = 01f2
  431:      {  
  432:        if (pMsgIn)
  01e9 9efe01   [5]             LDHX  1,SP
  01ec 2704     [3]             BEQ   L1F2 ;abs = 01f2
  433:        {  
  434:          /* Process it */
  435:          rc = App_HandleMlmeInput(pMsgIn);
  01ee ac000000 [8]             CALL  App_HandleMlmeInput
  01f2          L1F2:   
  436:        }
  437:      } 
  438:      
  439:  
  440:  #if gMPL3115A2_enable    
  441:      MPL3115A2_dump(events);
  442:  #endif
  443:    
  444:  #if gMMA8652_enable    
  445:  	// Start to receive periodical data 
  446:  	if(MMA8652_start_flag){
  01f2 c60000   [4]             LDA   MMA8652_start_flag
  01f5 2708     [3]             BEQ   L1FF ;abs = 01ff
  447:  		MMA8652_start_flag = 0;
  01f7 4f       [1]             CLRA  
  01f8 c70000   [4]             STA   MMA8652_start_flag
  448:  		MMA8652_Start_Periodical_data();
  01fb ac000000 [8]             CALL  MMA8652_Start_Periodical_data
  01ff          L1FF:   
  449:  	}
  450:  	
  451:  	if (events & gAppEvt_FromMMA8652_c){
  01ff 95       [2]             TSX   
  0200 e602     [3]             LDA   2,X
  0202 a502     [2]             BIT   #2
  0204          L204:   
  0204 2775     [3]             BEQ   L27B ;abs = 027b
  452:  		/* get byte from UART */
  453:  		App_TransmitSensorData();
  0206 ac000000 [8]             CALL  App_TransmitSensorData
  020a          L20A:   
  020a 206f     [3]             BRA   L27B ;abs = 027b
  020c          L20C:   
  454:  	}
  455:      //MMA8652_dump(events);
  456:  #endif
  457:      
  458:  #if gMAG3110_enable    
  459:      MAG3110_dump(events);
  460:  #endif
  461:      
  462:  #if gFXAS21000_enable    
  463:      FXAS21000_dump(events);
  464:  #endif
  465:      
  466:  #if gMMA9553_enable    
  467:      MMA9553_dump(events);
  468:  #endif
  469:      
  470:      break;
  471:      
  472:    case stateInitRooter:
  473:       /* Print a welcome message to the UART */
  474:      UartUtil_Print(" MyWirelessApp Demo Beacon Coordinator application is initialized and ready.\n\r\n\r", gAllowToBlock_d);            
  020c 450000   [3]             LDHX  @" MyWirelessApp Demo Beacon Coordinator application is initialized and ready.\012\015\012\015"
  020f ac00032d [8]             CALL  AppTask:813
  475:      /* Goto Energy Detection state. */
  476:      gState = stateScanEdStart;
  0213 a607     [2]             LDA   #7
  0215          L215:   
  477:      TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);    
  478:      break;
  0215 cc02b7   [4]             JMP   L2B7 ;abs = 02b7
  0218          L218:   
  479:      
  480:    case stateScanEdStart:
  481:        /* Start the Energy Detection scan, and goto wait for confirm state. */
  482:        UartUtil_Print("Initiating the Energy Detection Scan\n\r", gAllowToBlock_d);
  0218 450000   [3]             LDHX  @"Initiating the Energy Detection Scan\012\015"
  021b ac00032d [8]             CALL  AppTask:813
  483:        /*Print the message on the LCD also*/
  484:        LCD_ClearDisplay();
  485:        LCD_WriteString(1,"Starting Energy");
  486:        LCD_WriteString(2,"Detection Scan");      
  487:        rc = App_StartScan(gScanModeED_c);
  021f 4f       [1]             CLRA  
  0220 ac000000 [8]             CALL  App_StartScan
  488:        if(rc == errorNoError)
  0224 4d       [1]             TSTA  
  0225 2654     [3]             BNE   L27B ;abs = 027b
  489:        {
  490:          gState = stateScanEdWaitConfirm;
  0227 a608     [2]             LDA   #8
  0229          L229:   
  0229 204d     [3]             BRA   L278 ;abs = 0278
  022b          L22B:   
  491:        }
  492:        break;
  493:        
  494:    case stateScanEdWaitConfirm:
  495:        /* Stay in this state until the MLME Scan confirm message arrives,
  496:           and has been processed. Then goto Start Coordinator state. */
  497:        if (events & gAppEvtMessageFromMLME_c)
  022b 95       [2]             TSX   
  022c e603     [3]             LDA   3,X
  022e a504     [2]             BIT   #4
  0230 2749     [3]             BEQ   L27B ;abs = 027b
  498:        {
  499:          if (pMsgIn)
  0232 9efe01   [5]             LDHX  1,SP
  0235 2744     [3]             BEQ   L27B ;abs = 027b
  500:          {
  501:            rc = App_WaitMsg(pMsgIn, gNwkScanCnf_c);
  0237 a60b     [2]             LDA   #11
  0239 ac000000 [8]             CALL  App_WaitMsg
  502:            if(rc == errorNoError)
  023d 4d       [1]             TSTA  
  023e 263b     [3]             BNE   L27B ;abs = 027b
  503:            {
  504:              /* Process the ED scan confirm. The logical
  505:                 channel is selected by this function. */
  506:              App_HandleScanEdConfirm(pMsgIn);
  0240 9efe01   [5]             LDHX  1,SP
  0243 ac000000 [8]             CALL  App_HandleScanEdConfirm
  507:              /* Go to the Start Coordinator state */
  508:              gState = stateStartRooter;
  0247 a609     [2]             LDA   #9
  0249 c70000   [4]             STA   gState
  509:              TS_SendEvent(gAppTaskID_c, gAppEvtStartCoordinator_c);
  024c c60000   [4]             LDA   gAppTaskID_c
  024f ae10     [2]             LDX   #16
  0251 206c     [3]             BRA   L2BF ;abs = 02bf
  0253          L253:   
  510:            }
  511:          }
  512:        }
  513:        break;
  514:    
  515:    case stateStartRooter:
  516:      if (events & gAppEvtStartCoordinator_c)
  0253 95       [2]             TSX   
  0254 e603     [3]             LDA   3,X
  0256 a510     [2]             BIT   #16
  0258 2721     [3]             BEQ   L27B ;abs = 027b
  517:      {
  518:        /* Start up as a PAN Coordinator on the selected channel. */
  519:        UartUtil_Print("\n\rStarting as PAN Rooter on channel 0x", gAllowToBlock_d);
  025a 450000   [3]             LDHX  @"\012\015Starting as PAN Rooter on channel 0x"
  025d ac00032d [8]             CALL  AppTask:813
  520:        UartUtil_PrintHex(&mLogicalChannel, 1, FALSE);
  0261 450000   [3]             LDHX  @mLogicalChannel
  0264 ac000340 [8]             CALL  AppTask:832
  521:        UartUtil_Print("\n\r", gAllowToBlock_d);
  0268 450000   [3]             LDHX  @"\012\015"
  026b ac00032d [8]             CALL  AppTask:813
  522:        /*print a message on the LCD also*/
  523:        LCD_ClearDisplay();
  524:        LCD_WriteString(1,"Starting");
  525:        LCD_WriteString(2,"PAN Rooter");
  526:        rc = App_StartRooter();
  026f ac000000 [8]             CALL  App_StartRooter
  527:        if(rc == errorNoError)
  0273 4d       [1]             TSTA  
  0274 266b     [3]             BNE   L2E1 ;abs = 02e1
  528:        {
  529:          /* If the Start request was sent successfully to
  530:             the MLME, then goto Wait for confirm state. */
  531:          gState = stateStartRooterWaitConfirm;
  0276 a60a     [2]             LDA   #10
  0278          L278:   
  0278 c70000   [4]             STA   gState
  027b          L27B:   
  027b 2064     [3]             BRA   L2E1 ;abs = 02e1
  027d          L27D:   
  532:        }
  533:      }
  534:      break; 
  535:      
  536:    case stateStartRooterWaitConfirm:
  537:      /* Stay in this state until the Start confirm message
  538:         arrives, and then goto the Listen state. */
  539:      if (events & gAppEvtMessageFromMLME_c)
  027d 95       [2]             TSX   
  027e e603     [3]             LDA   3,X
  0280 a504     [2]             BIT   #4
  0282 275d     [3]             BEQ   L2E1 ;abs = 02e1
  540:      {
  541:        if (pMsgIn)
  0284 9efe01   [5]             LDHX  1,SP
  0287 2758     [3]             BEQ   L2E1 ;abs = 02e1
  542:        {    
  543:          rc = App_WaitMsg(pMsgIn, gNwkStartCnf_c);
  0289 a60e     [2]             LDA   #14
  028b ac000000 [8]             CALL  App_WaitMsg
  544:          if(rc == errorNoError)
  028f 4d       [1]             TSTA  
  0290 264f     [3]             BNE   L2E1 ;abs = 02e1
  545:          {
  546:            UartUtil_Print("Started the Rooter with PAN ID 0x", gAllowToBlock_d);
  0292 450000   [3]             LDHX  @"Started the Rooter with PAN ID 0x"
  0295 ac00032d [8]             CALL  AppTask:813
  547:            UartUtil_PrintHex((uint8_t *)maPanId, 2, 0);
  0299 450000   [3]             LDHX  @maPanId
  029c ac000334 [8]             CALL  AppTask:820
  548:            UartUtil_Print(", and short address 0x", gAllowToBlock_d);
  02a0 450000   [3]             LDHX  @", and short address 0x"
  02a3 ac00032d [8]             CALL  AppTask:813
  549:            UartUtil_PrintHex((uint8_t *)maShortAddress, 2, 0);
  02a7 450000   [3]             LDHX  @maShortAddress
  02aa ac000334 [8]             CALL  AppTask:820
  550:            UartUtil_Print(".\n\r\n\rReady to send and receive data over the UART.\n\r\n\r", gAllowToBlock_d);
  02ae 450000   [3]             LDHX  @".\012\015\012\015Ready to send and receive data over the UART.\012\015\012\015"
  02b1 ac00032d [8]             CALL  AppTask:813
  551:            /*print a message on the LCD also*/
  552:            LCD_ClearDisplay();
  553:            LCD_WriteString(1,"Ready to send");
  554:            LCD_WriteString(2,"and receive data");
  555:            gState = stateRooterListen;
  02b5 a60b     [2]             LDA   #11
  02b7          L2B7:   
  02b7 c70000   [4]             STA   gState
  556:            TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);
  02ba c60000   [4]             LDA   gAppTaskID_c
  02bd ae01     [2]             LDX   #1
  02bf          L2BF:   
  02bf 8c       [1]             CLRH  
  02c0 ac000000 [8]             CALL  TS_SendEvent
  02c4 201b     [3]             BRA   L2E1 ;abs = 02e1
  02c6          L2C6:   
  557:          }
  558:        }
  559:      }
  560:      break; 
  561:      
  562:    /* added by yusk */
  563:    case stateRooterListen:
  564:      /* Stay in this state forever. 
  565:         Transmit the data received on UART */
  566:      if (events & gAppEvtMessageFromMLME_c)
  02c6 95       [2]             TSX   
  02c7 e603     [3]             LDA   3,X
  02c9 a504     [2]             BIT   #4
  02cb 2709     [3]             BEQ   L2D6 ;abs = 02d6
  567:      {
  568:        /* Get the message from MLME */
  569:        if (pMsgIn)
  02cd 9efe01   [5]             LDHX  1,SP
  02d0 2704     [3]             BEQ   L2D6 ;abs = 02d6
  570:        {      
  571:          /* Process it */
  572:          rc = Router_HandleMlmeInput(pMsgIn);
  02d2 ac000000 [8]             CALL  Router_HandleMlmeInput
  02d6          L2D6:   
  573:          /* Messages from the MLME must always be freed. */
  574:        }
  575:      }
  576:       if (events & gAppEvtRxFromUart_c)
  02d6 95       [2]             TSX   
  02d7 e603     [3]             LDA   3,X
  02d9 a502     [2]             BIT   #2
  02db 2704     [3]             BEQ   L2E1 ;abs = 02e1
  577:      {      
  578:        /* get byte from UART */
  579:        Router_TransmitUartData();
  02dd ac000000 [8]             CALL  Router_TransmitUartData
  02e1          L2E1:   
  580:      
  581:      }  
  582:      break;     
  583:    }
  584:    
  585:    if (pMsgIn)
  02e1 9efe01   [5]             LDHX  1,SP
  02e4 2704     [3]             BEQ   L2EA ;abs = 02ea
  586:    {
  587:      /* Messages must always be freed. */ 
  588:      MSG_Free(pMsgIn);
  02e6 ac000000 [8]             CALL  MM_Free
  02ea          L2EA:   
  589:    }
  590:    
  591:     /* Handle MCPS confirms and transmit data from UART */
  592:    if (events & gAppEvtMessageFromMCPS_c)
  02ea 95       [2]             TSX   
  02eb e603     [3]             LDA   3,X
  02ed a508     [2]             BIT   #8
  02ef 271b     [3]             BEQ   L30C ;abs = 030c
  593:    {      
  594:      /* Get the message from MCPS */
  595:      pMsgIn = MSG_DeQueue(&mMcpsNwkInputQueue);
  02f1 450000   [3]             LDHX  @mMcpsNwkInputQueue
  02f4 ac000000 [8]             CALL  List_RemoveHead
  596:      if (pMsgIn)
  02f8 650000   [3]             CPHX  #0
  02fb 270f     [3]             BEQ   L30C ;abs = 030c
  597:      {              
  598:        /* Process it */
  599:        Router_HandleMcpsInput(pMsgIn);
  02fd 89       [2]             PSHX  
  02fe 8b       [2]             PSHH  
  02ff ac000000 [8]             CALL  Router_HandleMcpsInput
  600:        /* Messages from the MCPS must always be freed. */
  601:        MSG_Free(pMsgIn);
  0303 9efe01   [5]             LDHX  1,SP
  0306 ac000000 [8]             CALL  MM_Free
  030a a702     [2]             AIS   #2
  030c          L30C:   
  602:      }
  603:    }
  604:    
  605:    /* Check for pending messages in the Queue */ 
  606:    if(MSG_Pending(&mMcpsNwkInputQueue))
  030c 320000   [5]             LDHX  mMcpsNwkInputQueue
  030f 270a     [3]             BEQ   L31B ;abs = 031b
  607:      TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMCPS_c);
  0311 c60000   [4]             LDA   gAppTaskID_c
  0314 ae08     [2]             LDX   #8
  0316 8c       [1]             CLRH  
  0317 ac000000 [8]             CALL  TS_SendEvent
  031b          L31B:   
  608:    if(MSG_Pending(&mMlmeNwkInputQueue))
  031b 320000   [5]             LDHX  mMlmeNwkInputQueue
  031e 270a     [3]             BEQ   L32A ;abs = 032a
  609:      TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMLME_c);  
  0320 c60000   [4]             LDA   gAppTaskID_c
  0323 ae04     [2]             LDX   #4
  0325 8c       [1]             CLRH  
  0326 ac000000 [8]             CALL  TS_SendEvent
  032a          L32A:   
  610:  }
  032a a704     [2]             AIS   #4
  032c 8d       [7]             RTC   
  032d          L32D:   
  032d a601     [2]             LDA   #1
  032f ac000000 [8]             CALL  UartUtil_Print
  0333 8d       [7]             RTC   
  0334          L334:   
  0334 89       [2]             PSHX  
  0335 8b       [2]             PSHH  
  0336 ae02     [2]             LDX   #2
  0338 4f       [1]             CLRA  
  0339 ac000000 [8]             CALL  UartUtil_PrintHex
  033d a702     [2]             AIS   #2
  033f 8d       [7]             RTC   
  0340          L340:   
  0340 89       [2]             PSHX  
  0341 8b       [2]             PSHH  
  0342 ae01     [2]             LDX   #1
  0344 4f       [1]             CLRA  
  0345 ac000000 [8]             CALL  UartUtil_PrintHex
  0349 a702     [2]             AIS   #2
  034b 8d       [7]             RTC   
  611:  
  612:  /************************************************************************************
  613:  *************************************************************************************
  614:  * Private functions
  615:  *************************************************************************************
  616:  ************************************************************************************/
  617:  
  618:  /*****************************************************************************
  619:  * UartRxCallBack
  620:  *
  621:  * This callback is triggered when a new byte is received over the UART
  622:  *
  623:  *****************************************************************************/
  624:  static void UartRxCallBack(void) 
  625:  {
  0000 8b       [2]             PSHH  
  626:    uint8_t pressedKey;
  627:    if(stateListen == gState){
  0001 c60000   [4]             LDA   gState
  0004 a105     [2]             CMP   #5
  0006 260c     [3]             BNE   L14 ;abs = 0014
  628:      TS_SendEvent(gAppTaskID_c, gAppEvtRxFromUart_c);
  0008 c60000   [4]             LDA   gAppTaskID_c
  000b ae02     [2]             LDX   #2
  000d 8c       [1]             CLRH  
  000e ac000000 [8]             CALL  TS_SendEvent
  629:    }else{
  630:  	  (void)UartX_GetByteFromRxBuffer(&pressedKey);
  631:    }
  632:  }
  0012 8a       [3]             PULH  
  0013 8d       [7]             RTC   
  0014          L14:    
  0014 95       [2]             TSX   
  0015 ac000000 [8]             CALL  Uart1_GetByteFromRxBuffer
  0019 8a       [3]             PULH  
  001a 8d       [7]             RTC   
  633:  
  634:  /******************************************************************************
  635:  * The App_HandleMlmeInput(nwkMessage_t *pMsg) function will handle various
  636:  * messages from the MLME, e.g. Beacon notifications; 
  637:  *
  638:  * The function may return either of the following values:
  639:  *   errorNoError:   The message was processed.
  640:  *   errorNoMessage: The message pointer is NULL.
  641:  *
  642:  ******************************************************************************/
  643:  static uint8_t App_HandleMlmeInput(nwkMessage_t *pMsg)
  644:  {
  645:    if(pMsg == NULL)
  0000 650000   [3]             CPHX  #0
  0003 2603     [3]             BNE   L8 ;abs = 0008
  646:      return errorNoMessage;
  0005 a603     [2]             LDA   #3
  0007 8d       [7]             RTC   
  0008          L8:     
  647:    
  648:    /* Handle the incoming message. The type determines the sort of processing. */
  649:    switch(pMsg->msgType)
  0008 f6       [3]             LDA   ,X
  0009 a104     [2]             CMP   #4
  000b 2607     [3]             BNE   L14 ;abs = 0014
  650:    {
  651:      case gNwkBeaconNotifyInd_c:   
  652:        /* Always free pBufferRoot */    
  653:        MSG_Free(((nwkMessage_t *)pMsg)->msgData.beaconNotifyInd.pBufferRoot);
  000d 9ece0a   [5]             LDHX  10,X
  0010 ac000000 [8]             CALL  MM_Free
  0014          L14:    
  654:        break;  
  655:           
  656:    }
  657:    return errorNoError;
  0014 4f       [1]             CLRA  
  658:  }
  0015 8d       [7]             RTC   
  659:  
  660:  /* added by yusk */
  661:  static uint8_t Router_HandleMlmeInput(nwkMessage_t *pMsg)
  662:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  663:    if(pMsg == NULL)
  0002 650000   [3]             CPHX  #0
  0005 2604     [3]             BNE   LB ;abs = 000b
  664:      return errorNoMessage;
  0007 a603     [2]             LDA   #3
  0009 2036     [3]             BRA   L41 ;abs = 0041
  000b          LB:     
  665:    
  666:    /* Handle the incoming message. The type determines the sort of processing.*/
  667:    switch(pMsg->msgType) {
  000b f6       [3]             LDA   ,X
  000c 2706     [3]             BEQ   L14 ;abs = 0014
  000e a10c     [2]             CMP   #12
  0010 262e     [3]             BNE   L40 ;abs = 0040
  0012 2012     [3]             BRA   L26 ;abs = 0026
  0014          L14:    
  668:    case gNwkAssociateInd_c:
  669:      UartUtil_Print("Received an MLME-Associate Indication from the MAC\n\r", gAllowToBlock_d);
  0014 450000   [3]             LDHX  @"Received an MLME-Associate Indication from the MAC\012\015"
  0017 a601     [2]             LDA   #1
  0019 ac000000 [8]             CALL  UartUtil_Print
  670:      /* A device sent us an Associate Request. We must send back a response.  */
  671:      return Router_SendAssociateResponse(pMsg);
  001d 9efe01   [5]             LDHX  1,SP
  0020 ac000000 [8]             CALL  Router_SendAssociateResponse
  0024 201b     [3]             BRA   L41 ;abs = 0041
  0026          L26:    
  672:      break;
  673:      
  674:    case gNwkCommStatusInd_c:
  675:      /* Sent by the MLME after the Association Response has been transmitted. */
  676:      UartUtil_Print("Received an MLME-Comm-Status Indication from the MAC - status = ", gAllowToBlock_d);
  0026 450000   [3]             LDHX  @"Received an MLME-Comm-Status Indication from the MAC - status = "
  0029 a601     [2]             LDA   #1
  002b ac000000 [8]             CALL  UartUtil_Print
  677:      UartUtil_PrintHex(&pMsg->msgData.commStatusInd.status, 1, gPrtHexNewLine_c);
  002f 9efe01   [5]             LDHX  1,SP
  0032 af15     [2]             AIX   #21
  0034 89       [2]             PSHX  
  0035 8b       [2]             PSHH  
  0036 ae01     [2]             LDX   #1
  0038 a602     [2]             LDA   #2
  003a ac000000 [8]             CALL  UartUtil_PrintHex
  003e a702     [2]             AIS   #2
  0040          L40:    
  678:      break;
  679:    }
  680:    return errorNoError;
  0040 4f       [1]             CLRA  
  0041          L41:    
  681:  }
  0041 a702     [2]             AIS   #2
  0043 8d       [7]             RTC   
  682:  
  683:  /* added by yusk */
  684:  static uint8_t Router_SendAssociateResponse(nwkMessage_t *pMsgIn)
  685:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  0002 a7fa     [2]             AIS   #-6
  686:    mlmeMessage_t *pMsg;
  687:    mlmeAssociateRes_t *pAssocRes;
  688:  
  689:    static uint8_t count;
  690:    
  691:    // static uint8_t nwk_addr; // deleted by yusk
  692:  
  693:    UartUtil_Print("Sending the MLME-Associate Response message to the MAC...", gAllowToBlock_d);
  0004 450000   [3]             LDHX  @"Sending the MLME-Associate Response message to the MAC..."
  0007 ac0000b5 [8]             CALL  Router_SendAssociateResponse:181
  694:   
  695:    /* Allocate a message for the MLME */
  696:    pMsg = MSG_AllocType(mlmeMessage_t);
  000b a60f     [2]             LDA   #15
  000d ac000000 [8]             CALL  MM_Alloc
  0011 9eff05   [5]             STHX  5,SP
  697:    if(pMsg != NULL)
  0014 2603     [3]             BNE   L19 ;abs = 0019
  0016 cc00a9   [4]             JMP   LA9 ;abs = 00a9
  0019          L19:    
  698:    {
  699:      /* This is a MLME-ASSOCIATE.res command */
  700:      pMsg->msgType = gMlmeAssociateRes_c;
  0019 a601     [2]             LDA   #1
  001b f7       [2]             STA   ,X
  701:      
  702:      /* Create the Associate response message data. */
  703:      pAssocRes = &pMsg->msgData.associateRes;
  001c af01     [2]             AIX   #1
  001e 9eff03   [5]             STHX  3,SP
  704:      
  705:      /* Assign a short address to the device. In this example we simply
  706:         choose 0x0001. Though, all devices and coordinators in a PAN must have
  707:         different short addresses. However, if a device do not want to use 
  708:         short addresses at all in the PAN, a short address of 0xFFFE must
  709:         be assigned to it. */
  710:      if(pMsgIn->msgData.associateInd.capabilityInfo & gCapInfoAllocAddr_c)
  0021 9efe07   [5]             LDHX  7,SP
  0024 e60b     [3]             LDA   11,X
  0026 2a1a     [3]             BPL   L42 ;abs = 0042
  711:      {
  712:        if(count != 0){
  0028 c60000   [4]             LDA   count
  002b 2703     [3]             BEQ   L30 ;abs = 0030
  002d cc00b0   [4]             JMP   LB0 ;abs = 00b0
  0030          L30:    
  713:      	  return errorAllocFailed;
  714:        }
  715:        /* Assign a unique short address less than 0xfffe if the device requests so. */
  716:        pAssocRes->assocShortAddress[1] = maMyAddress[1];
  0030 9efe03   [5]             LDHX  3,SP
  0033 c60001   [4]             LDA   maMyAddress:1
  0036 e709     [3]             STA   9,X
  717:        pAssocRes->assocShortAddress[0] = 0x02;
  0038 a602     [2]             LDA   #2
  003a e708     [3]             STA   8,X
  718:        // nwk_addr += 1; // deleted by yusk
  719:        count += 1;
  003c 450000   [3]             LDHX  @count
  003f 7c       [4]             INC   ,X
  720:      }
  0040 200a     [3]             BRA   L4C ;abs = 004c
  0042          L42:    
  721:      else
  722:      {
  723:        /* A short address of 0xfffe means that the device is granted access to
  724:           the PAN (Associate successful) but that long addressing is used.*/
  725:        pAssocRes->assocShortAddress[0] = 0xFE;
  0042 9efe03   [5]             LDHX  3,SP
  0045 a6fe     [2]             LDA   #-2
  0047 e708     [3]             STA   8,X
  726:        pAssocRes->assocShortAddress[1] = 0xFF;
  0049 4c       [1]             INCA  
  004a e709     [3]             STA   9,X
  004c          L4C:    
  727:      }
  728:      /* Get the 64 bit address of the device requesting association. */
  729:      FLib_MemCpy(pAssocRes->deviceAddress, pMsgIn->msgData.associateInd.deviceAddress, 8);
  004c 9efe03   [5]             LDHX  3,SP
  004f 89       [2]             PSHX  
  0050 8b       [2]             PSHH  
  0051 9efe09   [5]             LDHX  9,SP
  0054 af01     [2]             AIX   #1
  0056 a608     [2]             LDA   #8
  0058 ac000000 [8]             CALL  FLib_MemCpy
  005c a702     [2]             AIS   #2
  730:      /* Association granted. May also be gPanAtCapacity_c or gPanAccessDenied_c. */
  731:      pAssocRes->status = gSuccess_c;
  005e 9efe03   [5]             LDHX  3,SP
  0061 6f0b     [5]             CLR   11,X
  732:      /* Do not use security */
  733:  #ifndef gMAC2006_d
  734:      pAssocRes->securityEnable = FALSE;
  0063 6f0a     [5]             CLR   10,X
  735:  #else
  736:    pAssocRes->securityLevel = 0;
  737:  #endif //gMAC2006_d 
  738:      
  739:      /* Save device info. */
  740:      FLib_MemCpy(maDeviceShortAddress, pAssocRes->assocShortAddress, 2);
  0065 9eff01   [5]             STHX  1,SP
  0068 450000   [3]             LDHX  @maDeviceShortAddress
  006b 89       [2]             PSHX  
  006c 8b       [2]             PSHH  
  006d 9efe03   [5]             LDHX  3,SP
  0070 af08     [2]             AIX   #8
  0072 a602     [2]             LDA   #2
  0074 ac000000 [8]             CALL  FLib_MemCpy
  0078 a702     [2]             AIS   #2
  741:      FLib_MemCpy(maDeviceLongAddress,  pAssocRes->deviceAddress,     8);
  007a 450000   [3]             LDHX  @maDeviceLongAddress
  007d 89       [2]             PSHX  
  007e 8b       [2]             PSHH  
  007f 9efe05   [5]             LDHX  5,SP
  0082 a608     [2]             LDA   #8
  0084 ac000000 [8]             CALL  FLib_MemCpy
  0088 a702     [2]             AIS   #2
  742:      
  743:      /* Send the Associate Response to the MLME. */
  744:      if(MSG_Send(NWK_MLME, pMsg) == gSuccess_c)
  008a 9efe05   [5]             LDHX  5,SP
  008d ac000000 [8]             CALL  NWK_MLME_SapHandler
  0091 4d       [1]             TSTA  
  0092 260a     [3]             BNE   L9E ;abs = 009e
  745:      {
  746:        UartUtil_Print("Done\n\r", gAllowToBlock_d);
  0094 450000   [3]             LDHX  @"Done\012\015"
  0097 ac0000b5 [8]             CALL  Router_SendAssociateResponse:181
  747:        return errorNoError;
  009b 4f       [1]             CLRA  
  009c 2014     [3]             BRA   LB2 ;abs = 00b2
  009e          L9E:    
  748:      }
  749:      else
  750:      {
  751:        /* One or more parameters in the message were invalid. */
  752:        UartUtil_Print("Invalid parameter!\n\r", gAllowToBlock_d);
  009e 450000   [3]             LDHX  @"Invalid parameter!\012\015"
  00a1 ac0000b5 [8]             CALL  Router_SendAssociateResponse:181
  753:        return errorInvalidParameter;
  00a5 a605     [2]             LDA   #5
  00a7 2009     [3]             BRA   LB2 ;abs = 00b2
  00a9          LA9:    
  754:      }
  755:    }
  756:    else
  757:    {
  758:      /* Allocation of a message buffer failed. */
  759:      UartUtil_Print("Message allocation failed!\n\r", gAllowToBlock_d);
  00a9 450000   [3]             LDHX  @"Message allocation failed!\012\015"
  00ac ac0000b5 [8]             CALL  Router_SendAssociateResponse:181
  00b0          LB0:    
  760:      return errorAllocFailed;
  00b0 a604     [2]             LDA   #4
  00b2          LB2:    
  761:    }
  762:  }
  00b2 a708     [2]             AIS   #8
  00b4 8d       [7]             RTC   
  00b5          LB5:    
  00b5 a601     [2]             LDA   #1
  00b7 ac000000 [8]             CALL  UartUtil_Print
  00bb 8d       [7]             RTC   
  763:  
  764:  /************************************************************************************
  765:  *************************************************************************************
  766:  * Private functions
  767:  *************************************************************************************
  768:  ************************************************************************************/
  769:  
  770:  
  771:  /* added by yusk */
  772:  static void Router_TransmitUartData(void)
  773:  {   
  774:    static uint8_t keysBuffer[mMaxKeysToReceive_c];
  775:    static uint8_t keysReceived = 0;
  776:    // const uint8_t broadcastaddress[8] = { 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }; //deleted by yusk
  777:  
  778:    
  779:    /* get data from UART */
  780:    if( keysReceived < mMaxKeysToReceive_c) 
  0000 c60000   [4]             LDA   keysReceived
  0003 a120     [2]             CMP   #32
  0005 2414     [3]             BCC   L1B ;abs = 001b
  781:    { 
  782:      if(UartX_GetByteFromRxBuffer(&keysBuffer[keysReceived])) 
  0007 ab00     [2]             ADD   @keysBuffer
  0009 87       [2]             PSHA  
  000a 4f       [1]             CLRA  
  000b a900     [2]             ADC   @keysBuffer:MSB
  000d 88       [3]             PULX  
  000e 87       [2]             PSHA  
  000f 8a       [3]             PULH  
  0010 ac000000 [8]             CALL  Uart1_GetByteFromRxBuffer
  0014 4d       [1]             TSTA  
  0015 2704     [3]             BEQ   L1B ;abs = 001b
  783:      {
  784:      keysReceived++;
  0017 450000   [3]             LDHX  @keysReceived
  001a 7c       [4]             INC   ,X
  001b          L1B:    
  785:      }
  786:    }
  787:    /* Use multi buffering for increased TX performance. It does not really
  788:       have any effect at a UART baud rate of 19200bps but serves as an
  789:       example of how the throughput may be improved in a real-world 
  790:       application where the data rate is of concern. */
  791:    if( (mcPendingPackets < mDefaultValueOfMaxPendingDataPackets_c) && (mpPacket == NULL) ) 
  001b c60000   [4]             LDA   mcPendingPackets
  001e a102     [2]             CMP   #2
  0020 240e     [3]             BCC   L30 ;abs = 0030
  0022 320000   [5]             LDHX  mpPacket
  0025 2609     [3]             BNE   L30 ;abs = 0030
  792:    {
  793:      /* If the maximum number of pending data buffes is below maximum limit 
  794:         and we do not have a data buffer already then allocate one. */
  795:      mpPacket = MSG_Alloc(gMaxRxTxDataLength_c);
  0027 a68d     [2]             LDA   #-115
  0029 ac000000 [8]             CALL  MM_Alloc
  002d 960000   [5]             STHX  mpPacket
  0030          L30:    
  796:    }
  797:  
  798:    if(mpPacket != NULL)
  0030 320000   [5]             LDHX  mpPacket
  0033 276e     [3]             BEQ   LA3 ;abs = 00a3
  799:    {
  800:        /* get data from UART */        
  801:        mpPacket->msgData.dataReq.pMsdu = (uint8_t*)(&(mpPacket->msgData.dataReq.pMsdu)) + sizeof(uint8_t*);
  0035 af1c     [2]             AIX   #28
  0037 9f       [1]             TXA   
  0038 8b       [2]             PSHH  
  0039 320000   [5]             LDHX  mpPacket
  003c e71b     [3]             STA   27,X
  003e 86       [3]             PULA  
  003f e71a     [3]             STA   26,X
  802:        FLib_MemCpy(mpPacket->msgData.dataReq.pMsdu, (uint8_t*) keysBuffer, keysReceived);
  0041 9ece1a   [5]             LDHX  26,X
  0044 89       [2]             PSHX  
  0045 8b       [2]             PSHH  
  0046 450000   [3]             LDHX  @keysBuffer
  0049 c60000   [4]             LDA   keysReceived
  004c ac000000 [8]             CALL  FLib_MemCpy
  0050 a702     [2]             AIS   #2
  803:  
  804:        /* Data was available in the UART receive buffer. Now create an
  805:           MCPS-Data Request message containing the UART data. */
  806:        mpPacket->msgType = gMcpsDataReq_c;
  0052 320000   [5]             LDHX  mpPacket
  0055 7f       [4]             CLR   ,X
  807:        /* Create the header using device information stored when creating 
  808:           the association response. In this simple example the use of short
  809:           addresses is hardcoded. In a real world application we must be
  810:           flexible, and use the address mode required by the given situation. */
  811:        
  812:        
  813:        // FLib_MemCpy(mpPacket->msgData.dataReq.dstAddr, (void *)broadcastaddress, 2); // deleted by yusk
  814:        FLib_MemCpy(mpPacket->msgData.dataReq.srcAddr, (void *)maShortAddress, 2);
  0056 af0c     [2]             AIX   #12
  0058 89       [2]             PSHX  
  0059 8b       [2]             PSHH  
  005a 450000   [3]             LDHX  @maShortAddress
  005d a602     [2]             LDA   #2
  005f ac000000 [8]             CALL  FLib_MemCpy
  0063 a702     [2]             AIS   #2
  815:        FLib_MemCpy(mpPacket->msgData.dataReq.dstPanId, (void *)maPanId, 2);
  0065 320000   [5]             LDHX  mpPacket
  0068 af09     [2]             AIX   #9
  006a ac0000b3 [8]             CALL  Router_TransmitUartData:179
  816:        FLib_MemCpy(mpPacket->msgData.dataReq.srcPanId, (void *)maPanId, 2);
  006e 320000   [5]             LDHX  mpPacket
  0071 af14     [2]             AIX   #20
  0073 ac0000b3 [8]             CALL  Router_TransmitUartData:179
  817:        mpPacket->msgData.dataReq.dstAddrMode = gAddrModeShort_c;
  0077 a602     [2]             LDA   #2
  0079 320000   [5]             LDHX  mpPacket
  007c e70b     [3]             STA   11,X
  818:        mpPacket->msgData.dataReq.srcAddrMode = gAddrModeShort_c;
  007e e716     [3]             STA   22,X
  819:        mpPacket->msgData.dataReq.msduLength = keysReceived;
  0080 c60000   [4]             LDA   keysReceived
  0083 e717     [3]             STA   23,X
  820:        /* Request MAC level acknowledgement, and a
  821:           indirect transmission of the data packet */
  822:        mpPacket->msgData.dataReq.txOptions = gTxOptsAck_c | gTxOptsIndirect_c; // updated by yusk
  0085 a605     [2]             LDA   #5
  0087 e719     [3]             STA   25,X
  823:        /* Give the data packet a handle. The handle is
  824:           returned in the MCPS-Data Confirm message. */
  825:        mpPacket->msgData.dataReq.msduHandle = mMsduHandle++;
  0089 c60000   [4]             LDA   mMsduHandle
  008c e718     [3]             STA   24,X
  008e 4c       [1]             INCA  
  008f c70000   [4]             STA   mMsduHandle
  826:  #ifdef gMAC2006_d
  827:      mpPacket->msgData.dataReq.securityLevel = 0;
  828:  #endif //gMAC2006_d   
  829:        
  830:        /* Send the Data Request to the MCPS */
  831:        (void)MSG_Send(NWK_MCPS, mpPacket);
  0092 ac000000 [8]             CALL  NWK_MCPS_SapHandler
  832:        /* Prepare for another data buffer */
  833:        mpPacket = NULL;
  0096 5f       [1]             CLRX  
  0097 8c       [1]             CLRH  
  0098 960000   [5]             STHX  mpPacket
  834:        mcPendingPackets++;
  009b 450000   [3]             LDHX  @mcPendingPackets
  009e 7c       [4]             INC   ,X
  835:        /* Receive another pressed keys */
  836:        keysReceived = 0;
  009f 4f       [1]             CLRA  
  00a0 c70000   [4]             STA   keysReceived
  00a3          LA3:    
  837:    }
  838:    
  839:    /* If the keysBuffer[] wasn't send over the air because there are too many pending packets, */
  840:    /* try to send it later   */
  841:    if (keysReceived)
  00a3 c60000   [4]             LDA   keysReceived
  00a6 270a     [3]             BEQ   LB2 ;abs = 00b2
  842:    {
  843:    TS_SendEvent(gAppTaskID_c, gAppEvtRxFromUart_c);
  00a8 c60000   [4]             LDA   gAppTaskID_c
  00ab ae02     [2]             LDX   #2
  00ad 8c       [1]             CLRH  
  00ae ac000000 [8]             CALL  TS_SendEvent
  00b2          LB2:    
  844:    }
  845:  }
  00b2 8d       [7]             RTC   
  00b3          LB3:    
  00b3 89       [2]             PSHX  
  00b4 8b       [2]             PSHH  
  00b5 450000   [3]             LDHX  @maPanId
  00b8 a602     [2]             LDA   #2
  00ba ac000000 [8]             CALL  FLib_MemCpy
  00be a702     [2]             AIS   #2
  00c0 8d       [7]             RTC   
  846:  
  847:  
  848:  /******************************************************************************
  849:  * The App_StartScan(scanType) function will start the scan process of the
  850:  * specified type in the MAC. This is accomplished by allocating a MAC message,
  851:  * which is then assigned the desired scan parameters and sent to the MLME
  852:  * service access point.
  853:  * The function may return either of the following values:
  854:  *   errorNoError:          The Scan message was sent successfully.
  855:  *   errorInvalidParameter: The MLME service access point rejected the
  856:  *                          message due to an invalid parameter.
  857:  *   errorAllocFailed:      A message buffer could not be allocated.
  858:  *
  859:  ******************************************************************************/
  860:  static uint8_t App_StartScan(uint8_t scanType)
  861:  {
  0000 87       [2]             PSHA  
  0001 a7fe     [2]             AIS   #-2
  862:    mlmeMessage_t *pMsg;
  863:    mlmeScanReq_t *pScanReq;
  864:  
  865:    UartUtil_Print("Sending the MLME-Scan Request message to the MAC...", gAllowToBlock_d);
  0003 450000   [3]             LDHX  @"Sending the MLME-Scan Request message to the MAC..."
  0006 ac000056 [8]             CALL  App_StartScan:86
  866:  
  867:    /* Allocate a message for the MLME (We should check for NULL). */
  868:    pMsg = MSG_AllocType(mlmeMessage_t);
  000a a60f     [2]             LDA   #15
  000c ac000000 [8]             CALL  MM_Alloc
  0010 9eff01   [5]             STHX  1,SP
  869:    if(pMsg != NULL)
  0013 2735     [3]             BEQ   L4A ;abs = 004a
  870:    {
  871:      /* This is a MLME-SCAN.req command */
  872:      pMsg->msgType = gMlmeScanReq_c;
  0015 a608     [2]             LDA   #8
  0017 f7       [2]             STA   ,X
  873:      /* Create the Scan request message data. */
  874:      pScanReq = &pMsg->msgData.scanReq;
  875:      /* gScanModeED_c, gScanModeActive_c, gScanModePassive_c, or gScanModeOrphan_c */
  876:      pScanReq->scanType = scanType;
  0018 9ee603   [4]             LDA   3,SP
  001b e701     [3]             STA   1,X
  877:      /* ChannelsToScan & 0xFF - LSB, always 0x00 */
  878:      pScanReq->scanChannels[0] = (uint8_t)((mDefaultValueOfChannel_c)     & 0xFF);
  001d 6f02     [5]             CLR   2,X
  879:      /* ChannelsToScan>>8 & 0xFF  */
  880:      pScanReq->scanChannels[1] = (uint8_t)((mDefaultValueOfChannel_c>>8)  & 0xFF);
  001f 6f03     [5]             CLR   3,X
  881:      /* ChannelsToScan>>16 & 0xFF  */
  882:      pScanReq->scanChannels[2] = (uint8_t)((mDefaultValueOfChannel_c>>16) & 0xFF);
  0021 6f04     [5]             CLR   4,X
  883:      /* ChannelsToScan>>24 & 0xFF - MSB */
  884:      pScanReq->scanChannels[3] = (uint8_t)((mDefaultValueOfChannel_c>>24) & 0xFF);
  0023 a602     [2]             LDA   #2
  0025 e705     [3]             STA   5,X
  885:      /* Duration per channel 0-14 (dc). T[sec] = (16*960*((2^dc)+1))/1000000.
  886:         A scan duration of 2 on 16 channels approximately takes 1.2 secs. */
  887:      /* We know beforehand that we will talk to a coordinator with a Beacon
  888:         order of 1. Thus, choosing a Scan Duration of 2 per channel gives us
  889:         a very good chance (100% assuming no interference) of finding the
  890:         coordinator. 1 should be fine too though in an RF quiet environment. */
  891:      pScanReq->scanDuration = mDefaultValueOfScanDuration_c;
  0027 a607     [2]             LDA   #7
  0029 e706     [3]             STA   6,X
  892:  #ifdef gMAC2006_d
  893:  	pScanReq->securityLevel = 0;
  894:  #endif //gMAC2006_d	
  895:      
  896:      /* Send the Scan request to the MLME. */
  897:      if(MSG_Send(NWK_MLME, pMsg) == gSuccess_c)
  002b 9efe01   [5]             LDHX  1,SP
  002e ac000000 [8]             CALL  NWK_MLME_SapHandler
  0032 4d       [1]             TSTA  
  0033 260a     [3]             BNE   L3F ;abs = 003f
  898:      {
  899:        UartUtil_Print("Done\n\r", gAllowToBlock_d);
  0035 450000   [3]             LDHX  @"Done\012\015"
  0038 ac000056 [8]             CALL  App_StartScan:86
  900:        return errorNoError;
  003c 4f       [1]             CLRA  
  003d 2014     [3]             BRA   L53 ;abs = 0053
  003f          L3F:    
  901:      }
  902:      else
  903:      {
  904:        UartUtil_Print("Invalid parameter!\n\r", gAllowToBlock_d);
  003f 450000   [3]             LDHX  @"Invalid parameter!\012\015"
  0042 ac000056 [8]             CALL  App_StartScan:86
  905:        return errorInvalidParameter;
  0046 a605     [2]             LDA   #5
  0048 2009     [3]             BRA   L53 ;abs = 0053
  004a          L4A:    
  906:      }
  907:    }
  908:    else
  909:    {
  910:      /* Allocation of a message buffer failed. */
  911:      UartUtil_Print("Message allocation failed!\n\r", gAllowToBlock_d);
  004a 450000   [3]             LDHX  @"Message allocation failed!\012\015"
  004d ac000056 [8]             CALL  App_StartScan:86
  912:      return errorAllocFailed;
  0051 a604     [2]             LDA   #4
  0053          L53:    
  913:    }
  914:  }
  0053 a703     [2]             AIS   #3
  0055 8d       [7]             RTC   
  0056          L56:    
  0056 a601     [2]             LDA   #1
  0058 ac000000 [8]             CALL  UartUtil_Print
  005c 8d       [7]             RTC   
  915:  
  916:  /******************************************************************************
  917:  * The App_HandleScanActiveConfirm(nwkMessage_t *pMsg) function will handle the
  918:  * Active Scan confirm message received from the MLME when the Active scan has
  919:  * completed. The message contains a list of PAN descriptors. Based on link
  920:  * quality information in the pan descriptors the nearest coordinator is chosen.
  921:  * The corresponding pan descriptor is stored in the global variable mCoordInfo. 
  922:  *
  923:  * If a suitable coordinator was found, we synchronize to it immediately.
  924:  *
  925:  * The function may return either of the following values:
  926:  *   errorNoError:       A suitable pan descriptor was found.
  927:  *   errorNoScanResults: No scan results were present in the confirm message.
  928:  *
  929:  ******************************************************************************/
  930:  static uint8_t App_HandleScanActiveConfirm(nwkMessage_t *pMsg)
  931:  {
  0000 a7f3     [2]             AIS   #-13
  932:    void    *pBlock;
  933:    uint8_t panDescListSize = pMsg->msgData.scanCnf.resultListSize;
  0002 e603     [3]             LDA   3,X
  0004 9ee70a   [4]             STA   10,SP
  934:    uint8_t rc = errorNoScanResults;
  0007 a606     [2]             LDA   #6
  0009 9ee707   [4]             STA   7,SP
  935:    uint8_t j;
  936:    uint8_t bestLinkQuality = 0;  
  000c 9e6f09   [6]             CLR   9,SP
  937:    panDescriptorBlock_t *pDescBlock = pMsg->msgData.scanCnf.resList.pPanDescriptorBlocks;  
  000f 9ece08   [5]             LDHX  8,X
  0012 9eff05   [5]             STHX  5,SP
  938:    panDescriptor_t *pPanDesc;      
  939:   
  940:    /* Check if the scan resulted in any coordinator responses. */  
  941:    
  942:    if (panDescListSize > 0)
  0015 95       [2]             TSX   
  0016 6d09     [4]             TST   9,X
  0018 266d     [3]             BNE   L87 ;abs = 0087
  001a 206e     [3]             BRA   L8A ;abs = 008a
  001c          L1C:    
  943:    {    
  944:      /* Check all PAN descriptors. */
  945:      while (NULL != pDescBlock)
  946:      {
  947:        for (j = 0; j < pDescBlock->descriptorCount; j++)
  001c 95       [2]             TSX   
  001d 6f07     [5]             CLR   7,X
  001f 204b     [3]             BRA   L6C ;abs = 006c
  0021          L21:    
  948:        {            
  949:          pPanDesc = &pDescBlock->descriptorList[j];
  0021 95       [2]             TSX   
  0022 e607     [3]             LDA   7,X
  0024 ae16     [2]             LDX   #22
  0026 42       [5]             MUL   
  0027 9efe05   [5]             LDHX  5,SP
  002a 9eeb06   [4]             ADD   6,SP
  002d 87       [2]             PSHA  
  002e 8b       [2]             PSHH  
  002f 86       [3]             PULA  
  0030 a900     [2]             ADC   #0
  0032 88       [3]             PULX  
  950:  
  951:          /* Only attempt to associate if the coordinator accepts associations. */
  952:          if( pPanDesc->superFrameSpec[1] & gSuperFrameSpecMsbAssocPermit_c) 
  0033 87       [2]             PSHA  
  0034 8a       [3]             PULH  
  0035 e610     [3]             LDA   16,X
  0037 2a30     [3]             BPL   L69 ;abs = 0069
  953:          {
  954:            if ((pPanDesc->coordPanId[1]==coordinaterPanId[1])&&
  0039 e609     [3]             LDA   9,X
  003b a170     [2]             CMP   #112
  003d 262a     [3]             BNE   L69 ;abs = 0069
  955:                (pPanDesc->coordPanId[0]==coordinaterPanId[0]))
  003f e608     [3]             LDA   8,X
  0041 a104     [2]             CMP   #4
  0043 2624     [3]             BNE   L69 ;abs = 0069
  956:            {
  957:              /* Find the nearest coordinator using the link quality measure. */
  958:              if(pPanDesc->linkQuality > bestLinkQuality)
  0045 9ee609   [4]             LDA   9,SP
  0048 e112     [3]             CMP   18,X
  004a 241d     [3]             BCC   L69 ;abs = 0069
  959:              {
  960:                /* Save the information of the coordinator candidate. If we
  961:                   find a better candiate, the information will be replaced. */
  962:                FLib_MemCpy(&mCoordInfo, pPanDesc, sizeof(panDescriptor_t));
  004c 9eff01   [5]             STHX  1,SP
  004f 450000   [3]             LDHX  @mCoordInfo
  0052 89       [2]             PSHX  
  0053 8b       [2]             PSHH  
  0054 9efe03   [5]             LDHX  3,SP
  0057 a616     [2]             LDA   #22
  0059 ac000000 [8]             CALL  FLib_MemCpy
  005d a702     [2]             AIS   #2
  963:                bestLinkQuality = pPanDesc->linkQuality;
  005f 9efe01   [5]             LDHX  1,SP
  0062 e612     [3]             LDA   18,X
  0064 95       [2]             TSX   
  0065 e708     [3]             STA   8,X
  964:                rc = errorNoError;
  0067 6f06     [5]             CLR   6,X
  0069          L69:    
  0069 95       [2]             TSX   
  006a 6c07     [5]             INC   7,X
  006c          L6C:    
  006c 9efe05   [5]             LDHX  5,SP
  006f e66e     [3]             LDA   110,X
  0071 9ee108   [4]             CMP   8,SP
  0074 22ab     [3]             BHI   L21 ;abs = 0021
  965:              }
  966:            }
  967:          }      
  968:        }
  969:        
  970:        /* Free current block */
  971:        pBlock = pDescBlock;
  972:        pDescBlock = pDescBlock->pNext;              
  0076 89       [2]             PSHX  
  0077 8b       [2]             PSHH  
  0078 9ece6f   [5]             LDHX  111,X
  007b 9eff07   [5]             STHX  7,SP
  973:        MSG_Free(pBlock);
  007e 9efe01   [5]             LDHX  1,SP
  0081 ac000000 [8]             CALL  MM_Free
  0085 a702     [2]             AIS   #2
  0087          L87:    
  0087 9efe05   [5]             LDHX  5,SP
  008a          L8A:    
  008a 2690     [3]             BNE   L1C ;abs = 001c
  974:      }
  975:    }
  976:  
  977:    if(rc == errorNoError)
  008c 95       [2]             TSX   
  008d 6d06     [4]             TST   6,X
  008f 2703     [3]             BEQ   L94 ;abs = 0094
  0091 cc0150   [4]             JMP   L150 ;abs = 0150
  0094          L94:    
  978:    {
  979:      /* If we have found a beaconing coodinator we must setup the MAC to
  980:         synchronize to the beacon frames. This requires us to set the
  981:         PAN ID attribute of the MAC PIB to the PAN ID of the coordinator.
  982:         Furthermore, if we want to take advantage of the automatic
  983:         polling feature we must set the Auto Request MAC PIB attribute. */
  984:      if((mCoordInfo.superFrameSpec[0] & gSuperFrameSpecLsbBO_c) < 0xF) 
  0094 c6000f   [4]             LDA   mCoordInfo:15
  0097 a40f     [2]             AND   #15
  0099 a10f     [2]             CMP   #15
  009b 2503     [3]             BCS   LA0 ;abs = 00a0
  009d cc0150   [4]             JMP   L150 ;abs = 0150
  00a0          LA0:    
  985:      {
  986:        mlmeMessage_t *pMsgOut = MSG_AllocType(mlmeMessage_t);
  00a0 a60f     [2]             LDA   #15
  00a2 ac000000 [8]             CALL  MM_Alloc
  00a6 9eff03   [5]             STHX  3,SP
  987:        if(pMsgOut != NULL)
  00a9 2603     [3]             BNE   LAE ;abs = 00ae
  00ab cc0150   [4]             JMP   L150 ;abs = 0150
  00ae          LAE:    
  988:        {
  989:          uint8_t value = TRUE;
  00ae a601     [2]             LDA   #1
  00b0 95       [2]             TSX   
  00b1 e70a     [3]             STA   10,X
  990:          uint8_t mBeaconOrder;
  991:  		uint8_t mSuperFrameOrder;
  992:          /* Set MAC PIB auto request to TRUE. In this way the device will
  993:             automatically poll for data if the pending address list of the 
  994:             beacon frame contains our address. */
  995:          pMsgOut->msgType = gMlmeSetReq_c;
  00b3 9efe03   [5]             LDHX  3,SP
  00b6 a609     [2]             LDA   #9
  00b8 f7       [2]             STA   ,X
  996:          pMsgOut->msgData.setReq.pibAttribute = gMPibAutoRequest_c;
  00b9 a642     [2]             LDA   #66
  00bb e701     [3]             STA   1,X
  997:          pMsgOut->msgData.setReq.pibAttributeValue = &value;
  00bd 95       [2]             TSX   
  00be af0a     [2]             AIX   #10
  00c0 9f       [1]             TXA   
  00c1 8b       [2]             PSHH  
  00c2 9efe04   [5]             LDHX  4,SP
  00c5 e703     [3]             STA   3,X
  00c7 86       [3]             PULA  
  00c8 e702     [3]             STA   2,X
  998:          /* Get/Set/Reset Request messages are NOT freed by the MLME. */
  999:          (void)MSG_Send(NWK_MLME, pMsgOut);
  00ca ac000000 [8]             CALL  NWK_MLME_SapHandler
 1000:          
 1001:          /* Since we are going to receive data from the coordinator 
 1002:             using automatic polling we must synchronize to the beacon
 1003:             and keep tracking it. Before synchronizing it is required
 1004:             that the MAC PIB PAN ID, and the MAC PIB coordinator
 1005:             address is set. */
 1006:          pMsgOut->msgData.setReq.pibAttribute = gMPibPanId_c;
  00ce 9efe03   [5]             LDHX  3,SP
  00d1 a650     [2]             LDA   #80
  00d3 e701     [3]             STA   1,X
 1007:          pMsgOut->msgData.setReq.pibAttributeValue = mCoordInfo.coordPanId;
  00d5 a608     [2]             LDA   @mCoordInfo:8:MSB
  00d7 e702     [3]             STA   2,X
  00d9 a608     [2]             LDA   @mCoordInfo:8
  00db e703     [3]             STA   3,X
 1008:          /* Get/Set/Reset Request messages are NOT freed by the MLME. */
 1009:          (void)MSG_Send(NWK_MLME, pMsgOut);
  00dd ac000000 [8]             CALL  NWK_MLME_SapHandler
 1010:  
 1011:          /* Set coordinator address PIB attribute according the the 
 1012:             address mode of the coordinator (short or long address). */
 1013:          pMsgOut->msgData.setReq.pibAttribute = 
 1014:            mCoordInfo.coordAddrMode == gAddrModeShort_c ? gMPibCoordShortAddress_c :
  00e1 c6000a   [4]             LDA   mCoordInfo:10
  00e4 410203   [4]             CBEQA #2,LEA ;abs = 00ea
 1015:                                                          gMPibCoordExtendedAddress_c;
  00e7 a64a     [2]             LDA   #74
  00e9 65       [3]             SKIP2 LEC ;abs = 00ec
  00ea          LEA:    
  00ea a64b     [2]             LDA   #75
  00ec          LEC:    
  00ec 9efe03   [5]             LDHX  3,SP
  00ef e701     [3]             STA   1,X
 1016:          pMsgOut->msgData.setReq.pibAttributeValue = mCoordInfo.coordAddress;
  00f1 a600     [2]             LDA   @mCoordInfo:MSB
  00f3 e702     [3]             STA   2,X
  00f5 a600     [2]             LDA   @mCoordInfo
  00f7 e703     [3]             STA   3,X
 1017:          /* Get/Set/Reset Request messages are NOT freed by the MLME. */
 1018:          (void)MSG_Send(NWK_MLME, pMsgOut);
  00f9 ac000000 [8]             CALL  NWK_MLME_SapHandler
 1019:  
 1020:  
 1021:          /* Set macBeaconOrder PIB attribute according to the 
 1022:             value found in beacon.*/
 1023:          mBeaconOrder = (mCoordInfo.superFrameSpec[0] & 0x0F);   
  00fd c6000f   [4]             LDA   mCoordInfo:15
  0100 a40f     [2]             AND   #15
  0102 95       [2]             TSX   
  0103 e70b     [3]             STA   11,X
 1024:          pMsgOut->msgData.setReq.pibAttribute = gMPibBeaconOrder_c;                                             
  0105 9efe03   [5]             LDHX  3,SP
  0108 a647     [2]             LDA   #71
  010a e701     [3]             STA   1,X
 1025:          pMsgOut->msgData.setReq.pibAttributeValue = &mBeaconOrder;
  010c 95       [2]             TSX   
  010d af0b     [2]             AIX   #11
  010f 9f       [1]             TXA   
  0110 8b       [2]             PSHH  
  0111 9efe04   [5]             LDHX  4,SP
  0114 e703     [3]             STA   3,X
  0116 86       [3]             PULA  
  0117 e702     [3]             STA   2,X
 1026:          /* Get/Set/Reset Request messages are NOT freed by the MLME. */
 1027:          (void)MSG_Send(NWK_MLME, pMsgOut);
  0119 ac000000 [8]             CALL  NWK_MLME_SapHandler
 1028:  
 1029:          /* Set macSuperFrameOrder PIB attribute according to the 
 1030:             value found in beacon.*/
 1031:          mSuperFrameOrder = (mCoordInfo.superFrameSpec[0] & 0xF0);   
  011d c6000f   [4]             LDA   mCoordInfo:15
  0120 a4f0     [2]             AND   #-16
  0122 95       [2]             TSX   
  0123 e70c     [3]             STA   12,X
 1032:          pMsgOut->msgData.setReq.pibAttribute = gMPibSuperFrameOrder_c;                                             
  0125 9efe03   [5]             LDHX  3,SP
  0128 a654     [2]             LDA   #84
  012a e701     [3]             STA   1,X
 1033:          pMsgOut->msgData.setReq.pibAttributeValue = &mSuperFrameOrder;
  012c 95       [2]             TSX   
  012d af0c     [2]             AIX   #12
  012f 9f       [1]             TXA   
  0130 8b       [2]             PSHH  
  0131 9efe04   [5]             LDHX  4,SP
  0134 e703     [3]             STA   3,X
  0136 86       [3]             PULA  
  0137 e702     [3]             STA   2,X
 1034:          /* Get/Set/Reset Request messages are NOT freed by the MLME. */
 1035:          (void)MSG_Send(NWK_MLME, pMsgOut);  
  0139 ac000000 [8]             CALL  NWK_MLME_SapHandler
 1036:          
 1037:          /* Now send the MLME-Sync Request. We choose to let the MAC track
 1038:             the beacons on the logical channel obtained by the active scan.*/
 1039:          pMsgOut->msgType = gMlmeSyncReq_c;
  013d 9efe03   [5]             LDHX  3,SP
  0140 a60b     [2]             LDA   #11
  0142 f7       [2]             STA   ,X
 1040:          pMsgOut->msgData.syncReq.trackBeacon = TRUE;
  0143 a601     [2]             LDA   #1
  0145 e702     [3]             STA   2,X
 1041:          pMsgOut->msgData.syncReq.logicalChannel = mCoordInfo.logicalChannel;
  0147 c6000b   [4]             LDA   mCoordInfo:11
  014a e701     [3]             STA   1,X
 1042:          (void)MSG_Send(NWK_MLME, pMsgOut);
  014c ac000000 [8]             CALL  NWK_MLME_SapHandler
  0150          L150:   
 1043:        }
 1044:      }
 1045:    }
 1046:    
 1047:    return rc;
  0150 95       [2]             TSX   
  0151 e606     [3]             LDA   6,X
 1048:  }
  0153 a70d     [2]             AIS   #13
  0155 8d       [7]             RTC   
 1049:  
 1050:  
 1051:  /******************************************************************************
 1052:  * The App_SendAssociateRequest(void) will create an Associate Request message
 1053:  * and send it to the coordinator it wishes to associate to. The function uses
 1054:  * information gained about the coordinator during the scan procedure.
 1055:  *
 1056:  * The function may return either of the following values:
 1057:  *   errorNoError:          The Associate Request message was sent successfully.
 1058:  *   errorInvalidParameter: The MLME service access point rejected the
 1059:  *                          message due to an invalid parameter.
 1060:  *   errorAllocFailed:      A message buffer could not be allocated.
 1061:  *
 1062:  ******************************************************************************/
 1063:  static uint8_t App_SendAssociateRequest(void)
 1064:  {
  0000 a7fc     [2]             AIS   #-4
 1065:    mlmeMessage_t *pMsg;
 1066:    mlmeAssociateReq_t *pAssocReq;
 1067:  
 1068:    UartUtil_Print("Sending the MLME-Associate Request message to the MAC...", gAllowToBlock_d);
  0002 450000   [3]             LDHX  @"Sending the MLME-Associate Request message to the MAC..."
  0005 ac000077 [8]             CALL  App_SendAssociateRequest:119
 1069:    
 1070:    /* Allocate a message for the MLME message. */
 1071:    pMsg = MSG_AllocType(mlmeMessage_t);
  0009 a60f     [2]             LDA   #15
  000b ac000000 [8]             CALL  MM_Alloc
  000f 9eff03   [5]             STHX  3,SP
 1072:    if(pMsg != NULL)
  0012 2757     [3]             BEQ   L6B ;abs = 006b
 1073:    {
 1074:      /* This is a MLME-ASSOCIATE.req command. */
 1075:      pMsg->msgType = gMlmeAssociateReq_c;
  0014 7f       [4]             CLR   ,X
 1076:      
 1077:      /* Create the Associate request message data. */
 1078:      pAssocReq = &pMsg->msgData.associateReq;
  0015 af01     [2]             AIX   #1
 1079:   
 1080:      /* Use the coordinator info we got from the Active Scan. */
 1081:      FLib_MemCpy(pAssocReq->coordAddress, mCoordInfo.coordAddress, 8);
  0017 89       [2]             PSHX  
  0018 8b       [2]             PSHH  
  0019 9eff03   [5]             STHX  3,SP
  001c 450000   [3]             LDHX  @mCoordInfo
  001f a608     [2]             LDA   #8
  0021 ac000000 [8]             CALL  FLib_MemCpy
  0025 a702     [2]             AIS   #2
 1082:      FLib_MemCpy(pAssocReq->coordPanId,   mCoordInfo.coordPanId, 2);
  0027 9efe01   [5]             LDHX  1,SP
  002a af08     [2]             AIX   #8
  002c 89       [2]             PSHX  
  002d 8b       [2]             PSHH  
  002e 450008   [3]             LDHX  @mCoordInfo:8
  0031 a602     [2]             LDA   #2
  0033 ac000000 [8]             CALL  FLib_MemCpy
  0037 a702     [2]             AIS   #2
 1083:      pAssocReq->coordAddrMode      = mCoordInfo.coordAddrMode;
  0039 c6000a   [4]             LDA   mCoordInfo:10
  003c 9efe01   [5]             LDHX  1,SP
  003f e70a     [3]             STA   10,X
 1084:      pAssocReq->logicalChannel     = mCoordInfo.logicalChannel;
  0041 c6000b   [4]             LDA   mCoordInfo:11
  0044 e70b     [3]             STA   11,X
 1085:  #ifndef gMAC2006_d
 1086:      pAssocReq->securityEnable     = FALSE;
  0046 6f0c     [5]             CLR   12,X
 1087:  #else
 1088:  	pAssocReq->securityLevel = 0;
 1089:  #endif //gMAC2006_d	
 1090:      /* We want the coordinator to assign a short address to us. */
 1091:      pAssocReq->capabilityInfo     = gCapInfoAllocAddr_c;
  0048 a680     [2]             LDA   #-128
  004a e70d     [3]             STA   13,X
 1092:        
 1093:      /* Send the Associate Request to the MLME. */
 1094:      if(MSG_Send(NWK_MLME, pMsg) == gSuccess_c)
  004c 9efe03   [5]             LDHX  3,SP
  004f ac000000 [8]             CALL  NWK_MLME_SapHandler
  0053 4d       [1]             TSTA  
  0054 260a     [3]             BNE   L60 ;abs = 0060
 1095:      {
 1096:        UartUtil_Print("Done\n\r", gAllowToBlock_d);
  0056 450000   [3]             LDHX  @"Done\012\015"
  0059 ac000077 [8]             CALL  App_SendAssociateRequest:119
 1097:        return errorNoError;
  005d 4f       [1]             CLRA  
  005e 2014     [3]             BRA   L74 ;abs = 0074
  0060          L60:    
 1098:      }
 1099:      else
 1100:      {
 1101:        /* One or more parameters in the message were invalid. */
 1102:        UartUtil_Print("Invalid parameter!\n\r", gAllowToBlock_d);
  0060 450000   [3]             LDHX  @"Invalid parameter!\012\015"
  0063 ac000077 [8]             CALL  App_SendAssociateRequest:119
 1103:        return errorInvalidParameter;
  0067 a605     [2]             LDA   #5
  0069 2009     [3]             BRA   L74 ;abs = 0074
  006b          L6B:    
 1104:      }
 1105:    }
 1106:    else
 1107:    {
 1108:      /* Allocation of a message buffer failed - 
 1109:         the state machine will call us again. */
 1110:      UartUtil_Print("Message allocation failed - retrying...\n\r", gAllowToBlock_d);
  006b 450000   [3]             LDHX  @"Message allocation failed - retrying...\012\015"
  006e ac000077 [8]             CALL  App_SendAssociateRequest:119
 1111:      return errorAllocFailed;
  0072 a604     [2]             LDA   #4
  0074          L74:    
 1112:    }
 1113:  }
  0074 a704     [2]             AIS   #4
  0076 8d       [7]             RTC   
  0077          L77:    
  0077 a601     [2]             LDA   #1
  0079 ac000000 [8]             CALL  UartUtil_Print
  007d 8d       [7]             RTC   
 1114:  
 1115:  /******************************************************************************
 1116:  * The App_HandleAssociateConfirm(nwkMessage_t *pMsg) function will handle the
 1117:  * Associate confirm message received from the MLME when the Association
 1118:  * procedure has completed. The message contains the short address that the
 1119:  * coordinator has assigned to us. This address is 0xfffe if we did not specify
 1120:  * the gCapInfoAllocAddr_c flag in the capability info field of the Associate
 1121:  * request. The address and address mode are saved in global variables. They
 1122:  * will be used in the next demo application when sending data.
 1123:  *
 1124:  ******************************************************************************/
 1125:  static uint8_t App_HandleAssociateConfirm(nwkMessage_t *pMsg)
 1126:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  0002 8b       [2]             PSHH  
 1127:  
 1128:  	mlmeMessage_t *pMsg_;
 1129:  	uint8_t ret;
 1130:  	uint8_t boolFlag;
 1131:  
 1132:  	
 1133:    /* This is our own extended address (MAC address). It cannot be modified. */
 1134:    extern uint8_t aExtendedAddress[8];
 1135:    
 1136:    /* If the coordinator assigns a short address of 0xfffe then,
 1137:       that means we must use our own extended address in all
 1138:       communications with the coordinator. Otherwise, we use
 1139:       the short address assigned to us. */
 1140:    if ( pMsg->msgData.associateCnf.status == gSuccess_c) 
  0003 6d03     [4]             TST   3,X
  0005 2663     [3]             BNE   L6A ;abs = 006a
 1141:    {
 1142:  
 1143:      if( (pMsg->msgData.associateCnf.assocShortAddress[0] >= 0xFE) && 
  0007 e601     [3]             LDA   1,X
  0009 a1fe     [2]             CMP   #-2
  000b 2516     [3]             BCS   L23 ;abs = 0023
 1144:          (pMsg->msgData.associateCnf.assocShortAddress[1] == 0xFF) )
  000d e602     [3]             LDA   2,X
  000f 4c       [1]             INCA  
  0010 2611     [3]             BNE   L23 ;abs = 0023
 1145:      {
 1146:        mAddrMode = gAddrModeLong_c;
  0012 a603     [2]             LDA   #3
  0014 c70000   [4]             STA   mAddrMode
 1147:        FLib_MemCpy(maMyAddress, (void *)aExtendedAddress, 8);
  0017 450000   [3]             LDHX  @maMyAddress
  001a 89       [2]             PSHX  
  001b 8b       [2]             PSHH  
  001c 450000   [3]             LDHX  @aExtendedAddress
  001f a608     [2]             LDA   #8
 1148:      }
  0021 200f     [3]             BRA   L32 ;abs = 0032
  0023          L23:    
 1149:      else
 1150:      {
 1151:        mAddrMode = gAddrModeShort_c;
  0023 a602     [2]             LDA   #2
  0025 c70000   [4]             STA   mAddrMode
 1152:        FLib_MemCpy(maMyAddress, pMsg->msgData.associateCnf.assocShortAddress, 2);
  0028 450000   [3]             LDHX  @maMyAddress
  002b 89       [2]             PSHX  
  002c 8b       [2]             PSHH  
  002d 9efe04   [5]             LDHX  4,SP
  0030 af01     [2]             AIX   #1
  0032          L32:    
  0032 ac000000 [8]             CALL  FLib_MemCpy
  0036 a702     [2]             AIS   #2
 1153:      }
 1154:      
 1155:      pMsg_=MSG_AllocType(mlmeMessage_t);
  0038 a60f     [2]             LDA   #15
  003a ac000000 [8]             CALL  MM_Alloc
 1156:      if (pMsg_ !=NULL)
  003e 650000   [3]             CPHX  #0
  0041 2725     [3]             BEQ   L68 ;abs = 0068
 1157:      {
 1158:      	pMsg_->msgType=gMlmeSetReq_c;
  0043 a609     [2]             LDA   #9
  0045 f7       [2]             STA   ,X
 1159:      	pMsg_->msgData.setReq.pibAttribute=gMPibRxOnWhenIdle_c;
  0046 a652     [2]             LDA   #82
  0048 e701     [3]             STA   1,X
 1160:      	boolFlag=TRUE;
  004a a601     [2]             LDA   #1
 1161:      	pMsg_->msgData.setReq.pibAttributeValue=&boolFlag;
  004c 89       [2]             PSHX  
  004d 8b       [2]             PSHH  
  004e 95       [2]             TSX   
  004f e702     [3]             STA   2,X
  0051 af02     [2]             AIX   #2
  0053 8b       [2]             PSHH  
  0054 9ee602   [4]             LDA   2,SP
  0057 87       [2]             PSHA  
  0058 8a       [3]             PULH  
  0059 9f       [1]             TXA   
  005a 9eee03   [4]             LDX   3,SP
  005d e703     [3]             STA   3,X
  005f 86       [3]             PULA  
  0060 e702     [3]             STA   2,X
 1162:      	ret=MSG_Send(NWK_MLME,pMsg_);
  0062 ac000000 [8]             CALL  NWK_MLME_SapHandler
  0066 a702     [2]             AIS   #2
  0068          L68:    
 1163:      }
 1164:      
 1165:      return gSuccess_c;
  0068 4f       [1]             CLRA  
  0069 65       [3]             SKIP2 L6C ;abs = 006c
  006a          L6A:    
 1166:    } 
 1167:    
 1168:    else 
 1169:    {
 1170:    return pMsg->msgData.associateCnf.status; 
  006a e603     [3]             LDA   3,X
  006c          L6C:    
 1171:    }
 1172:  }
  006c a703     [2]             AIS   #3
  006e 8d       [7]             RTC   
 1173:  
 1174:  
 1175:  /******************************************************************************
 1176:  * The App_HandleMcpsInput(mcpsToNwkMessage_t *pMsgIn) function will handle 
 1177:  * messages from the MCPS, e.g. Data Confirm, and Data Indication.
 1178:  *
 1179:  ******************************************************************************/
 1180:  static void App_HandleMcpsInput(mcpsToNwkMessage_t *pMsgIn)
 1181:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  0002 a7fe     [2]             AIS   #-2
 1182:    switch(pMsgIn->msgType)
  0004 f6       [3]             LDA   ,X
  0005 2704     [3]             BEQ   LB ;abs = 000b
  0007 4b1f     [4]             DBNZA L28 ;abs = 0028
  0009 200b     [3]             BRA   L16 ;abs = 0016
  000b          LB:     
 1183:    {
 1184:      /* The MCPS-Data confirm is sent by the MAC to the network 
 1185:         or application layer when data has been sent. */
 1186:    case gMcpsDataCnf_c:
 1187:      if(mcPendingPackets)
  000b c60000   [4]             LDA   mcPendingPackets
  000e 2718     [3]             BEQ   L28 ;abs = 0028
 1188:        mcPendingPackets--;
  0010 450000   [3]             LDHX  @mcPendingPackets
  0013 7a       [4]             DEC   ,X
  0014 2012     [3]             BRA   L28 ;abs = 0028
  0016          L16:    
 1189:      break;
 1190:  
 1191:    case gMcpsDataInd_c:
 1192:      /* Copy the received data to the UART. */
 1193:      UartUtil_Tx(pMsgIn->msgData.dataInd.pMsdu, pMsgIn->msgData.dataInd.msduLength);
  0016 9ece1b   [5]             LDHX  27,X
  0019 9eff01   [5]             STHX  1,SP
  001c 9efe03   [5]             LDHX  3,SP
  001f e617     [3]             LDA   23,X
  0021 9efe01   [5]             LDHX  1,SP
  0024 ac000000 [8]             CALL  UartUtil_Tx
  0028          L28:    
 1194:  
 1195:      break;
 1196:    }
 1197:  }
  0028 a704     [2]             AIS   #4
  002a 8d       [7]             RTC   
 1198:  
 1199:  
 1200:  /* added by ueda */
 1201:  static void Router_HandleMcpsInput(mcpsToNwkMessage_t *pMsgIn)
 1202:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  0002 a7fe     [2]             AIS   #-2
 1203:  	
 1204:    switch(pMsgIn->msgType)
  0004 f6       [3]             LDA   ,X
  0005 2705     [3]             BEQ   LC ;abs = 000c
  0007 41010d   [4]             CBEQA #1,L17 ;abs = 0017
  000a 2073     [3]             BRA   L7F ;abs = 007f
  000c          LC:     
 1205:    {
 1206:      /* The MCPS-Data confirm is sent by the MAC to the network 
 1207:         or application layer when data has been sent. */
 1208:    case gMcpsDataCnf_c:
 1209:      if(mcPendingPackets)
  000c c60000   [4]             LDA   mcPendingPackets
  000f 276e     [3]             BEQ   L7F ;abs = 007f
 1210:        mcPendingPackets--;
  0011 450000   [3]             LDHX  @mcPendingPackets
  0014 7a       [4]             DEC   ,X
  0015 2068     [3]             BRA   L7F ;abs = 007f
  0017          L17:    
 1211:      break;
 1212:  
 1213:    case gMcpsDataInd_c:
 1214:      /* Copy the received data to the UART. */
 1215:      UartUtil_Tx(pMsgIn->msgData.dataInd.pMsdu, pMsgIn->msgData.dataInd.msduLength);
  0017 9ece1b   [5]             LDHX  27,X
  001a 9eff01   [5]             STHX  1,SP
  001d 9efe03   [5]             LDHX  3,SP
  0020 e617     [3]             LDA   23,X
  0022 9efe01   [5]             LDHX  1,SP
  0025 ac000000 [8]             CALL  UartUtil_Tx
 1216:      UartUtil_Print("Source NW Addr : ", gAllowToBlock_d);
  0029 450000   [3]             LDHX  @"Source NW Addr : "
  002c ac00008f [8]             CALL  Router_HandleMcpsInput:143
 1217:             UartUtil_PrintHex(&(((mcpsToNwkMessage_t*)pMsgIn)->msgData.dataInd.srcAddr[0]), 2, 0);
  0030 af0c     [2]             AIX   #12
  0032 89       [2]             PSHX  
  0033 8b       [2]             PSHH  
  0034 ae02     [2]             LDX   #2
  0036 4f       [1]             CLRA  
  0037 ac000000 [8]             CALL  UartUtil_PrintHex
  003b a702     [2]             AIS   #2
 1218:             UartUtil_Print("\n\r", gAllowToBlock_d);
  003d 450000   [3]             LDHX  @"\012\015"
  0040 a601     [2]             LDA   #1
  0042 ac000000 [8]             CALL  UartUtil_Print
 1219:  
 1220:             UartUtil_Print("Data:MMA8652(2g: Int2,Float10) \n\rX axis : 0x", gAllowToBlock_d);
  0046 450000   [3]             LDHX  @"Data:MMA8652(2g: Int2,Float10) \012\015X axis : 0x"
  0049 ac00008f [8]             CALL  Router_HandleMcpsInput:143
 1221:             UartUtil_PrintHex(&pMsgIn->msgData.dataInd.pMsdu[1], 2, 1);
  004d 9ece1b   [5]             LDHX  27,X
  0050 af01     [2]             AIX   #1
  0052 ac000082 [8]             CALL  Router_HandleMcpsInput:130
 1222:             UartUtil_Print(" /1024 [g]\n\rY axis : 0x", gAllowToBlock_d);
  0056 450000   [3]             LDHX  @" /1024 [g]\012\015Y axis : 0x"
  0059 ac00008f [8]             CALL  Router_HandleMcpsInput:143
 1223:             UartUtil_PrintHex(&pMsgIn->msgData.dataInd.pMsdu[3], 2, 1);
  005d 9ece1b   [5]             LDHX  27,X
  0060 af03     [2]             AIX   #3
  0062 ac000082 [8]             CALL  Router_HandleMcpsInput:130
 1224:     		UartUtil_Print(" /1024 [g]\n\rZ axis : 0x", gAllowToBlock_d);
  0066 450000   [3]             LDHX  @" /1024 [g]\012\015Z axis : 0x"
  0069 ac00008f [8]             CALL  Router_HandleMcpsInput:143
 1225:     		UartUtil_PrintHex(&pMsgIn->msgData.dataInd.pMsdu[5], 2, 1);
  006d 9ece1b   [5]             LDHX  27,X
  0070 af05     [2]             AIX   #5
  0072 ac000082 [8]             CALL  Router_HandleMcpsInput:130
 1226:     		UartUtil_Print(" /1024 [g]\n\r", gAllowToBlock_d);
  0076 450000   [3]             LDHX  @" /1024 [g]\012\015"
  0079 a601     [2]             LDA   #1
  007b ac000000 [8]             CALL  UartUtil_Print
  007f          L7F:    
 1227:     		//UartUtil_Tx(&pMsgIn->msgData.dataInd.pMsdu[1], 6);
 1228:      //UartUtil_print(pMsgIn->msgData.dataInd.pMsdu, pMsgIn->msgData.dataInd.msduLength);//added by ueda
 1229:      break;
 1230:    }
 1231:  
 1232:  }
  007f a704     [2]             AIS   #4
  0081 8d       [7]             RTC   
  0082          L82:    
  0082 89       [2]             PSHX  
  0083 8b       [2]             PSHH  
  0084 ae02     [2]             LDX   #2
  0086 a601     [2]             LDA   #1
  0088 ac000000 [8]             CALL  UartUtil_PrintHex
  008c a702     [2]             AIS   #2
  008e 8d       [7]             RTC   
  008f          L8F:    
  008f a601     [2]             LDA   #1
  0091 ac000000 [8]             CALL  UartUtil_Print
  0095 9efe06   [5]             LDHX  6,SP
  0098 8d       [7]             RTC   
 1233:  
 1234:  
 1235:  
 1236:  /******************************************************************************
 1237:  * The App_WaitMsg(nwkMessage_t *pMsg, uint8_t msgType) function does not, as
 1238:  * the name implies, wait for a message, thus blocking the execution of the
 1239:  * state machine. Instead the function analyzes the supplied message to 
 1240:  * determine whether or not the message is of the expected type.
 1241:  * The function may return either of the following values:
 1242:  *   errorNoError: The message was of the expected type.
 1243:  *   errorNoMessage: The message pointer is NULL.
 1244:  *   errorWrongConfirm: The message is not of the expected type.
 1245:  *
 1246:  ******************************************************************************/
 1247:  static uint8_t App_WaitMsg(nwkMessage_t *pMsg, uint8_t msgType)
 1248:  {
 1249:    /* Do we have a message? If not, the exit with error code */
 1250:    if(pMsg == NULL)
  0000 650000   [3]             CPHX  #0
  0003 2603     [3]             BNE   L8 ;abs = 0008
 1251:      return errorNoMessage;
  0005 a603     [2]             LDA   #3
  0007 8d       [7]             RTC   
  0008          L8:     
 1252:  
 1253:    /* Is it the expected message type? If not then exit with error code */
 1254:    if(pMsg->msgType != msgType)
  0008 f1       [3]             CMP   ,X
  0009 2703     [3]             BEQ   LE ;abs = 000e
 1255:      return errorWrongConfirm;
  000b a601     [2]             LDA   #1
  000d 8d       [7]             RTC   
  000e          LE:     
 1256:  
 1257:    /* Found the expected message. Return with success code */
 1258:    return errorNoError;
  000e 4f       [1]             CLRA  
 1259:  }
  000f 8d       [7]             RTC   
 1260:  
 1261:  
 1262:  void App_TransmitSensorData(void){
  0000 a7f5     [2]             AIS   #-11
 1263:  	
 1264:  	uint8_t i;
 1265:  
 1266:  	static uint8_t sens_count=0;
 1267:  	static int16_t x_avg=0;
 1268:  	static int16_t y_avg=0;
 1269:  	static int16_t z_avg=0;
 1270:  
 1271:  	uint8_t sens_data[7];
 1272:  
 1273:  	volatile int16_t val;
 1274:  
 1275:  	UartUtil_Print("\n\r-----------------------------------------------\n\r", gAllowToBlock_d); 
  0002 450000   [3]             LDHX  @"\012\015-----------------------------------------------\012\015"
  0005 ac0001b3 [8]             CALL  App_TransmitSensorData:435
 1276:  	for(i=1; i<4; i++){
  0009 a601     [2]             LDA   #1
  000b 95       [2]             TSX   
  000c e701     [3]             STA   1,X
  000e          LE:     
 1277:  		val = MMA8652_CatchSensorData(i);
  000e 95       [2]             TSX   
  000f e601     [3]             LDA   1,X
  0011 ac000000 [8]             CALL  MMA8652_CatchSensorData
  0015 9eff0a   [5]             STHX  10,SP
 1278:  		switch(i){
  0018 95       [2]             TSX   
  0019 e601     [3]             LDA   1,X
  001b a103     [2]             CMP   #3
  001d 2251     [3]             BHI   L70 ;abs = 0070
  001f 410109   [4]             CBEQA #1,L2B ;abs = 002b
  0022 41021b   [4]             CBEQA #2,L40 ;abs = 0040
  0025 a103     [2]             CMP   #3
  0027 2647     [3]             BNE   L70 ;abs = 0070
  0029 202a     [3]             BRA   L55 ;abs = 0055
  002b          L2B:    
 1279:  		case 1:
 1280:  			x_avg = (x_avg * sens_count + val)/(sens_count + 1);
  002b 320000   [5]             LDHX  x_avg
  002e ac0001a4 [8]             CALL  App_TransmitSensorData:420
  0032 89       [2]             PSHX  
  0033 8b       [2]             PSHH  
  0034 ac000181 [8]             CALL  App_TransmitSensorData:385
  0038 960000   [5]             STHX  x_avg
 1281:  			UartUtil_Print("MMA8652(2g: Int2,Float10) \n\rX axis : 0x", gAllowToBlock_d); 
  003b 450000   [3]             LDHX  @"MMA8652(2g: Int2,Float10) \012\015X axis : 0x"
 1282:  			break;
  003e 2028     [3]             BRA   L68 ;abs = 0068
  0040          L40:    
 1283:  		case 2:
 1284:  			y_avg = (y_avg * sens_count + val)/(sens_count + 1);
  0040 320000   [5]             LDHX  y_avg
  0043 ac0001a4 [8]             CALL  App_TransmitSensorData:420
  0047 89       [2]             PSHX  
  0048 8b       [2]             PSHH  
  0049 ac000181 [8]             CALL  App_TransmitSensorData:385
  004d 960000   [5]             STHX  y_avg
 1285:  			UartUtil_Print(" /1024 [g]\n\rY axis : 0x", gAllowToBlock_d);  				
  0050 450000   [3]             LDHX  @" /1024 [g]\012\015Y axis : 0x"
 1286:  			break;
  0053 2013     [3]             BRA   L68 ;abs = 0068
  0055          L55:    
 1287:  		case 3:
 1288:  			z_avg = (z_avg * sens_count + val)/(sens_count + 1);
  0055 320000   [5]             LDHX  z_avg
  0058 ac0001a4 [8]             CALL  App_TransmitSensorData:420
  005c 89       [2]             PSHX  
  005d 8b       [2]             PSHH  
  005e ac000181 [8]             CALL  App_TransmitSensorData:385
  0062 960000   [5]             STHX  z_avg
 1289:  			UartUtil_Print(" /1024 [g]\n\rZ axis : 0x", gAllowToBlock_d);  		
  0065 450000   [3]             LDHX  @" /1024 [g]\012\015Z axis : 0x"
  0068          L68:    
  0068 ac0001b3 [8]             CALL  App_TransmitSensorData:435
 1290:  			break;
  006c a702     [2]             AIS   #2
  006e 2007     [3]             BRA   L77 ;abs = 0077
  0070          L70:    
 1291:  		default:
 1292:  			UartUtil_Print("???????????????", gAllowToBlock_d);  		
  0070 450000   [3]             LDHX  @"???????????????"
  0073 ac0001b3 [8]             CALL  App_TransmitSensorData:435
  0077          L77:    
 1293:  			break;
 1294:  		}
 1295:  		UartUtil_PrintHex((uint8_t *)&val, 2, 1);
  0077 95       [2]             TSX   
  0078 af09     [2]             AIX   #9
  007a 89       [2]             PSHX  
  007b 8b       [2]             PSHH  
  007c ae02     [2]             LDX   #2
  007e a601     [2]             LDA   #1
  0080 ac000000 [8]             CALL  UartUtil_PrintHex
  0084 a702     [2]             AIS   #2
 1296:  		if(i==3){
  0086 95       [2]             TSX   
  0087 e601     [3]             LDA   1,X
  0089 a103     [2]             CMP   #3
  008b 2607     [3]             BNE   L94 ;abs = 0094
 1297:  			UartUtil_Print(" /1024 [g]", gAllowToBlock_d);  					
  008d 450000   [3]             LDHX  @" /1024 [g]"
  0090 ac0001b3 [8]             CALL  App_TransmitSensorData:435
  0094          L94:    
  0094 95       [2]             TSX   
  0095 6c01     [5]             INC   1,X
  0097 e601     [3]             LDA   1,X
  0099 a104     [2]             CMP   #4
  009b 2403     [3]             BCC   LA0 ;abs = 00a0
  009d cc000e   [4]             JMP   LE ;abs = 000e
  00a0          LA0:    
 1298:  		}
 1299:  	}
 1300:  
 1301:  	UartUtil_Print("\n\r-----------------------------------------------\n\r", gAllowToBlock_d); 
  00a0 450000   [3]             LDHX  @"\012\015-----------------------------------------------\012\015"
  00a3 ac0001b3 [8]             CALL  App_TransmitSensorData:435
 1302:  
 1303:  	sens_count++;
  00a7 450000   [3]             LDHX  @sens_count
  00aa 7c       [4]             INC   ,X
 1304:  
 1305:  	if (global_counter>=5){
  00ab c60000   [4]             LDA   global_counter
  00ae a105     [2]             CMP   #5
  00b0 2403     [3]             BCC   LB5 ;abs = 00b5
  00b2 cc017e   [4]             JMP   L17E ;abs = 017e
  00b5          LB5:    
 1306:  		global_counter=0;
  00b5 4f       [1]             CLRA  
  00b6 c70000   [4]             STA   global_counter
 1307:  
 1308:  		sens_data[0]=0x81;
  00b9 a681     [2]             LDA   #-127
  00bb 95       [2]             TSX   
  00bc e702     [3]             STA   2,X
 1309:  		sens_data[1]=(x_avg >> 8) & 0xFF;
  00be c60000   [4]             LDA   x_avg
  00c1 e703     [3]             STA   3,X
 1310:  		sens_data[2]=x_avg & 0xFF;
  00c3 c60001   [4]             LDA   x_avg:1
  00c6 e704     [3]             STA   4,X
 1311:  		sens_data[3]=(y_avg >> 8) & 0xFF;
  00c8 c60000   [4]             LDA   y_avg
  00cb e705     [3]             STA   5,X
 1312:  		sens_data[4]=y_avg & 0xFF;
  00cd c60001   [4]             LDA   y_avg:1
  00d0 e706     [3]             STA   6,X
 1313:  		sens_data[5]=(z_avg >> 8) & 0xFF;
  00d2 c60000   [4]             LDA   z_avg
  00d5 e707     [3]             STA   7,X
 1314:  		sens_data[6]=z_avg & 0xFF;
  00d7 c60001   [4]             LDA   z_avg:1
  00da e708     [3]             STA   8,X
 1315:  
 1316:  		UartUtil_Print("\n\r***************Average*************\n\r", gAllowToBlock_d); 
  00dc 450000   [3]             LDHX  @"\012\015***************Average*************\012\015"
  00df ac0001b3 [8]             CALL  App_TransmitSensorData:435
 1317:  
 1318:  		for(i=1; i<4; i++){
  00e3 a601     [2]             LDA   #1
  00e5 95       [2]             TSX   
  00e6 e701     [3]             STA   1,X
  00e8          LE8:    
 1319:  			switch(i){			
  00e8 95       [2]             TSX   
  00e9 e601     [3]             LDA   1,X
  00eb a103     [2]             CMP   #3
  00ed 221b     [3]             BHI   L10A ;abs = 010a
  00ef 410109   [4]             CBEQA #1,LFB ;abs = 00fb
  00f2 41020b   [4]             CBEQA #2,L100 ;abs = 0100
  00f5 a103     [2]             CMP   #3
  00f7 2611     [3]             BNE   L10A ;abs = 010a
  00f9 200a     [3]             BRA   L105 ;abs = 0105
  00fb          LFB:    
 1320:  			case 1:
 1321:  				UartUtil_Print("MMA8652(2g: Int2,Float10) \n\rX axis : 0x", gAllowToBlock_d); 
  00fb 450000   [3]             LDHX  @"MMA8652(2g: Int2,Float10) \012\015X axis : 0x"
 1322:  				break;
  00fe 200d     [3]             BRA   L10D ;abs = 010d
  0100          L100:   
 1323:  			case 2:
 1324:  				UartUtil_Print(" /1024 [g]\n\rY axis : 0x", gAllowToBlock_d);  
  0100 450000   [3]             LDHX  @" /1024 [g]\012\015Y axis : 0x"
 1325:  				break;
  0103 2008     [3]             BRA   L10D ;abs = 010d
  0105          L105:   
 1326:  			case 3:
 1327:  				UartUtil_Print(" /1024 [g]\n\rZ axis : 0x", gAllowToBlock_d);  		
  0105 450000   [3]             LDHX  @" /1024 [g]\012\015Z axis : 0x"
 1328:  				break;
  0108 2003     [3]             BRA   L10D ;abs = 010d
  010a          L10A:   
 1329:  			default:
 1330:  				UartUtil_Print("???????????????", gAllowToBlock_d);  		
  010a 450000   [3]             LDHX  @"???????????????"
  010d          L10D:   
  010d ac0001b3 [8]             CALL  App_TransmitSensorData:435
 1331:  				break;
 1332:  			}//switch(i){	 	
 1333:  
 1334:  			UartUtil_PrintHex((uint8_t *)&sens_data[2*i-1], 2, 1); 	
  0111 95       [2]             TSX   
  0112 e601     [3]             LDA   1,X
  0114 48       [1]             LSLA  
  0115 af02     [2]             AIX   #2
  0117 4a       [1]             DECA  
  0118 9ee701   [4]             STA   1,SP
  011b 9f       [1]             TXA   
  011c 9eeb01   [4]             ADD   1,SP
  011f 87       [2]             PSHA  
  0120 8b       [2]             PSHH  
  0121 86       [3]             PULA  
  0122 a900     [2]             ADC   #0
  0124 87       [2]             PSHA  
  0125 ae02     [2]             LDX   #2
  0127 a601     [2]             LDA   #1
  0129 ac000000 [8]             CALL  UartUtil_PrintHex
  012d a702     [2]             AIS   #2
 1335:  
 1336:  			if(i==3){
  012f 95       [2]             TSX   
  0130 e601     [3]             LDA   1,X
  0132 a103     [2]             CMP   #3
  0134 2607     [3]             BNE   L13D ;abs = 013d
 1337:  				UartUtil_Print(" /1024 [g]", gAllowToBlock_d);  					
  0136 450000   [3]             LDHX  @" /1024 [g]"
  0139 ac0001b3 [8]             CALL  App_TransmitSensorData:435
  013d          L13D:   
  013d 95       [2]             TSX   
  013e 6c01     [5]             INC   1,X
  0140 e601     [3]             LDA   1,X
  0142 a104     [2]             CMP   #4
  0144 25a2     [3]             BCS   LE8 ;abs = 00e8
 1338:  			}
 1339:  
 1340:  		} //for(i=1; i<4; i++){
 1341:  
 1342:  
 1343:  		UartUtil_Print("\n\r*********************************\n\r", gAllowToBlock_d); 		
  0146 450000   [3]             LDHX  @"\012\015*********************************\012\015"
  0149 ac0001b3 [8]             CALL  App_TransmitSensorData:435
 1344:  
 1345:  
 1346:  		GenandTransData(7, sens_data, (void*)mCoordInfo.coordAddress);
  014d a607     [2]             LDA   #7
  014f 87       [2]             PSHA  
  0150 95       [2]             TSX   
  0151 af03     [2]             AIX   #3
  0153 89       [2]             PSHX  
  0154 8b       [2]             PSHH  
  0155 450000   [3]             LDHX  @mCoordInfo
  0158 ac000000 [8]             CALL  GenandTransData
  015c a703     [2]             AIS   #3
 1347:  		sens_count=0;
  015e 4f       [1]             CLRA  
  015f c70000   [4]             STA   sens_count
 1348:  		for(i=0;i<7;i++){
  0162 95       [2]             TSX   
  0163 6f01     [5]             CLR   1,X
  0165          L165:   
 1349:  			sens_data[i]=0;
  0165 95       [2]             TSX   
  0166 af02     [2]             AIX   #2
  0168 9f       [1]             TXA   
  0169 9eeb02   [4]             ADD   2,SP
  016c 87       [2]             PSHA  
  016d 8b       [2]             PSHH  
  016e 86       [3]             PULA  
  016f a900     [2]             ADC   #0
  0171 87       [2]             PSHA  
  0172 8a       [3]             PULH  
  0173 88       [3]             PULX  
  0174 7f       [4]             CLR   ,X
  0175 95       [2]             TSX   
  0176 6c01     [5]             INC   1,X
  0178 e601     [3]             LDA   1,X
  017a a107     [2]             CMP   #7
  017c 25e7     [3]             BCS   L165 ;abs = 0165
  017e          L17E:   
 1350:  		}
 1351:  	}
 1352:  	
 1353:  }
  017e a70b     [2]             AIS   #11
  0180 8d       [7]             RTC   
  0181          L181:   
  0181 9efe0f   [5]             LDHX  15,SP
  0184 9f       [1]             TXA   
  0185 8b       [2]             PSHH  
  0186 95       [2]             TSX   
  0187 eb05     [3]             ADD   5,X
  0189 e705     [3]             STA   5,X
  018b 86       [3]             PULA  
  018c e904     [3]             ADC   4,X
  018e ee06     [3]             LDX   6,X
  0190 8c       [1]             CLRH  
  0191 af01     [2]             AIX   #1
  0193 9ee706   [4]             STA   6,SP
  0196 9ee605   [4]             LDA   5,SP
  0199 87       [2]             PSHA  
  019a 9ee607   [4]             LDA   7,SP
  019d 87       [2]             PSHA  
  019e cd0000   [6]             JSR   _IDIVS_STAR08
  01a1 a702     [2]             AIS   #2
  01a3 8d       [7]             RTC   
  01a4          L1A4:   
  01a4 89       [2]             PSHX  
  01a5 8b       [2]             PSHH  
  01a6 ce0000   [4]             LDX   sens_count
  01a9 8c       [1]             CLRH  
  01aa 9eef06   [4]             STX   6,SP
  01ad cd0000   [6]             JSR   _IMUL_STAR08
  01b0 a702     [2]             AIS   #2
  01b2 8d       [7]             RTC   
  01b3          L1B3:   
  01b3 a601     [2]             LDA   #1
  01b5 ac000000 [8]             CALL  UartUtil_Print
  01b9 8d       [7]             RTC   
 1354:  
 1355:  static void GenandTransData(uint8_t Length, uint8_t* pTxData, uint8_t* dest_addr){
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
 1356:   
 1357:  	/* Use multi buffering for increased TX performance. It does not really
 1358:       have any effect at a UART baud rate of 19200bps but serves as an
 1359:       example of how the throughput may be improved in a real-world 
 1360:       application where the data rate is of concern. */
 1361:    if( (mcPendingPackets < mDefaultValueOfMaxPendingDataPackets_c) && (mpPacket == NULL) ) 
  0002 c60000   [4]             LDA   mcPendingPackets
  0005 a102     [2]             CMP   #2
  0007 240e     [3]             BCC   L17 ;abs = 0017
  0009 320000   [5]             LDHX  mpPacket
  000c 2609     [3]             BNE   L17 ;abs = 0017
 1362:    {
 1363:      /* If the maximum number of pending data buffes is below maximum limit 
 1364:         and we do not have a data buffer already then allocate one. */
 1365:      mpPacket = MSG_Alloc(gMaxRxTxDataLength_c);
  000e a68d     [2]             LDA   #-115
  0010 ac000000 [8]             CALL  MM_Alloc
  0014 960000   [5]             STHX  mpPacket
  0017          L17:    
 1366:    }
 1367:    
 1368:    if(mpPacket != NULL)
  0017 320000   [5]             LDHX  mpPacket
  001a 277e     [3]             BEQ   L9A ;abs = 009a
 1369:    {
 1370:      /* get data from UART */        
 1371:        mpPacket->msgData.dataReq.pMsdu = (uint8_t*)(&(mpPacket->msgData.dataReq.pMsdu)) + sizeof(uint8_t*);
  001c af1c     [2]             AIX   #28
  001e 9f       [1]             TXA   
  001f 8b       [2]             PSHH  
  0020 320000   [5]             LDHX  mpPacket
  0023 e71b     [3]             STA   27,X
  0025 86       [3]             PULA  
  0026 e71a     [3]             STA   26,X
 1372:        FLib_MemCpy(mpPacket->msgData.dataReq.pMsdu, (uint8_t*) pTxData, Length);
  0028 9ece1a   [5]             LDHX  26,X
  002b 89       [2]             PSHX  
  002c 8b       [2]             PSHH  
  002d 9efe08   [5]             LDHX  8,SP
  0030 9ee60a   [4]             LDA   10,SP
  0033 ac000000 [8]             CALL  FLib_MemCpy
  0037 a702     [2]             AIS   #2
 1373:        /* Data was available in the UART receive buffer. Now create an
 1374:           MCPS-Data Request message containing the UART data. */
 1375:        mpPacket->msgType = gMcpsDataReq_c;
  0039 320000   [5]             LDHX  mpPacket
  003c 7f       [4]             CLR   ,X
 1376:        /* Create the header using coordinator information gained during 
 1377:           the scan procedure. Also use the short address we were assigned
 1378:           by the coordinator during association. */
 1379:        FLib_MemCpy(mpPacket->msgData.dataReq.dstAddr,dest_addr, 8);
  003d af01     [2]             AIX   #1
  003f 89       [2]             PSHX  
  0040 8b       [2]             PSHH  
  0041 9efe03   [5]             LDHX  3,SP
  0044 a608     [2]             LDA   #8
  0046 ac000000 [8]             CALL  FLib_MemCpy
  004a a702     [2]             AIS   #2
 1380:        FLib_MemCpy(mpPacket->msgData.dataReq.srcAddr, maMyAddress, 8);
  004c 320000   [5]             LDHX  mpPacket
  004f af0c     [2]             AIX   #12
  0051 89       [2]             PSHX  
  0052 8b       [2]             PSHH  
  0053 450000   [3]             LDHX  @maMyAddress
  0056 a608     [2]             LDA   #8
  0058 ac000000 [8]             CALL  FLib_MemCpy
  005c a702     [2]             AIS   #2
 1381:        FLib_MemCpy(mpPacket->msgData.dataReq.dstPanId, mCoordInfo.coordPanId, 2);
  005e 320000   [5]             LDHX  mpPacket
  0061 af09     [2]             AIX   #9
  0063 ac00009d [8]             CALL  GenandTransData:157
 1382:        FLib_MemCpy(mpPacket->msgData.dataReq.srcPanId, mCoordInfo.coordPanId, 2);
  0067 320000   [5]             LDHX  mpPacket
  006a af14     [2]             AIX   #20
  006c ac00009d [8]             CALL  GenandTransData:157
 1383:        mpPacket->msgData.dataReq.dstAddrMode = mCoordInfo.coordAddrMode;
  0070 c6000a   [4]             LDA   mCoordInfo:10
  0073 320000   [5]             LDHX  mpPacket
  0076 e70b     [3]             STA   11,X
 1384:        mpPacket->msgData.dataReq.srcAddrMode = mAddrMode;
  0078 c60000   [4]             LDA   mAddrMode
  007b e716     [3]             STA   22,X
 1385:        mpPacket->msgData.dataReq.msduLength = Length;
  007d 9ee608   [4]             LDA   8,SP
  0080 e717     [3]             STA   23,X
 1386:        /* Request MAC level acknowledgement of the data packet */
 1387:        mpPacket->msgData.dataReq.txOptions = 0;
  0082 6f19     [5]             CLR   25,X
 1388:        /* Give the data packet a handle. The handle is
 1389:           returned in the MCPS-Data Confirm message. */
 1390:        mpPacket->msgData.dataReq.msduHandle = mMsduHandle++;
  0084 c60000   [4]             LDA   mMsduHandle
  0087 e718     [3]             STA   24,X
  0089 4c       [1]             INCA  
  008a c70000   [4]             STA   mMsduHandle
 1391:  #ifdef gMAC2006_d
 1392:  	  mpPacket->msgData.dataReq.securityLevel = 0;
 1393:  #endif //gMAC2006_d	  
 1394:        
 1395:        /* Send the Data Request to the MCPS */
 1396:        (void)MSG_Send(NWK_MCPS, mpPacket);
  008d ac000000 [8]             CALL  NWK_MCPS_SapHandler
 1397:        /* Prepare for another data buffer */
 1398:        mpPacket = NULL;
  0091 5f       [1]             CLRX  
  0092 8c       [1]             CLRH  
  0093 960000   [5]             STHX  mpPacket
 1399:        mcPendingPackets++;
  0096 450000   [3]             LDHX  @mcPendingPackets
  0099 7c       [4]             INC   ,X
  009a          L9A:    
 1400:    }
 1401:     
 1402:  
 1403:  }
  009a a702     [2]             AIS   #2
  009c 8d       [7]             RTC   
  009d          L9D:    
  009d 89       [2]             PSHX  
  009e 8b       [2]             PSHH  
  009f 450008   [3]             LDHX  @mCoordInfo:8
  00a2 a602     [2]             LDA   #2
  00a4 ac000000 [8]             CALL  FLib_MemCpy
  00a8 a702     [2]             AIS   #2
  00aa 8d       [7]             RTC   
 1404:  
 1405:  /*****************************************************************************
 1406:  * Function to handle a generic key press. Called for all keys.
 1407:  *****************************************************************************/
 1408:  static void App_HandleGenericKey(void)
 1409:  {
 1410:    if(gState == stateInit)
  0000 c60000   [4]             LDA   gState
  0003 262a     [3]             BNE   L2F ;abs = 002f
 1411:    {
 1412:     StopLed1Flashing();
  0005 a601     [2]             LDA   #1
  0007 ac000000 [8]             CALL  LED_StopFlash
 1413:     StopLed2Flashing();
  000b a602     [2]             LDA   #2
  000d ac000000 [8]             CALL  LED_StopFlash
 1414:     StopLed3Flashing();
  0011 a604     [2]             LDA   #4
  0013 ac000000 [8]             CALL  LED_StopFlash
 1415:     StopLed4Flashing();
  0017 a608     [2]             LDA   #8
  0019 ac000000 [8]             CALL  LED_StopFlash
 1416:     Led1Off();
  001d 1000     [5]             BSET  0,0
 1417:     Led2Off();
  001f 1800     [5]             BSET  4,0
 1418:     Led3Off();
  0021 1006     [5]             BSET  0,6
 1419:     Led4Off();
  0023 1206     [5]             BSET  1,6
 1420:     LCD_ClearDisplay();
 1421:     LCD_WriteString(1,"Application");
 1422:     LCD_WriteString(2,"    started");     
 1423:     TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);       
  0025 c60000   [4]             LDA   gAppTaskID_c
  0028 ae01     [2]             LDX   #1
  002a 8c       [1]             CLRH  
  002b ac000000 [8]             CALL  TS_SendEvent
  002f          L2F:    
 1424:    }
 1425:  }
  002f 8d       [7]             RTC   
 1426:  
 1427:  /*****************************************************************************
 1428:  * Handles all key events for this device.
 1429:  * Interface assumptions: None
 1430:  * Return value: None
 1431:  *****************************************************************************/
 1432:  #if (gMC1323xMatrixKBD_d == TRUE)
 1433:  static void App_HandleKeys(uint8_t events, uint8_t pressedKey)   
 1434:  {
 1435:   (void)events;
 1436:   (void)pressedKey;
 1437:   App_HandleGenericKey();
  0000 ac000000 [8]             CALL  App_HandleGenericKey
 1438:  }
  0004 8d       [7]             RTC   
 1439:  #else
 1440:  static void App_HandleKeys(key_event_t events)
 1441:  {
 1442:    switch ( events ) 
 1443:      { 
 1444:        case gKBD_EventSW1_c:
 1445:        case gKBD_EventSW2_c:
 1446:        case gKBD_EventSW3_c:
 1447:        case gKBD_EventSW4_c:
 1448:        case gKBD_EventLongSW1_c:
 1449:        case gKBD_EventLongSW2_c:
 1450:        case gKBD_EventLongSW3_c:
 1451:        case gKBD_EventLongSW4_c:
 1452:         App_HandleGenericKey();
 1453:  	  break; 
 1454:      }    
 1455:  }
 1456:  #endif //gMC1323xMatrixKBD_d
 1457:  
 1458:  /*****************************************************************************
 1459:  * The DeepSleepWakeupStackProc(void) function is called each time the 
 1460:  * application exits the DeepSleep mode .
 1461:  * 
 1462:  * Return value:
 1463:  *     None
 1464:  *****************************************************************************/
 1465:  void DeepSleepWakeupStackProc(void){
 1466:    return;
 1467:  }
  0000 8d       [7]             RTC   
 1468:  
 1469:  /******************************************************************************
 1470:  * The following functions are called by the MAC to put messages into the
 1471:  * Application's queue. They need to be defined even if they are not used
 1472:  * in order to avoid linker errors.
 1473:  ******************************************************************************/
 1474:  
 1475:  uint8_t MLME_NWK_SapHandler(nwkMessage_t * pMsg)
 1476:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
 1477:    /* Put the incoming MLME message in the applications input queue. */
 1478:    MSG_Queue(&mMlmeNwkInputQueue, pMsg);
  0002 450000   [3]             LDHX  @mMlmeNwkInputQueue
  0005 89       [2]             PSHX  
  0006 8b       [2]             PSHH  
  0007 9efe03   [5]             LDHX  3,SP
  000a ac000000 [8]             CALL  List_AddTail
  000e a702     [2]             AIS   #2
 1479:    TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMLME_c);
  0010 c60000   [4]             LDA   gAppTaskID_c
  0013 ae04     [2]             LDX   #4
  0015 8c       [1]             CLRH  
  0016 ac000000 [8]             CALL  TS_SendEvent
 1480:    return gSuccess_c;
  001a 4f       [1]             CLRA  
 1481:  }
  001b a702     [2]             AIS   #2
  001d 8d       [7]             RTC   
 1482:  
 1483:  uint8_t MCPS_NWK_SapHandler(mcpsToNwkMessage_t *pMsg)
 1484:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
 1485:    /* Put the incoming MCPS message in the applications input queue. */
 1486:    MSG_Queue(&mMcpsNwkInputQueue, pMsg);
  0002 450000   [3]             LDHX  @mMcpsNwkInputQueue
  0005 89       [2]             PSHX  
  0006 8b       [2]             PSHH  
  0007 9efe03   [5]             LDHX  3,SP
  000a ac000000 [8]             CALL  List_AddTail
  000e a702     [2]             AIS   #2
 1487:    TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMCPS_c);
  0010 c60000   [4]             LDA   gAppTaskID_c
  0013 ae08     [2]             LDX   #8
  0015 8c       [1]             CLRH  
  0016 ac000000 [8]             CALL  TS_SendEvent
 1488:    return gSuccess_c;
  001a 4f       [1]             CLRA  
 1489:  }
  001b a702     [2]             AIS   #2
  001d 8d       [7]             RTC   
 1490:  
 1491:  uint8_t ASP_APP_SapHandler(aspToAppMsg_t *pMsg)
 1492:  {
 1493:    /* If the message is not handled anywhere it must be freed. */
 1494:    MSG_Free(pMsg);
  0000 ac000000 [8]             CALL  MM_Free
 1495:    return gSuccess_c;
  0004 4f       [1]             CLRA  
 1496:  }
  0005 8d       [7]             RTC   
 1497:  
 1498:  /******************************************************************************
 1499:  * The App_StartScan(scanType) function will start the scan process of the
 1500:  * specified type in the MAC. This is accomplished by allocating a MAC message,
 1501:  * which is then assigned the desired scan parameters and sent to the MLME
 1502:  * service access point. The MAC PIB attributes "macShortAddress", and 
 1503:  * "macAssociatePermit" are modified.
 1504:  *
 1505:  * The function may return either of the following values:
 1506:  *   errorNoError:          The Scan message was sent successfully.
 1507:  *   errorInvalidParameter: The MLME service access point rejected the
 1508:  *                          message due to an invalid parameter.
 1509:  *   errorAllocFailed:      A message buffer could not be allocated.
 1510:  *
 1511:  ******************************************************************************/
 1512:  static uint8_t App_StartRooter(void)
 1513:  {
  0000 a7fb     [2]             AIS   #-5
 1514:    /* Message for the MLME will be allocated and attached to this pointer */
 1515:    mlmeMessage_t *pMsg;
 1516:  
 1517:    UartUtil_Print("Sending the MLME-Start Request message to the MAC...", gAllowToBlock_d);
  0002 450000   [3]             LDHX  @"Sending the MLME-Start Request message to the MAC..."
  0005 ac0000af [8]             CALL  App_StartRooter:175
 1518:    
 1519:    /* Allocate a message for the MLME (We should check for NULL). */
 1520:    pMsg = MSG_AllocType(mlmeMessage_t);
  0009 a60f     [2]             LDA   #15
  000b ac000000 [8]             CALL  MM_Alloc
  000f 9eff01   [5]             STHX  1,SP
 1521:    if(pMsg != NULL)
  0012 2603     [3]             BNE   L17 ;abs = 0017
  0014 cc00a3   [4]             JMP   LA3 ;abs = 00a3
  0017          L17:    
 1522:    {
 1523:      /* Pointer which is used for easy access inside the allocated message */
 1524:      mlmeStartReq_t *pStartReq;
 1525:      /* Return value from MSG_send - used for avoiding compiler warnings */
 1526:      uint8_t ret;
 1527:      /* Boolean value that will be written to the MAC PIB */
 1528:      uint8_t boolFlag;
 1529:      
 1530:      /* Set-up MAC PIB attributes. Please note that Set, Get,
 1531:         and Reset messages are not freed by the MLME. */
 1532:      
 1533:      /* We must always set the short address to something
 1534:         else than 0xFFFF before starting a PAN. */
 1535:      pMsg->msgType = gMlmeSetReq_c;
  0017 a609     [2]             LDA   #9
  0019 f7       [2]             STA   ,X
 1536:      pMsg->msgData.setReq.pibAttribute = gMPibShortAddress_c;
  001a a653     [2]             LDA   #83
  001c e701     [3]             STA   1,X
 1537:      pMsg->msgData.setReq.pibAttributeValue = (uint8_t *)maShortAddress;
  001e a600     [2]             LDA   @maShortAddress:MSB
  0020 e702     [3]             STA   2,X
  0022 a600     [2]             LDA   @maShortAddress
  0024 e703     [3]             STA   3,X
 1538:      ret = MSG_Send(NWK_MLME, pMsg);
  0026 89       [2]             PSHX  
  0027 8b       [2]             PSHH  
  0028 ac000000 [8]             CALL  NWK_MLME_SapHandler
 1539:      
 1540:      /* We must set the Association Permit flag to TRUE 
 1541:         in order to allow devices to associate to us. */
 1542:      pMsg->msgType = gMlmeSetReq_c;
  002c 9efe01   [5]             LDHX  1,SP
  002f a609     [2]             LDA   #9
  0031 f7       [2]             STA   ,X
 1543:      pMsg->msgData.setReq.pibAttribute = gMPibAssociationPermit_c;
  0032 a641     [2]             LDA   #65
  0034 e701     [3]             STA   1,X
 1544:      boolFlag = TRUE;
  0036 a601     [2]             LDA   #1
  0038 95       [2]             TSX   
  0039 e704     [3]             STA   4,X
 1545:      pMsg->msgData.setReq.pibAttributeValue = &boolFlag;
  003b af04     [2]             AIX   #4
  003d 8b       [2]             PSHH  
  003e 9ee602   [4]             LDA   2,SP
  0041 87       [2]             PSHA  
  0042 8a       [3]             PULH  
  0043 9f       [1]             TXA   
  0044 9eee03   [4]             LDX   3,SP
  0047 e703     [3]             STA   3,X
  0049 86       [3]             PULA  
  004a e702     [3]             STA   2,X
 1546:      ret = MSG_Send(NWK_MLME, pMsg);
  004c ac000000 [8]             CALL  NWK_MLME_SapHandler
 1547:      
 1548:      /* This is a MLME-START.req command */
 1549:      pMsg->msgType = gMlmeStartReq_c;
  0050 9efe03   [5]             LDHX  3,SP
  0053 a60a     [2]             LDA   #10
  0055 f7       [2]             STA   ,X
 1550:      
 1551:      /* Create the Start request message data. */
 1552:      pStartReq = &pMsg->msgData.startReq;
  0056 af01     [2]             AIX   #1
  0058 9eff06   [5]             STHX  6,SP
 1553:      /* PAN ID - LSB, MSB. The example shows a PAN ID of 0xBEEF. */
 1554:      FLib_MemCpy(pStartReq->panId, (void *)maPanId, 2);
  005b 89       [2]             PSHX  
  005c 8b       [2]             PSHH  
  005d 450000   [3]             LDHX  @maPanId
  0060 a602     [2]             LDA   #2
  0062 ac000000 [8]             CALL  FLib_MemCpy
  0066 a702     [2]             AIS   #2
 1555:      /* Logical Channel - the default of 11 will be overridden */
 1556:      pStartReq->logicalChannel = mLogicalChannel;
  0068 9efe06   [5]             LDHX  6,SP
  006b c60000   [4]             LDA   mLogicalChannel
  006e e702     [3]             STA   2,X
 1557:      /* Beacon Order: 0xF = turn off beacons, less than 0xF = turn on beacons */
 1558:      pStartReq->beaconOrder = 0x0F;  
  0070 a60f     [2]             LDA   #15
  0072 e703     [3]             STA   3,X
 1559:      /* Superframe Order: Must be equal or less than the beacon order */
 1560:      pStartReq->superFrameOrder = mDefaultValueOfSuperframeOrder_c;
  0074 a606     [2]             LDA   #6
  0076 e704     [3]             STA   4,X
 1561:      /* Be a PAN coordinator */
 1562:      pStartReq->panCoordinator = TRUE;
  0078 a601     [2]             LDA   #1
  007a e705     [3]             STA   5,X
 1563:      /* Dont use battery life extension */
 1564:      pStartReq->batteryLifeExt = FALSE;
  007c 6f06     [5]             CLR   6,X
 1565:      /* This is not a Realignment command */
 1566:      pStartReq->coordRealignment = FALSE;
  007e 6f07     [5]             CLR   7,X
 1567:      /* Dont use security */
 1568:  #ifndef gMAC2006_d	
 1569:      pStartReq->securityEnable = FALSE;
  0080 6f08     [5]             CLR   8,X
 1570:  #else
 1571:  	pStartReq->coordRealignSecurityLevel = 0;
 1572:    pStartReq->beaconSecurityLevel = 0;	
 1573:  #endif //gMAC2006_d	
 1574:        
 1575:      /* Send the Start request to the MLME. */
 1576:      if(MSG_Send(NWK_MLME, pMsg) == gSuccess_c)
  0082 9efe03   [5]             LDHX  3,SP
  0085 ac000000 [8]             CALL  NWK_MLME_SapHandler
  0089 4d       [1]             TSTA  
  008a a702     [2]             AIS   #2
  008c 260a     [3]             BNE   L98 ;abs = 0098
 1577:      {
 1578:        UartUtil_Print("Done\n\r", gAllowToBlock_d);
  008e 450000   [3]             LDHX  @"Done\012\015"
  0091 ac0000af [8]             CALL  App_StartRooter:175
 1579:        return errorNoError;
  0095 4f       [1]             CLRA  
  0096 2014     [3]             BRA   LAC ;abs = 00ac
  0098          L98:    
 1580:      }
 1581:      else
 1582:      {
 1583:        /* One or more parameters in the Start Request message were invalid. */
 1584:        UartUtil_Print("Invalid parameter!\n\r", gAllowToBlock_d);
  0098 450000   [3]             LDHX  @"Invalid parameter!\012\015"
  009b ac0000af [8]             CALL  App_StartRooter:175
 1585:        return errorInvalidParameter;
  009f a605     [2]             LDA   #5
  00a1 2009     [3]             BRA   LAC ;abs = 00ac
  00a3          LA3:    
 1586:      }
 1587:    }
 1588:    else
 1589:    {
 1590:      /* Allocation of a message buffer failed. */
 1591:      UartUtil_Print("Message allocation failed!\n\r", gAllowToBlock_d);
  00a3 450000   [3]             LDHX  @"Message allocation failed!\012\015"
  00a6 ac0000af [8]             CALL  App_StartRooter:175
 1592:      return errorAllocFailed;
  00aa a604     [2]             LDA   #4
  00ac          LAC:    
 1593:    }
 1594:  }
  00ac a705     [2]             AIS   #5
  00ae 8d       [7]             RTC   
  00af          LAF:    
  00af a601     [2]             LDA   #1
  00b1 ac000000 [8]             CALL  UartUtil_Print
  00b5 8d       [7]             RTC   
 1595:  
 1596:  /******************************************************************************
 1597:  * The App_HandleScanEdConfirm(nwkMessage_t *pMsg) function will handle the
 1598:  * ED scan confirm message received from the MLME when the ED scan has completed.
 1599:  * The message contains the ED scan result list. This function will search the
 1600:  * list in order to select the logical channel with the least energy. The
 1601:  * selected channel is stored in the global variable called 'mLogicalChannel'.
 1602:  *
 1603:  ******************************************************************************/
 1604:  static void App_HandleScanEdConfirm(nwkMessage_t *pMsg)
 1605:  {  
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  0002 a7fb     [2]             AIS   #-5
 1606:    uint8_t n, minEnergy;
 1607:    uint8_t *pEdList;
 1608:    uint8_t ChannelMask;
 1609:    
 1610:    UartUtil_Print("Received the MLME-Scan Confirm message from the MAC\n\r", gAllowToBlock_d);
  0004 450000   [3]             LDHX  @"Received the MLME-Scan Confirm message from the MAC\012\015"
  0007 ac0000b0 [8]             CALL  App_HandleScanEdConfirm:176
 1611:      
 1612:    /* Get a pointer to the energy detect results */
 1613:    pEdList = pMsg->msgData.scanCnf.resList.pEnergyDetectList;
  000b 9efe06   [5]             LDHX  6,SP
  000e 9ece08   [5]             LDHX  8,X
  0011 9eff03   [5]             STHX  3,SP
 1614:    
 1615:    /* Set the minimum energy to a large value */
 1616:    minEnergy = 0xFF;
  0014 a6ff     [2]             LDA   #-1
  0016 95       [2]             TSX   
  0017 e704     [3]             STA   4,X
 1617:  
 1618:    /* Select default channel */
 1619:    mLogicalChannel = 11;
  0019 a60b     [2]             LDA   #11
  001b c70000   [4]             STA   mLogicalChannel
 1620:   
 1621:    /* Search for the channel with least energy */
 1622:    for(n=0; n<16; n++)
  001e 6f01     [5]             CLR   1,X
  0020          L20:    
 1623:    {
 1624:      ChannelMask = n + 11;
  0020 95       [2]             TSX   
  0021 e601     [3]             LDA   1,X
  0023 ab0b     [2]             ADD   #11
 1625:  	if((pEdList[n] < minEnergy)&&((uint8_t)((mDefaultValueOfChannel_c>>ChannelMask) & 0x1)))
  0025 f7       [2]             STA   ,X
  0026 e601     [3]             LDA   1,X
  0028 eb03     [3]             ADD   3,X
  002a 87       [2]             PSHA  
  002b 4f       [1]             CLRA  
  002c e902     [3]             ADC   2,X
  002e 87       [2]             PSHA  
  002f e604     [3]             LDA   4,X
  0031 8a       [3]             PULH  
  0032 88       [3]             PULX  
  0033 f1       [3]             CMP   ,X
  0034 232e     [3]             BLS   L64 ;abs = 0064
  0036 4f       [1]             CLRA  
  0037 450200   [3]             LDHX  #512
  003a 87       [2]             PSHA  
  003b 87       [2]             PSHA  
  003c 89       [2]             PSHX  
  003d 8b       [2]             PSHH  
  003e 95       [2]             TSX   
  003f e604     [3]             LDA   4,X
  0041 cd0000   [6]             JSR   _LLSR
  0044 9ee604   [4]             LDA   4,SP
  0047 a501     [2]             BIT   #1
  0049 a708     [2]             AIS   #8
  004b 2717     [3]             BEQ   L64 ;abs = 0064
 1626:      {
 1627:        minEnergy = pEdList[n];
  004d e605     [3]             LDA   5,X
  004f eb07     [3]             ADD   7,X
  0051 87       [2]             PSHA  
  0052 4f       [1]             CLRA  
  0053 e906     [3]             ADC   6,X
  0055 87       [2]             PSHA  
  0056 8a       [3]             PULH  
  0057 88       [3]             PULX  
  0058 fe       [3]             LDX   ,X
  0059 9eef05   [4]             STX   5,SP
 1628:        /* Channel numbering is 11 to 26 both inclusive */
 1629:        mLogicalChannel = n + 11; 
  005c 95       [2]             TSX   
  005d e601     [3]             LDA   1,X
  005f ab0b     [2]             ADD   #11
  0061 c70000   [4]             STA   mLogicalChannel
  0064          L64:    
  0064 95       [2]             TSX   
  0065 6c01     [5]             INC   1,X
  0067 e601     [3]             LDA   1,X
  0069 a110     [2]             CMP   #16
  006b 25b3     [3]             BCS   L20 ;abs = 0020
 1630:      }
 1631:    }
 1632:    
 1633:    /* Print out the result of the ED scan */
 1634:    UartUtil_Print("ED scan returned the following results:\n\r  [", gAllowToBlock_d);
  006d 450000   [3]             LDHX  @"ED scan returned the following results:\012\015  ["
  0070 ac0000b0 [8]             CALL  App_HandleScanEdConfirm:176
 1635:    UartUtil_PrintHex(pEdList, 16, gPrtHexBigEndian_c | gPrtHexSpaces_c);
  0074 9efe03   [5]             LDHX  3,SP
  0077 89       [2]             PSHX  
  0078 8b       [2]             PSHH  
  0079 ae10     [2]             LDX   #16
  007b a609     [2]             LDA   #9
  007d ac000000 [8]             CALL  UartUtil_PrintHex
  0081 a702     [2]             AIS   #2
 1636:    UartUtil_Print("]\n\r\n\r", gAllowToBlock_d);
  0083 450000   [3]             LDHX  @"]\012\015\012\015"
  0086 ac0000b0 [8]             CALL  App_HandleScanEdConfirm:176
 1637:    
 1638:    /* Print out the selected logical channel */
 1639:    UartUtil_Print("Based on the ED scan the logical channel 0x", gAllowToBlock_d);
  008a 450000   [3]             LDHX  @"Based on the ED scan the logical channel 0x"
  008d ac0000b0 [8]             CALL  App_HandleScanEdConfirm:176
 1640:    UartUtil_PrintHex(&mLogicalChannel, 1, 0);
  0091 450000   [3]             LDHX  @mLogicalChannel
  0094 89       [2]             PSHX  
  0095 8b       [2]             PSHH  
  0096 ae01     [2]             LDX   #1
  0098 4f       [1]             CLRA  
  0099 ac000000 [8]             CALL  UartUtil_PrintHex
  009d a702     [2]             AIS   #2
 1641:    UartUtil_Print(" was selected\n\r", gAllowToBlock_d);
  009f 450000   [3]             LDHX  @" was selected\012\015"
  00a2 ac0000b0 [8]             CALL  App_HandleScanEdConfirm:176
 1642:    
 1643:    /* The list of detected energies must be freed. */
 1644:    MSG_Free(pEdList);
  00a6 9efe03   [5]             LDHX  3,SP
  00a9 ac000000 [8]             CALL  MM_Free
 1645:  }
  00ad a707     [2]             AIS   #7
  00af 8d       [7]             RTC   
  00b0          LB0:    
  00b0 a601     [2]             LDA   #1
  00b2 ac000000 [8]             CALL  UartUtil_Print
  00b6 8d       [7]             RTC   
 1646:  
 1647:  /******************************************************************************/
 1648:  
 1649:  
 1650:  
