*** EVALUATION ***
ANSI-C/cC++ Compiler for HC08 V-5.0.41 Build 12319, Nov 15 2012

    1:  /*****************************************************************************
    2:  * MyWirelessApp Demo Beacon End Device application.
    3:  *
    4:  * (c) Copyright 2008, Freescale, Inc. All rights reserved.
    5:  *
    6:  *
    7:  * No part of this document must be reproduced in any form - including copied,
    8:  * transcribed, printed or by any electronic means - without specific written
    9:  * permission from Freescale Semiconductor.
   10:  *
   11:  *****************************************************************************/
   12:  
   13:  #include "MApp.h"
   14:  #include "Sound.h"
   15:  #include "NVM_Interface.h"
   16:  #include "IIC_Interface.h" // New
   17:  //#include "IoConfig.h"
   18:  
   19:  
   20:  /************************************************************************************
   21:  *************************************************************************************
   22:  * Private macros
   23:  *************************************************************************************
   24:  ************************************************************************************/
   25:  
   26:  /* If there are too many pending packets to be send over the air, */
   27:  /* receive mMaxKeysToReceive_c chars. */
   28:  /* The chars will be send over the air when there are no pending packets*/
   29:  #define mMaxKeysToReceive_c 32
   30:  
   31:  //----------Sensor switch--------
   32:  #define gMPL3115A2_enable 0
   33:  #define gMMA8652_enable   1
   34:  #define gMAG3110_enable   0
   35:  #define gFXAS21000_enable 0
   36:  #define gMMA9553_enable   0
   37:  //-------------------------------
   38:  
   39:  /************************************************************************************
   40:  *************************************************************************************
   41:  * Private prototypes
   42:  *************************************************************************************
   43:  ************************************************************************************/
   44:  
   45:  /* Forward declarations of helper functions */
   46:  static void    UartRxCallBack(void);
   47:  static uint8_t App_StartScan(uint8_t scanType);
   48:  static uint8_t App_HandleScanActiveConfirm(nwkMessage_t *pMsg);
   49:  static uint8_t App_WaitMsg(nwkMessage_t *pMsg, uint8_t msgType);
   50:  static uint8_t App_SendAssociateRequest(void);
   51:  static uint8_t App_HandleAssociateConfirm(nwkMessage_t *pMsg);
   52:  static void    App_HandleMcpsInput(mcpsToNwkMessage_t *pMsgIn);
   53:  static void    App_TransmitSensorData(void);
   54:  #if (gMC1323xMatrixKBD_d == TRUE)
   55:  static void    App_HandleKeys(uint8_t events, uint8_t pressedKey);
   56:  #else
   57:  static void    App_HandleKeys(key_event_t events);
   58:  #endif //gMC1323xMatrixKBD_d
   59:  
   60:  static uint8_t App_HandleMlmeInput(nwkMessage_t *pMsg);
   61:  static uint8_t App_SendSyncRequest(void);
   62:  static void GenandTransData(uint8_t Length, uint8_t* pTxData, uint8_t* dest_addr);
   63:  
   64:  static void count_timer  (uint8_t timerId);
   65:  
   66:  /* added by yusk */
   67:  static void App_TransmitUartData(void);
   68:  
   69:  volatile static uint8_t global_counter;
   70:  
   71:  static void count_timer(uint8_t timerId){
   72:  	uint8_t data[2];
   73:  	(void)timerId;  /* prevent compiler warning */
   74:  	global_counter++;
  0000 450000   [3]             LDHX  @global_counter
  0003 7c       [4]             INC   ,X
   75:  }
  0004 8d       [7]             RTC   
   76:  
   77:  /************************************************************************************
   78:  *************************************************************************************
   79:  * Private memory declarations
   80:  *************************************************************************************
   81:  ************************************************************************************/
   82:  
   83:  //Default Pan ID
   84:  static const uint8_t coordinaterPanId[2] = { (mDefaultValueOfPanId_c & 0xff), (mDefaultValueOfPanId_c >> 8)};
   85:  
   86:  /* The short address and PAN ID of the coordinator*/
   87:  static const uint8_t maShortAddress[2] = { (mDefaultValueOfShortAddress_c & 0xff), (mDefaultValueOfShortAddress_c >> 8)};
   88:  static const uint8_t maPanId[2] = { (mDefaultValueOfPanId_c & 0xff), (mDefaultValueOfPanId_c >> 8)};
   89:  
   90:  /************************************************************************************
   91:  *************************************************************************************
   92:  * Private memory declarations
   93:  *************************************************************************************
   94:  ************************************************************************************/
   95:  
   96:  /* Information about the PAN we are part of */
   97:  static panDescriptor_t mCoordInfo;
   98:  
   99:  /* This is either the short address assigned by the PAN coordinator
  100:     during association, or our own extended MAC address. */
  101:  static uint8_t maMyAddress[8];
  102:  
  103:  /* The devices address mode. If 2 (gAddrModeShort_c), then maMyAddress
  104:     contains the short address assigned by the PAN coordinator. If 3
  105:     (gAddrModeLong_c), then maMyAddress is equal to the extended address. */
  106:  static uint8_t mAddrMode;
  107:  
  108:  /* Data request packet for sending UART input to the coordinator */
  109:  static nwkToMcpsMessage_t *mpPacket;
  110:  
  111:  /* The MSDU handle is a unique data packet identifier */
  112:  static uint8_t mMsduHandle;
  113:  
  114:  /* Number of pending data packets */
  115:  static uint8_t mcPendingPackets;
  116:  
  117:  /* Application input queues */
  118:  static anchor_t mMlmeNwkInputQueue;
  119:  static anchor_t mMcpsNwkInputQueue;
  120:  
  121:  
  122:  /* The current logical channel (frequency band) */
  123:  static uint8_t mLogicalChannel;//New ueda
  124:  
  125:  /************************************************************************************
  126:  *************************************************************************************
  127:  * Public memory declarations
  128:  *************************************************************************************
  129:  ************************************************************************************/
  130:  
  131:  /* The current state of the applications state machine */
  132:  uint8_t gState;
  133:  
  134:  uint8_t MPL3115A2_start_flag = 0;
  135:  uint8_t MMA8652_start_flag   = 0;
  136:  uint8_t MAG3110_start_flag   = 0;
  137:  uint8_t FXAS21000_start_flag = 0;
  138:  uint8_t MMA9553_start_flag   = 0;
  139:  
  140:  /* This data set contains application variables to be preserved across resets */
  141:  NvDataItemDescription_t const gaNvAppDataSet[] = {
  142:    {NULL, 0}       /* Required end-of-table marker. */
  143:  };
  144:  
  145:  STATIC tmrTimerID_t mTimerID = gTmrInvalidTimerID_c;
  146:  
  147:  /************************************************************************************
  148:  *************************************************************************************
  149:  * Public functions
  150:  *************************************************************************************
  151:  ************************************************************************************/
  152:  
  153:  void DeepSleepWakeupStackProc(void);
  154:  
  155:  /*****************************************************************************
  156:  * Initialization function for the App Task. This is called during
  157:  * initialization and should contain any application specific initialization
  158:  * (ie. hardware initialization/setup, table initialization, power up
  159:  * notificaiton.
  160:  *
  161:  * Interface assumptions: None
  162:  *
  163:  * Return value: None
  164:  *
  165:  *****************************************************************************/
  166:  void MApp_init(void)
  167:  { 
  168:    
  169:    /* The initial application state */
  170:    gState = stateInit;    
  0000 4f       [1]             CLRA  
  0001 c70000   [4]             STA   gState
  171:    /* Reset number of pending packets */
  172:    mcPendingPackets = 0;
  0004 c70000   [4]             STA   mcPendingPackets
  173:  
  174:    /* Initialize the MAC 802.15.4 extended address */
  175:    Init_MacExtendedAddress();
  0007 ac000000 [8]             CALL  Init_MacExtendedAddress
  176:    /* register keyboard callback function */
  177:    KBD_Init(App_HandleKeys);
  000b 450000   [3]             LDHX  @App_HandleKeys
  000e 89       [2]             PSHX  
  000f 8b       [2]             PSHH  
  0010 a600     [2]             LDA   @App_HandleKeys:PAGE
  0012 87       [2]             PSHA  
  0013 ac000000 [8]             CALL  KBD_Init
  0017 a703     [2]             AIS   #3
  178:    /* Initialize SPI Module */
  179:    SPI_Init();
  0019 ac000000 [8]             CALL  SPI1_Init
  180:    /* initialize LCD Module */
  181:    LCD_Init();
  182:    /* initialize LED Module */
  183:    LED_Init();
  001d ac000000 [8]             CALL  LED_Init
  184:    /* Initialize the LPM module */
  185:    PWRLib_Init();
  0021 ac000000 [8]             CALL  PWRLib_Init
  186:    /* Initialize the UART so that we can print out status messages */
  187:    UartX_SetBaud(gUartDefaultBaud_c);
  0025 ae34     [2]             LDX   #52
  0027 8c       [1]             CLRH  
  0028 ac000000 [8]             CALL  Uart1_SetBaud
  188:    UartX_SetRxCallBack(UartRxCallBack);
  002c 450000   [3]             LDHX  @UartRxCallBack
  002f 89       [2]             PSHX  
  0030 8b       [2]             PSHH  
  0031 a600     [2]             LDA   @UartRxCallBack:PAGE
  0033 87       [2]             PSHA  
  0034 ac000000 [8]             CALL  Uart1_SetRxCallBack
  0038 a703     [2]             AIS   #3
  189:    
  190:    /* Initialize the IIC module */
  191:    IIC_Bus_Reset();  // Reset IIC bus to prevent freezing sensor module using GPIO 
  003a ac000000 [8]             CALL  IIC_Bus_Reset
  192:    IIC_ModuleInit(); // New      
  003e ac000000 [8]             CALL  IIC_ModuleInit
  193:        
  194:  #if gMPL3115A2_enable
  195:    MPL3115A2_Init();
  196:  #endif
  197:    
  198:  #if gMMA8652_enable
  199:    MMA8652_Init();
  0042 ac000000 [8]             CALL  MMA8652_Init
  200:  #endif   
  201:  
  202:  #if gMAG3110_enable
  203:    MAG3110_Init();
  204:  #endif 
  205:    
  206:  #if gFXAS21000_enable
  207:    FXAS21000_Init();
  208:  #endif 
  209:   
  210:  #if gMMA9553_enable
  211:    MMA9553_Init();
  212:  #endif   
  213:    
  214:    /* initialize buzzer (NCB, SRB only) */  
  215:    BuzzerInit();  
  216:    /* Prepare input queues.*/
  217:    MSG_InitQueue(&mMlmeNwkInputQueue); 
  0046 450000   [3]             LDHX  @mMlmeNwkInputQueue
  0049 ac000000 [8]             CALL  List_ClearAnchor
  218:    MSG_InitQueue(&mMcpsNwkInputQueue);  
  004d 450000   [3]             LDHX  @mMcpsNwkInputQueue
  0050 ac000000 [8]             CALL  List_ClearAnchor
  219:    /* Enable MCU interrupts */
  220:    IrqControlLib_EnableAllIrqs();
  0054 9a       [1]             CLI   
  221:    /*signal app ready*/  
  222:    Led1Flashing();
  0055 a601     [2]             LDA   #1
  0057 ac000000 [8]             CALL  LED_StartFlash
  223:    Led2Flashing();
  005b a602     [2]             LDA   #2
  005d ac000000 [8]             CALL  LED_StartFlash
  224:    Led3Flashing();
  0061 a604     [2]             LDA   #4
  0063 ac000000 [8]             CALL  LED_StartFlash
  225:    Led4Flashing();
  0067 a608     [2]             LDA   #8
  0069 ac000000 [8]             CALL  LED_StartFlash
  226:      
  227:    UartUtil_Print("\n\rPress any switch on board to start running the application.\n\r", gAllowToBlock_d);  
  006d 450000   [3]             LDHX  @"\012\015Press any switch on board to start running the application.\012\015"
  0070 a601     [2]             LDA   #1
  0072 ac000000 [8]             CALL  UartUtil_Print
  228:    
  229:    LCD_WriteString(1,"Press any key");
  230:    LCD_WriteString(2,"to start.");
  231:    
  232:    mTimerID = TMR_AllocateTimer();
  0076 ac000000 [8]             CALL  TMR_AllocateTimer
  007a c70000   [4]             STA   mTimerID
  233:    TMR_StartIntervalTimer(mTimerID, 1000, count_timer);
  007d 87       [2]             PSHA  
  007e 4503e8   [3]             LDHX  #1000
  0081 89       [2]             PSHX  
  0082 8b       [2]             PSHH  
  0083 4f       [1]             CLRA  
  0084 87       [2]             PSHA  
  0085 87       [2]             PSHA  
  0086 450000   [3]             LDHX  @count_timer
  0089 89       [2]             PSHX  
  008a 8b       [2]             PSHH  
  008b a600     [2]             LDA   @count_timer:PAGE
  008d 87       [2]             PSHA  
  008e ac000000 [8]             CALL  TMR_StartIntervalTimer
  0092 a708     [2]             AIS   #8
  234:    
  235:  }
  0094 8d       [7]             RTC   
